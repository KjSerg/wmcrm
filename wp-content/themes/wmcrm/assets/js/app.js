/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/broker-factory/build/es2019/guards/message-port.js":
/*!*************************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/guards/message-port.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isMessagePort: () => (/* binding */ isMessagePort)
/* harmony export */ });
const isMessagePort = (sender) => {
    return typeof sender.start === 'function';
};
//# sourceMappingURL=message-port.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/helpers/extend-broker-implementation.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/helpers/extend-broker-implementation.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extendBrokerImplementation: () => (/* binding */ extendBrokerImplementation)
/* harmony export */ });
/* harmony import */ var _port_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./port-map */ "./node_modules/broker-factory/build/es2019/helpers/port-map.js");

const extendBrokerImplementation = (partialBrokerImplementation) => ({
    ...partialBrokerImplementation,
    connect: ({ call }) => {
        return async () => {
            const { port1, port2 } = new MessageChannel();
            const portId = await call('connect', { port: port1 }, [port1]);
            _port_map__WEBPACK_IMPORTED_MODULE_0__.PORT_MAP.set(port2, portId);
            return port2;
        };
    },
    disconnect: ({ call }) => {
        return async (port) => {
            const portId = _port_map__WEBPACK_IMPORTED_MODULE_0__.PORT_MAP.get(port);
            if (portId === undefined) {
                throw new Error('The given port is not connected.');
            }
            await call('disconnect', { portId });
        };
    },
    isSupported: ({ call }) => {
        return () => call('isSupported');
    }
});
//# sourceMappingURL=extend-broker-implementation.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/helpers/port-map.js":
/*!**********************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/helpers/port-map.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PORT_MAP: () => (/* binding */ PORT_MAP)
/* harmony export */ });
const PORT_MAP = new WeakMap();
//# sourceMappingURL=port-map.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/interfaces/broker-actions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/interfaces/broker-actions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=broker-actions.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/interfaces/broker-definition.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/interfaces/broker-definition.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=broker-definition.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/interfaces/default-broker-definition.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/interfaces/default-broker-definition.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=default-broker-definition.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/interfaces/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/interfaces/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _broker_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broker-actions */ "./node_modules/broker-factory/build/es2019/interfaces/broker-actions.js");
/* harmony import */ var _broker_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./broker-definition */ "./node_modules/broker-factory/build/es2019/interfaces/broker-definition.js");
/* harmony import */ var _default_broker_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./default-broker-definition */ "./node_modules/broker-factory/build/es2019/interfaces/default-broker-definition.js");
/* harmony import */ var _worker_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-event */ "./node_modules/broker-factory/build/es2019/interfaces/worker-event.js");




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/interfaces/worker-event.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/interfaces/worker-event.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=worker-event.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/module.js":
/*!************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createBroker: () => (/* binding */ createBroker)
/* harmony export */ });
/* harmony import */ var fast_unique_numbers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-unique-numbers */ "./node_modules/fast-unique-numbers/build/es5/bundle.js");
/* harmony import */ var fast_unique_numbers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_unique_numbers__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _guards_message_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./guards/message-port */ "./node_modules/broker-factory/build/es2019/guards/message-port.js");
/* harmony import */ var _helpers_extend_broker_implementation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/extend-broker-implementation */ "./node_modules/broker-factory/build/es2019/helpers/extend-broker-implementation.js");
/* harmony import */ var _interfaces_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interfaces/index */ "./node_modules/broker-factory/build/es2019/interfaces/index.js");
/* harmony import */ var _types_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types/index */ "./node_modules/broker-factory/build/es2019/types/index.js");



/*
 * @todo Explicitly referencing the barrel file seems to be necessary when enabling the
 * isolatedModules compiler option.
 */


const ONGOING_REQUESTS = new WeakMap();
const createOrGetOngoingRequests = (sender) => {
    if (ONGOING_REQUESTS.has(sender)) {
        // @todo TypeScript needs to be convinced that has() works as expected.
        return ONGOING_REQUESTS.get(sender);
    }
    const ongoingRequests = new Map();
    ONGOING_REQUESTS.set(sender, ongoingRequests);
    return ongoingRequests;
};
const createBroker = (brokerImplementation) => {
    const fullBrokerImplementation = (0,_helpers_extend_broker_implementation__WEBPACK_IMPORTED_MODULE_2__.extendBrokerImplementation)(brokerImplementation);
    return (sender) => {
        const ongoingRequests = createOrGetOngoingRequests(sender);
        sender.addEventListener('message', (({ data: message }) => {
            const { id } = message;
            if (id !== null && ongoingRequests.has(id)) {
                const { reject, resolve } = ongoingRequests.get(id);
                ongoingRequests.delete(id);
                if (message.error === undefined) {
                    resolve(message.result);
                }
                else {
                    reject(new Error(message.error.message));
                }
            }
        }));
        if ((0,_guards_message_port__WEBPACK_IMPORTED_MODULE_1__.isMessagePort)(sender)) {
            sender.start();
        }
        const call = (method, params = null, transferables = []) => {
            return new Promise((resolve, reject) => {
                const id = (0,fast_unique_numbers__WEBPACK_IMPORTED_MODULE_0__.generateUniqueNumber)(ongoingRequests);
                ongoingRequests.set(id, { reject, resolve });
                if (params === null) {
                    sender.postMessage({ id, method }, transferables);
                }
                else {
                    sender.postMessage({ id, method, params }, transferables);
                }
            });
        };
        const notify = (method, params, transferables = []) => {
            sender.postMessage({ id: null, method, params }, transferables);
        };
        let functions = {};
        for (const [key, handler] of Object.entries(fullBrokerImplementation)) {
            functions = { ...functions, [key]: handler({ call, notify }) };
        }
        return { ...functions };
    };
};
//# sourceMappingURL=module.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/types/broker-implementation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/types/broker-implementation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=broker-implementation.js.map

/***/ }),

/***/ "./node_modules/broker-factory/build/es2019/types/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/broker-factory/build/es2019/types/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _broker_implementation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broker-implementation */ "./node_modules/broker-factory/build/es2019/types/broker-implementation.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/fast-unique-numbers/build/es5/bundle.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-unique-numbers/build/es5/bundle.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {
      return function (set) {
        var number = generateUniqueNumber(set);
        set.add(number);
        return number;
      };
    };

    var createCache = function createCache(lastNumberWeakMap) {
      return function (collection, nextNumber) {
        lastNumberWeakMap.set(collection, nextNumber);
        return nextNumber;
      };
    };

    /*
     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it
     * is fairly new.
     */
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {
      return function (collection) {
        var lastNumber = lastNumberWeakMap.get(collection);
        /*
         * Let's try the cheapest algorithm first. It might fail to produce a new
         * number, but it is so cheap that it is okay to take the risk. Just
         * increase the last number by one or reset it to 0 if we reached the upper
         * bound of SMIs (which stands for small integers). When the last number is
         * unknown it is assumed that the collection contains zero based consecutive
         * numbers.
         */
        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
        if (!collection.has(nextNumber)) {
          return cache(collection, nextNumber);
        }
        /*
         * If there are less than half of 2 ** 30 numbers stored in the collection,
         * the chance to generate a new random number in the range from 0 to 2 ** 30
         * is at least 50%. It's benifitial to use only SMIs because they perform
         * much better in any environment based on V8.
         */
        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
          while (collection.has(nextNumber)) {
            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
          }
          return cache(collection, nextNumber);
        }
        // Quickly check if there is a theoretical chance to generate a new number.
        if (collection.size > MAX_SAFE_INTEGER) {
          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');
        }
        // Otherwise use the full scale of safely usable integers.
        while (collection.has(nextNumber)) {
          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
        }
        return cache(collection, nextNumber);
      };
    };

    var LAST_NUMBER_WEAK_MAP = new WeakMap();
    var cache = createCache(LAST_NUMBER_WEAK_MAP);
    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);

    exports.addUniqueNumber = addUniqueNumber;
    exports.generateUniqueNumber = generateUniqueNumber;

}));


/***/ }),

/***/ "./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Handle stopping all sounds globally.
     */
    stop: function() {
      var self = this || Howler;

      // Loop through all Howls and stop them.
      for (var i=0; i<self._howls.length; i++) {
        self._howls[i].stop();
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var ua = self._navigator ? self._navigator.userAgent : '';
      var checkOpera = ua.match(/OPR\/(\d+)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
      var safariVersion = ua.match(/Version\/(.*?) /);
      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        while (self._html5AudioPool.length < self.html5PoolSize) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
            break;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);
          document.removeEventListener('keydown', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);
      document.addEventListener('keydown', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';

        // Handle updating the state of the audio context after suspending.
        var handleSuspension = function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        };

        // Either the state gets suspended or it is interrupted.
        // Either way, we need to update the state to suspended.
        self.ctx.suspend().then(handleSuspension, handleSuspension);
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhr = {
        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
      };

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload && self._preload !== 'none') {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                  } else {
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;
          self._state = 'loading';

          var listener = function() {
            self._state = 'loaded';
            
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = Math.min(Math.max(0, parseFloat(from)), 1);
      to = Math.min(Math.max(0, parseFloat(to)), 1);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Make sure the volume is in the right bounds.
        if (diff < 0) {
          vol = Math.max(to, vol);
        } else {
          vol = Math.min(to, vol);
        }

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;

              // If playing, restart playback to ensure looping updates.
              if (self.playing(ids[i])) {
                self.pause(ids[i], true);
                self.play(ids[i], true);
              }
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        if (self._sounds.length) {
          id = self._sounds[0]._id;
        }
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return 0;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }

            self._emit('seek', id);
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (!node.bufferSource) {
        return self;
      }

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Listen for the 'ended' event on the sound to account for edge-case where
        // a finite sound has a duration of Infinity.
        self._endFn = self._endListener.bind(self);
        self._node.addEventListener('ended', self._endFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    },

    /**
     * HTML5 Audio ended listener callback.
     */
    _endListener: function() {
      var self = this;
      var parent = self._parent;

      // Only handle the `ended`` event if the duration is Infinity.
      if (parent._duration === Infinity) {
        // Update the parent duration to match the real audio duration.
        // Round up the duration to account for the lower precision in HTML5 Audio.
        parent._duration = Math.ceil(self._node.duration * 10) / 10;

        // Update the sprite that corresponds to the real duration.
        if (parent._sprite.__default[1] === Infinity) {
          parent._sprite.__default[1] = parent._duration * 1000;
        }

        // Run the regular ended method.
        parent._ended(self);
      }

      // Clear the event listener since the duration is now correct.
      self._node.removeEventListener('ended', self._endFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open(self._xhr.method, url, true);
      xhr.withCredentials = self._xhr.withCredentials;
      xhr.responseType = 'arraybuffer';

      // Apply any custom headers to the request.
      if (self._xhr.headers) {
        Object.keys(self._xhr.headers).forEach(function(key) {
          xhr.setRequestHeader(key, self._xhr.headers[key]);
        });
      }

      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  // Add support for CommonJS libraries such as browserify.
  if (true) {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Add to global in Node.js (for testing, etc).
  if (typeof __webpack_require__.g !== 'undefined') {
    __webpack_require__.g.HowlerGlobal = HowlerGlobal;
    __webpack_require__.g.Howler = Howler;
    __webpack_require__.g.Howl = Howl;
    __webpack_require__.g.Sound = Sound;
  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Create a new panner node if one doesn't already exist.
        var panner = sound._panner;
        if (!panner) {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
          panner = sound._panner
        }

        // Update the panner values or create a new panner if none exists.
        panner.coneInnerAngle = pa.coneInnerAngle;
        panner.coneOuterAngle = pa.coneOuterAngle;
        panner.coneOuterGain = pa.coneOuterGain;
        panner.distanceModel = pa.distanceModel;
        panner.maxDistance = pa.maxDistance;
        panner.refDistance = pa.refDistance;
        panner.rolloffFactor = pa.rolloffFactor;
        panner.panningModel = pa.panningModel;
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();


/***/ }),

/***/ "./node_modules/jquery-ui/ui/keycode.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery-ui/ui/keycode.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Keycode 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: https://api.jqueryui.com/jQuery.ui.keyCode/

( function( factory ) {
	"use strict";

	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} )( function( $ ) {
"use strict";

return $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

} );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/version.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery-ui/ui/version.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	"use strict";

	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} )( function( $ ) {
"use strict";

$.ui = $.ui || {};

return $.ui.version = "1.14.1";

} );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/widgets/datepicker.js":
/*!*********************************************************!*\
  !*** ./node_modules/jquery-ui/ui/widgets/datepicker.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable max-len, camelcase */
/*!
 * jQuery UI Datepicker 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//>>label: Datepicker
//>>group: Widgets
//>>description: Displays a calendar from an input or inline for selecting dates.
//>>docs: https://api.jqueryui.com/datepicker/
//>>demos: https://jqueryui.com/datepicker/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/datepicker.css
//>>css.theme: ../../themes/base/theme.css

( function( factory ) {
	"use strict";

	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"),
			__webpack_require__(/*! ../version */ "./node_modules/jquery-ui/ui/version.js"),
			__webpack_require__(/*! ../keycode */ "./node_modules/jquery-ui/ui/keycode.js")
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} )( function( $ ) {
"use strict";

$.extend( $.ui, { datepicker: { version: "1.14.1" } } );

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {

		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {

			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[ "" ] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: [ "January", "February", "March", "April", "May", "June",
			"July", "August", "September", "October", "November", "December" ], // Names of months for drop-down and formatting
		monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
		dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
		dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
		dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "", // Additional text to append to the year in the month headers,
		selectMonthLabel: "Select month", // Invisible label for month selector
		selectYearLabel: "Select year" // Invisible label for year selector
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		onUpdateDatepicker: null, // Define a callback function when the datepicker is updated
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend( this._defaults, this.regional[ "" ] );
	this.regional.en = $.extend( true, {}, this.regional[ "" ] );
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
}

$.extend( Datepicker.prototype, {

	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function( settings ) {
		datepicker_extendRemove( this._defaults, settings || {} );
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function( target, settings ) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = ( nodeName === "div" || nodeName === "span" );
		if ( !target.id ) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst( $( target ), inline );
		inst.settings = $.extend( {}, settings || {} );
		if ( nodeName === "input" ) {
			this._connectDatepicker( target, inst );
		} else if ( inline ) {
			this._inlineDatepicker( target, inst );
		}
	},

	/* Create a new instance object. */
	_newInst: function( target, inline ) {
		var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
		return { id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: ( !inline ? this.dpDiv : // presentation div
			datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function( target, inst ) {
		var input = $( target );
		inst.append = $( [] );
		inst.trigger = $( [] );
		if ( input.hasClass( this.markerClassName ) ) {
			return;
		}
		this._attachments( input, inst );
		input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
			on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
		this._autoSize( inst );
		$.data( target, "datepicker", inst );

		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function( input, inst ) {
		var showOn, buttonText, buttonImage,
			appendText = this._get( inst, "appendText" ),
			isRTL = this._get( inst, "isRTL" );

		if ( inst.append ) {
			inst.append.remove();
		}
		if ( appendText ) {
			inst.append = $( "<span>" )
				.addClass( this._appendClass )
				.text( appendText );
			input[ isRTL ? "before" : "after" ]( inst.append );
		}

		input.off( "focus", this._showDatepicker );

		if ( inst.trigger ) {
			inst.trigger.remove();
		}

		showOn = this._get( inst, "showOn" );
		if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
			input.on( "focus", this._showDatepicker );
		}
		if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
			buttonText = this._get( inst, "buttonText" );
			buttonImage = this._get( inst, "buttonImage" );

			if ( this._get( inst, "buttonImageOnly" ) ) {
				inst.trigger = $( "<img>" )
					.addClass( this._triggerClass )
					.attr( {
						src: buttonImage,
						alt: buttonText,
						title: buttonText
					} );
			} else {
				inst.trigger = $( "<button type='button'>" )
					.addClass( this._triggerClass );
				if ( buttonImage ) {
					inst.trigger.html(
						$( "<img>" )
							.attr( {
								src: buttonImage,
								alt: buttonText,
								title: buttonText
							} )
					);
				} else {
					inst.trigger.text( buttonText );
				}
			}

			input[ isRTL ? "before" : "after" ]( inst.trigger );
			inst.trigger.on( "click", function() {
				if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
					$.datepicker._hideDatepicker();
				} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker( input[ 0 ] );
				} else {
					$.datepicker._showDatepicker( input[ 0 ] );
				}
				return false;
			} );
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function( inst ) {
		if ( this._get( inst, "autoSize" ) && !inst.inline ) {
			var findMax, max, maxI, i,
				date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
				dateFormat = this._get( inst, "dateFormat" );

			if ( dateFormat.match( /[DM]/ ) ) {
				findMax = function( names ) {
					max = 0;
					maxI = 0;
					for ( i = 0; i < names.length; i++ ) {
						if ( names[ i ].length > max ) {
							max = names[ i ].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
					"monthNames" : "monthNamesShort" ) ) ) );
				date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
					"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
			}
			inst.input.attr( "size", this._formatDate( inst, date ).length );
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function( target, inst ) {
		var divSpan = $( target );
		if ( divSpan.hasClass( this.markerClassName ) ) {
			return;
		}
		divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
		$.data( target, "datepicker", inst );
		this._setDate( inst, this._getDefaultDate( inst ), true );
		this._updateDatepicker( inst );
		this._updateAlternate( inst );

		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}

		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// https://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function( input, date, onSelect, settings, pos ) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if ( !inst ) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $( "<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>" );
			this._dialogInput.on( "keydown", this._doKeyDown );
			$( "body" ).append( this._dialogInput );
			inst = this._dialogInst = this._newInst( this._dialogInput, false );
			inst.settings = {};
			$.data( this._dialogInput[ 0 ], "datepicker", inst );
		}
		datepicker_extendRemove( inst.settings, settings || {} );
		date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
		this._dialogInput.val( date );

		this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
		if ( !this._pos ) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
		}

		// Move input on screen for focus, but hidden behind dialog
		this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass( this._dialogClass );
		this._showDatepicker( this._dialogInput[ 0 ] );
		if ( $.blockUI ) {
			$.blockUI( this.dpDiv );
		}
		$.data( this._dialogInput[ 0 ], "datepicker", inst );
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function( target ) {
		var nodeName,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData( target, "datepicker" );
		if ( nodeName === "input" ) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass( this.markerClassName ).
				off( "focus", this._showDatepicker ).
				off( "keydown", this._doKeyDown ).
				off( "keypress", this._doKeyPress ).
				off( "keyup", this._doKeyUp );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			$target.removeClass( this.markerClassName ).empty();
		}

		$.datepicker._hideDatepicker();
		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
			this._curInst = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = false;
			inst.trigger.filter( "button" ).
				each( function() {
					this.disabled = false;
				} ).end().
				filter( "img" ).css( { opacity: "1.0", cursor: "" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().removeClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", false );
		}
		this._disabledInputs = $.map( this._disabledInputs,

			// Delete entry
			function( value ) {
				return ( value === target ? null : value );
			} );
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = true;
			inst.trigger.filter( "button" ).
				each( function() {
					this.disabled = true;
				} ).end().
				filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().addClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", true );
		}
		this._disabledInputs = $.map( this._disabledInputs,

			// Delete entry
			function( value ) {
				return ( value === target ? null : value );
			} );
		this._disabledInputs[ this._disabledInputs.length ] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function( target ) {
		if ( !target ) {
			return false;
		}
		for ( var i = 0; i < this._disabledInputs.length; i++ ) {
			if ( this._disabledInputs[ i ] === target ) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function( target ) {
		try {
			return $.data( target, "datepicker" );
		} catch ( err ) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function( target, name, value ) {
		var settings, date, minDate, maxDate,
			inst = this._getInst( target );

		if ( arguments.length === 2 && typeof name === "string" ) {
			return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
				( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
				this._get( inst, name ) ) : null ) );
		}

		settings = name || {};
		if ( typeof name === "string" ) {
			settings = {};
			settings[ name ] = value;
		}

		if ( inst ) {
			if ( this._curInst === inst ) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker( target, true );
			minDate = this._getMinMaxDate( inst, "min" );
			maxDate = this._getMinMaxDate( inst, "max" );
			datepicker_extendRemove( inst.settings, settings );

			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
				inst.settings.minDate = this._formatDate( inst, minDate );
			}
			if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
				inst.settings.maxDate = this._formatDate( inst, maxDate );
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker( target );
				} else {
					this._enableDatepicker( target );
				}
			}
			this._attachments( $( target ), inst );
			this._autoSize( inst );
			this._setDate( inst, date );
			this._updateAlternate( inst );
			this._updateDatepicker( inst );
		}
	},

	// Change method deprecated
	_changeDatepicker: function( target, name, value ) {
		this._optionDatepicker( target, name, value );
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function( target ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._updateDatepicker( inst );
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function( target, date ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._setDate( inst, date );
			this._updateDatepicker( inst );
			this._updateAlternate( inst );
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function( target, noDefault ) {
		var inst = this._getInst( target );
		if ( inst && !inst.inline ) {
			this._setDateFromField( inst, noDefault );
		}
		return ( inst ? this._getDate( inst ) : null );
	},

	/* Handle keystrokes. */
	_doKeyDown: function( event ) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst( event.target ),
			handled = true,
			isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );

		inst._keyEvent = true;
		if ( $.datepicker._datepickerShowing ) {
			switch ( event.keyCode ) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv );
						if ( sel[ 0 ] ) {
							$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
						}

						onSelect = $.datepicker._get( inst, "onSelect" );
						if ( onSelect ) {
							dateStr = $.datepicker._formatDate( inst );

							// Trigger custom callback
							onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							-$.datepicker._get( inst, "stepBigMonths" ) :
							-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							+$.datepicker._get( inst, "stepBigMonths" ) :
							+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // next month/year on page down/+ ctrl
				case 35: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._clearDate( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._gotoToday( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// -1 day on ctrl or command +left
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								-$.datepicker._get( inst, "stepBigMonths" ) :
								-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +left on Mac
						break;
				case 38: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, -7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// +1 day on ctrl or command +right
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								+$.datepicker._get( inst, "stepBigMonths" ) :
								+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +right
						break;
				case 40: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, +7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker( this );
		} else {
			handled = false;
		}

		if ( handled ) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function( event ) {
		var chars, chr,
			inst = $.datepicker._getInst( event.target );

		if ( $.datepicker._get( inst, "constrainInput" ) ) {
			chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
			chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
			return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function( event ) {
		var date,
			inst = $.datepicker._getInst( event.target );

		if ( inst.input.val() !== inst.lastVal ) {
			try {
				date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
					( inst.input ? inst.input.val() : null ),
					$.datepicker._getFormatConfig( inst ) );

				if ( date ) { // only if valid
					$.datepicker._setDateFromField( inst );
					$.datepicker._updateAlternate( inst );
					$.datepicker._updateDatepicker( inst );
				}
			} catch ( err ) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function( input ) {
		input = input.target || input;
		if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
			input = $( "input", input.parentNode )[ 0 ];
		}

		if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst( input );
		if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
			$.datepicker._curInst.dpDiv.stop( true, true );
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
			}
		}

		beforeShow = $.datepicker._get( inst, "beforeShow" );
		beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
		if ( beforeShowSettings === false ) {
			return;
		}
		datepicker_extendRemove( inst.settings, beforeShowSettings );

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField( inst );

		if ( $.datepicker._inDialog ) { // hide cursor
			input.value = "";
		}
		if ( !$.datepicker._pos ) { // position below input
			$.datepicker._pos = $.datepicker._findPos( input );
			$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$( input ).parents().each( function() {
			isFixed |= $( this ).css( "position" ) === "fixed";
			return !isFixed;
		} );

		offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
		$.datepicker._pos = null;

		//to avoid flashes on Firefox
		inst.dpDiv.empty();

		// determine sizing offscreen
		inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
		$.datepicker._updateDatepicker( inst );

		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset( inst, offset, isFixed );
		inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
			"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
			left: offset.left + "px", top: offset.top + "px" } );

		if ( !inst.inline ) {
			showAnim = $.datepicker._get( inst, "showAnim" );
			duration = $.datepicker._get( inst, "duration" );
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
			} else {
				inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.trigger( "focus" );
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function( inst ) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append( this._generateHTML( inst ) );
		this._attachHandlers( inst );

		var origyearshtml,
			numMonths = this._getNumberOfMonths( inst ),
			cols = numMonths[ 1 ],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" ),
			onUpdateDatepicker = $.datepicker._get( inst, "onUpdateDatepicker" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
		if ( cols > 1 ) {
			inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
		}
		inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-multi" );
		inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-rtl" );

		if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.trigger( "focus" );
		}

		// Deffered render of the years select (to avoid flashes on Firefox)
		if ( inst.yearshtml ) {
			origyearshtml = inst.yearshtml;
			setTimeout( function() {

				//assure that inst.yearshtml didn't change.
				if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
					inst.dpDiv.find( "select.ui-datepicker-year" ).first().replaceWith( inst.yearshtml );
				}
				origyearshtml = inst.yearshtml = null;
			}, 0 );
		}

		if ( onUpdateDatepicker ) {
			onUpdateDatepicker.apply( ( inst.input ? inst.input[ 0 ] : null ), [ inst ] );
		}
	},

	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function( inst, offset, isFixed ) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
			viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );

		offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
		offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
		offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;

		// Now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
			Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
		offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
			Math.abs( dpHeight + inputHeight ) : 0 );

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function( obj ) {
		var position,
			inst = this._getInst( obj ),
			isRTL = this._get( inst, "isRTL" );

		while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.pseudos.hidden( obj ) ) ) {
			obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
		}

		position = $( obj ).offset();
		return [ position.left, position.top ];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function( input ) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
			return;
		}

		if ( this._datepickerShowing ) {
			showAnim = this._get( inst, "showAnim" );
			duration = this._get( inst, "duration" );
			postProcess = function() {
				$.datepicker._tidyDialog( inst );
			};

			if ( $.effects && ( $.effects.effect[ showAnim ] ) ) {
				inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
			} else {
				inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
					( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
			}

			if ( !showAnim ) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get( inst, "onClose" );
			if ( onClose ) {
				onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
			}

			this._lastInput = null;
			if ( this._inDialog ) {
				this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
				if ( $.blockUI ) {
					$.unblockUI();
					$( "body" ).append( this.dpDiv );
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function( inst ) {
		inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function( event ) {
		if ( !$.datepicker._curInst ) {
			return;
		}

		var $target = $( event.target ),
			inst = $.datepicker._getInst( $target[ 0 ] );

		if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
				$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
				!$target.hasClass( $.datepicker.markerClassName ) &&
				!$target.closest( "." + $.datepicker._triggerClass ).length &&
				$.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
			( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function( id, offset, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}
		this._adjustInstDate( inst, offset, period );
		this._updateDatepicker( inst );
	},

	/* Action for current link. */
	_gotoToday: function( id ) {
		var date,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function( id, select, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
		inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
			parseInt( select.options[ select.selectedIndex ].value, 10 );

		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a day. */
	_selectDay: function( id, month, year, td ) {
		var inst,
			target = $( id );

		if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}

		inst = this._getInst( target[ 0 ] );
		inst.selectedDay = inst.currentDay = parseInt( $( "a", td ).attr( "data-date" ) );
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate( id, this._formatDate( inst,
			inst.currentDay, inst.currentMonth, inst.currentYear ) );
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function( id ) {
		var target = $( id );
		this._selectDate( target, "" );
	},

	/* Update the input field with the selected date. */
	_selectDate: function( id, dateStr ) {
		var onSelect,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
		if ( inst.input ) {
			inst.input.val( dateStr );
		}
		this._updateAlternate( inst );

		onSelect = this._get( inst, "onSelect" );
		if ( onSelect ) {
			onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
		} else if ( inst.input ) {
			inst.input.trigger( "change" ); // fire the change event
		}

		if ( inst.inline ) {
			this._updateDatepicker( inst );
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[ 0 ];
			if ( typeof( inst.input[ 0 ] ) !== "object" ) {
				inst.input.trigger( "focus" ); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function( inst ) {
		var altFormat, date, dateStr,
			altField = this._get( inst, "altField" );

		if ( altField ) { // update alternate field too
			altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
			date = this._getDate( inst );
			dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
			$( document ).find( altField ).val( dateStr );
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function( date ) {
		var day = date.getDay();
		return [ ( day > 0 && day < 6 ), "" ];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function( date ) {
		var time,
			checkDate = new Date( date.getTime() );

		// Find Thursday of this week starting on Monday
		checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );

		time = checkDate.getTime();
		checkDate.setMonth( 0 ); // Compare with Jan 1
		checkDate.setDate( 1 );
		return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function( format, value, settings ) {
		if ( format == null || value == null ) {
			throw "Invalid arguments";
		}

		value = ( typeof value === "object" ? value.toString() : value + "" );
		if ( value === "" ) {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
			shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Extract a number from the string value
			getNumber = function( match ) {
				var isDoubled = lookAhead( match ),
					size = ( match === "@" ? 14 : ( match === "!" ? 20 :
					( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
					minSize = ( match === "y" ? size : 1 ),
					digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
					num = value.substring( iValue ).match( digits );
				if ( !num ) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[ 0 ].length;
				return parseInt( num[ 0 ], 10 );
			},

			// Extract a name from the string value and convert to an index
			getName = function( match, shortNames, longNames ) {
				var index = -1,
					names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
						return [ [ k, v ] ];
					} ).sort( function( a, b ) {
						return -( a[ 1 ].length - b[ 1 ].length );
					} );

				$.each( names, function( i, pair ) {
					var name = pair[ 1 ];
					if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
						index = pair[ 0 ];
						iValue += name.length;
						return false;
					}
				} );
				if ( index !== -1 ) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},

			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d":
						day = getNumber( "d" );
						break;
					case "D":
						getName( "D", dayNamesShort, dayNames );
						break;
					case "o":
						doy = getNumber( "o" );
						break;
					case "m":
						month = getNumber( "m" );
						break;
					case "M":
						month = getName( "M", monthNamesShort, monthNames );
						break;
					case "y":
						year = getNumber( "y" );
						break;
					case "@":
						date = new Date( getNumber( "@" ) );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if ( lookAhead( "'" ) ) {
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if ( iValue < value.length ) {
			extra = value.substr( iValue );
			if ( !/^\s+/.test( extra ) ) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if ( year === -1 ) {
			year = new Date().getFullYear();
		} else if ( year < 100 ) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				( year <= shortYearCutoff ? 0 : -100 );
		}

		if ( doy > -1 ) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth( year, month - 1 );
				if ( day <= dim ) {
					break;
				}
				month++;
				day -= dim;
			} while ( true );
		}

		date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
		if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
		Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function( format, date, settings ) {
		if ( !date ) {
			return "";
		}

		var iFormat,
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Format a number, with leading zero if necessary
			formatNumber = function( match, value, len ) {
				var num = "" + value;
				if ( lookAhead( match ) ) {
					while ( num.length < len ) {
						num = "0" + num;
					}
				}
				return num;
			},

			// Format a name, short or long as requested
			formatName = function( match, value, shortNames, longNames ) {
				return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
			},
			output = "",
			literal = false;

		if ( date ) {
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						output += format.charAt( iFormat );
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d":
							output += formatNumber( "d", date.getDate(), 2 );
							break;
						case "D":
							output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
							break;
						case "o":
							output += formatNumber( "o",
								Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
							break;
						case "m":
							output += formatNumber( "m", date.getMonth() + 1, 2 );
							break;
						case "M":
							output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
							break;
						case "y":
							output += ( lookAhead( "y" ) ? date.getFullYear() :
								( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if ( lookAhead( "'" ) ) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt( iFormat );
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function( format ) {
		var iFormat,
			chars = "",
			literal = false,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					chars += format.charAt( iFormat );
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if ( lookAhead( "'" ) ) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt( iFormat );
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function( inst, name ) {
		return inst.settings[ name ] !== undefined ?
			inst.settings[ name ] : this._defaults[ name ];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function( inst, noDefault ) {
		if ( inst.input.val() === inst.lastVal ) {
			return;
		}

		var dateFormat = this._get( inst, "dateFormat" ),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate( inst ),
			date = defaultDate,
			settings = this._getFormatConfig( inst );

		try {
			date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
		} catch ( event ) {
			dates = ( noDefault ? "" : dates );
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = ( dates ? date.getDate() : 0 );
		inst.currentMonth = ( dates ? date.getMonth() : 0 );
		inst.currentYear = ( dates ? date.getFullYear() : 0 );
		this._adjustInstDate( inst );
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function( inst ) {
		return this._restrictMinMax( inst,
			this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function( inst, date, defaultDate ) {
		var offsetNumeric = function( offset ) {
				var date = new Date();
				date.setDate( date.getDate() + offset );
				return date;
			},
			offsetString = function( offset ) {
				try {
					return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
						offset, $.datepicker._getFormatConfig( inst ) );
				} catch ( e ) {

					// Ignore
				}

				var date = ( offset.toLowerCase().match( /^c/ ) ?
					$.datepicker._getDate( inst ) : null ) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec( offset );

				while ( matches ) {
					switch ( matches[ 2 ] || "d" ) {
						case "d" : case "D" :
							day += parseInt( matches[ 1 ], 10 ); break;
						case "w" : case "W" :
							day += parseInt( matches[ 1 ], 10 ) * 7; break;
						case "m" : case "M" :
							month += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
						case "y": case "Y" :
							year += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
					}
					matches = pattern.exec( offset );
				}
				return new Date( year, month, day );
			},
			newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
				( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );

		newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
		if ( newDate ) {
			newDate.setHours( 0 );
			newDate.setMinutes( 0 );
			newDate.setSeconds( 0 );
			newDate.setMilliseconds( 0 );
		}
		return this._daylightSavingAdjust( newDate );
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function( date ) {
		if ( !date ) {
			return null;
		}
		date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function( inst, date, noChange ) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
			this._notifyChange( inst );
		}
		this._adjustInstDate( inst );
		if ( inst.input ) {
			inst.input.val( clear ? "" : this._formatDate( inst ) );
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function( inst ) {
		var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
			this._daylightSavingAdjust( new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function( inst ) {
		var stepMonths = this._get( inst, "stepMonths" ),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find( "[data-handler]" ).map( function() {
			var handler = {
				prev: function() {
					$.datepicker._adjustDate( id, -stepMonths, "M" );
				},
				next: function() {
					$.datepicker._adjustDate( id, +stepMonths, "M" );
				},
				hide: function() {
					$.datepicker._hideDatepicker();
				},
				today: function() {
					$.datepicker._gotoToday( id );
				},
				selectDay: function() {
					$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
					return false;
				},
				selectMonth: function() {
					$.datepicker._selectMonthYear( id, this, "M" );
					return false;
				},
				selectYear: function() {
					$.datepicker._selectMonthYear( id, this, "Y" );
					return false;
				}
			};
			$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
		} );
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function( inst ) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
			isRTL = this._get( inst, "isRTL" ),
			showButtonPanel = this._get( inst, "showButtonPanel" ),
			hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
			navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
			numMonths = this._getNumberOfMonths( inst ),
			showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
			stepMonths = this._get( inst, "stepMonths" ),
			isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
			currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
				new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if ( drawMonth < 0 ) {
			drawMonth += 12;
			drawYear--;
		}
		if ( maxDate ) {
			maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
				maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
			maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
			while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
				drawMonth--;
				if ( drawMonth < 0 ) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get( inst, "prevText" );
		prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		if ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ) {
			prev = $( "<a>" )
				.attr( {
					"class": "ui-datepicker-prev ui-corner-all",
					"data-handler": "prev",
					"data-event": "click",
					title: prevText
				} )
				.append(
					$( "<span>" )
						.addClass( "ui-icon ui-icon-circle-triangle-" +
							( isRTL ? "e" : "w" ) )
						.text( prevText )
				)[ 0 ].outerHTML;
		} else if ( hideIfNoPrevNext ) {
			prev = "";
		} else {
			prev = $( "<a>" )
				.attr( {
					"class": "ui-datepicker-prev ui-corner-all ui-state-disabled",
					title: prevText
				} )
				.append(
					$( "<span>" )
						.addClass( "ui-icon ui-icon-circle-triangle-" +
							( isRTL ? "e" : "w" ) )
						.text( prevText )
				)[ 0 ].outerHTML;
		}

		nextText = this._get( inst, "nextText" );
		nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		if ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ) {
			next = $( "<a>" )
				.attr( {
					"class": "ui-datepicker-next ui-corner-all",
					"data-handler": "next",
					"data-event": "click",
					title: nextText
				} )
				.append(
					$( "<span>" )
						.addClass( "ui-icon ui-icon-circle-triangle-" +
							( isRTL ? "w" : "e" ) )
						.text( nextText )
				)[ 0 ].outerHTML;
		} else if ( hideIfNoPrevNext ) {
			next = "";
		} else {
			next = $( "<a>" )
				.attr( {
					"class": "ui-datepicker-next ui-corner-all ui-state-disabled",
					title: nextText
				} )
				.append(
					$( "<span>" )
						.attr( "class", "ui-icon ui-icon-circle-triangle-" +
							( isRTL ? "w" : "e" ) )
						.text( nextText )
				)[ 0 ].outerHTML;
		}

		currentText = this._get( inst, "currentText" );
		gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
		currentText = ( !navigationAsDateFormat ? currentText :
			this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );

		controls = "";
		if ( !inst.inline ) {
			controls = $( "<button>" )
				.attr( {
					type: "button",
					"class": "ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all",
					"data-handler": "hide",
					"data-event": "click"
				} )
				.text( this._get( inst, "closeText" ) )[ 0 ].outerHTML;
		}

		buttonPanel = "";
		if ( showButtonPanel ) {
			buttonPanel = $( "<div class='ui-datepicker-buttonpane ui-widget-content'>" )
				.append( isRTL ? controls : "" )
				.append( this._isInRange( inst, gotoDate ) ?
					$( "<button>" )
						.attr( {
							type: "button",
							"class": "ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all",
							"data-handler": "today",
							"data-event": "click"
						} )
						.text( currentText ) :
					"" )
				.append( isRTL ? "" : controls )[ 0 ].outerHTML;
		}

		firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
		firstDay = ( isNaN( firstDay ) ? 0 : firstDay );

		showWeek = this._get( inst, "showWeek" );
		dayNames = this._get( inst, "dayNames" );
		dayNamesMin = this._get( inst, "dayNamesMin" );
		monthNames = this._get( inst, "monthNames" );
		monthNamesShort = this._get( inst, "monthNamesShort" );
		beforeShowDay = this._get( inst, "beforeShowDay" );
		showOtherMonths = this._get( inst, "showOtherMonths" );
		selectOtherMonths = this._get( inst, "selectOtherMonths" );
		defaultDate = this._getDefaultDate( inst );
		html = "";

		for ( row = 0; row < numMonths[ 0 ]; row++ ) {
			group = "";
			this.maxRows = 4;
			for ( col = 0; col < numMonths[ 1 ]; col++ ) {
				selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
				cornerClass = " ui-corner-all";
				calender = "";
				if ( isMultiMonth ) {
					calender += "<div class='ui-datepicker-group";
					if ( numMonths[ 1 ] > 1 ) {
						switch ( col ) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
							case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
					( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
					this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
				for ( dow = 0; dow < 7; dow++ ) { // days of the week
					day = ( dow + firstDay ) % 7;
					thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
						"<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
				if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
					inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
				}
				leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
				curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
				numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
				for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
					calender += "<tr>";
					tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
					for ( dow = 0; dow < 7; dow++ ) { // create date picker days
						daySettings = ( beforeShowDay ?
							beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
						otherMonth = ( printDate.getMonth() !== drawMonth );
						unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
							( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
						tbody += "<td class='" +
							( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
							( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
							( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
							( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?

							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "" ) + // highlight selected day
							( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
							( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
							( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
							( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
							( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
							( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
							( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
							( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
							( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
							"' href='#' aria-current='" + ( printDate.getTime() === currentDate.getTime() ? "true" : "false" ) + // mark date as selected for screen reader
							"' data-date='" + printDate.getDate() + // store date as data
							"'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
						printDate.setDate( printDate.getDate() + 1 );
						printDate = this._daylightSavingAdjust( printDate );
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if ( drawMonth > 11 ) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
							( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort ) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get( inst, "changeMonth" ),
			changeYear = this._get( inst, "changeYear" ),
			showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
			selectMonthLabel = this._get( inst, "selectMonthLabel" ),
			selectYearLabel = this._get( inst, "selectYearLabel" ),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// Month selection
		if ( secondary || !changeMonth ) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
		} else {
			inMinYear = ( minDate && minDate.getFullYear() === drawYear );
			inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
			monthHtml += "<select class='ui-datepicker-month' aria-label='" + selectMonthLabel + "' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++ ) {
				if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
					monthHtml += "<option value='" + month + "'" +
						( month === drawMonth ? " selected='selected'" : "" ) +
						">" + monthNamesShort[ month ] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if ( !showMonthAfterYear ) {
			html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
		}

		// Year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if ( secondary || !changeYear ) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {

				// determine range of years to display
				years = this._get( inst, "yearRange" ).split( ":" );
				thisYear = new Date().getFullYear();
				determineYear = function( value ) {
					var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
						( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
						parseInt( value, 10 ) ) );
					return ( isNaN( year ) ? thisYear : year );
				};
				year = determineYear( years[ 0 ] );
				endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
				year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
				endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
				inst.yearshtml += "<select class='ui-datepicker-year' aria-label='" + selectYearLabel + "' data-handler='selectYear' data-event='change'>";
				for ( ; year <= endYear; year++ ) {
					inst.yearshtml += "<option value='" + year + "'" +
						( year === drawYear ? " selected='selected'" : "" ) +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get( inst, "yearSuffix" );
		if ( showMonthAfterYear ) {
			html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function( inst, offset, period ) {
		var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
			month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
			day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
			date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if ( period === "M" || period === "Y" ) {
			this._notifyChange( inst );
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function( inst, date ) {
		var minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			newDate = ( minDate && date < minDate ? minDate : date );
		return ( maxDate && newDate > maxDate ? maxDate : newDate );
	},

	/* Notify change of month/year. */
	_notifyChange: function( inst ) {
		var onChange = this._get( inst, "onChangeMonthYear" );
		if ( onChange ) {
			onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
				[ inst.selectedYear, inst.selectedMonth + 1, inst ] );
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function( inst ) {
		var numMonths = this._get( inst, "numberOfMonths" );
		return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function( inst, minMax ) {
		return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function( year, month ) {
		return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function( year, month ) {
		return new Date( year, month, 1 ).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function( inst, offset, curYear, curMonth ) {
		var numMonths = this._getNumberOfMonths( inst ),
			date = this._daylightSavingAdjust( new Date( curYear,
			curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );

		if ( offset < 0 ) {
			date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
		}
		return this._isInRange( inst, date );
	},

	/* Is the given date in the accepted range? */
	_isInRange: function( inst, date ) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			minYear = null,
			maxYear = null,
			years = this._get( inst, "yearRange" );
			if ( years ) {
				yearSplit = years.split( ":" );
				currentYear = new Date().getFullYear();
				minYear = parseInt( yearSplit[ 0 ], 10 );
				maxYear = parseInt( yearSplit[ 1 ], 10 );
				if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
					minYear += currentYear;
				}
				if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
					maxYear += currentYear;
				}
			}

		return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
			( !maxDate || date.getTime() <= maxDate.getTime() ) &&
			( !minYear || date.getFullYear() >= minYear ) &&
			( !maxYear || date.getFullYear() <= maxYear ) );
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function( inst ) {
		var shortYearCutoff = this._get( inst, "shortYearCutoff" );
		shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
		return { shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
			monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
	},

	/* Format the given date for display. */
	_formatDate: function( inst, day, month, year ) {
		if ( !day ) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = ( day ? ( typeof day === "object" ? day :
			this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
			this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
		return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
	}
} );

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover( dpDiv ) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.on( "mouseout", selector, function() {
			$( this ).removeClass( "ui-state-hover" );
			if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-prev-hover" );
			}
			if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-next-hover" );
			}
		} )
		.on( "mouseover", selector, datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
		$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
		$( this ).addClass( "ui-state-hover" );
		if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-prev-hover" );
		}
		if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-next-hover" );
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove( target, props ) {
	$.extend( target, props );
	for ( var name in props ) {
		if ( props[ name ] == null ) {
			target[ name ] = props[ name ];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function( options ) {

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if ( !$.datepicker.initialized ) {
		$( document ).on( "mousedown", $.datepicker._checkExternalClick );
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
		$( "body" ).append( $.datepicker.dpDiv );
	}

	var otherArgs = Array.prototype.slice.call( arguments, 1 );
	if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	return this.each( function() {
		if ( typeof options === "string" ) {
			$.datepicker[ "_" + options + "Datepicker" ]
				.apply( $.datepicker, [ this ].concat( otherArgs ) );
		} else {
			$.datepicker._attachDatepicker( this, options );
		}
	} );
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.14.1";

return $.datepicker;

} );


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/selectric/public/jquery.selectric.js":
/*!***********************************************************!*\
  !*** ./node_modules/selectric/public/jquery.selectric.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 *         ,/
 *       ,'/
 *     ,' /
 *   ,'  /_____,
 * .'____    ,'
 *      /  ,'
 *     / ,'
 *    /,'
 *   /'
 *
 * Selectric ϟ v1.13.0 (Aug 22 2017) - http://lcdsantos.github.io/jQuery-Selectric/
 *
 * Copyright (c) 2017 Leonardo Santos; MIT License
 *
 */

(function(factory) {
  /* global define */
  /* istanbul ignore next */
  if ( true ) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(function($) {
  'use strict';

  var $doc = $(document);
  var $win = $(window);

  var pluginName = 'selectric';
  var classList = 'Input Items Open Disabled TempShow HideSelect Wrapper Focus Hover Responsive Above Below Scroll Group GroupLabel';
  var eventNamespaceSuffix = '.sl';

  var chars = ['a', 'e', 'i', 'o', 'u', 'n', 'c', 'y'];
  var diacritics = [
    /[\xE0-\xE5]/g, // a
    /[\xE8-\xEB]/g, // e
    /[\xEC-\xEF]/g, // i
    /[\xF2-\xF6]/g, // o
    /[\xF9-\xFC]/g, // u
    /[\xF1]/g,      // n
    /[\xE7]/g,      // c
    /[\xFD-\xFF]/g  // y
  ];

  /**
   * Create an instance of Selectric
   *
   * @constructor
   * @param {Node} element - The &lt;select&gt; element
   * @param {object}  opts - Options
   */
  var Selectric = function(element, opts) {
    var _this = this;

    _this.element = element;
    _this.$element = $(element);

    _this.state = {
      multiple       : !!_this.$element.attr('multiple'),
      enabled        : false,
      opened         : false,
      currValue      : -1,
      selectedIdx    : -1,
      highlightedIdx : -1
    };

    _this.eventTriggers = {
      open    : _this.open,
      close   : _this.close,
      destroy : _this.destroy,
      refresh : _this.refresh,
      init    : _this.init
    };

    _this.init(opts);
  };

  Selectric.prototype = {
    utils: {
      /**
       * Detect mobile browser
       *
       * @return {boolean}
       */
      isMobile: function() {
        return /android|ip(hone|od|ad)/i.test(navigator.userAgent);
      },

      /**
       * Escape especial characters in string (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
       *
       * @param  {string} str - The string to be escaped
       * @return {string}       The string with the special characters escaped
       */
      escapeRegExp: function(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
      },

      /**
       * Replace diacritics
       *
       * @param  {string} str - The string to replace the diacritics
       * @return {string}       The string with diacritics replaced with ascii characters
       */
      replaceDiacritics: function(str) {
        var k = diacritics.length;

        while (k--) {
          str = str.toLowerCase().replace(diacritics[k], chars[k]);
        }

        return str;
      },

      /**
       * Format string
       * https://gist.github.com/atesgoral/984375
       *
       * @param  {string} f - String to be formated
       * @return {string}     String formated
       */
      format: function(f) {
        var a = arguments; // store outer arguments
        return ('' + f) // force format specifier to String
          .replace( // replace tokens in format specifier
            /\{(?:(\d+)|(\w+))\}/g, // match {token} references
            function(
              s, // the matched string (ignored)
              i, // an argument index
              p // a property name
            ) {
              return p && a[1] // if property name and first argument exist
                ? a[1][p] // return property from first argument
                : a[i]; // assume argument index and return i-th argument
            });
      },

      /**
       * Get the next enabled item in the options list.
       *
       * @param  {object} selectItems - The options object.
       * @param  {number}    selected - Index of the currently selected option.
       * @return {object}               The next enabled item.
       */
      nextEnabledItem: function(selectItems, selected) {
        while ( selectItems[ selected = (selected + 1) % selectItems.length ].disabled ) {
          // empty
        }
        return selected;
      },

      /**
       * Get the previous enabled item in the options list.
       *
       * @param  {object} selectItems - The options object.
       * @param  {number}    selected - Index of the currently selected option.
       * @return {object}               The previous enabled item.
       */
      previousEnabledItem: function(selectItems, selected) {
        while ( selectItems[ selected = (selected > 0 ? selected : selectItems.length) - 1 ].disabled ) {
          // empty
        }
        return selected;
      },

      /**
       * Transform camelCase string to dash-case.
       *
       * @param  {string} str - The camelCased string.
       * @return {string}       The string transformed to dash-case.
       */
      toDash: function(str) {
        return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
      },

      /**
       * Calls the events registered with function name.
       *
       * @param {string}    fn - The name of the function.
       * @param {number} scope - Scope that should be set on the function.
       */
      triggerCallback: function(fn, scope) {
        var elm = scope.element;
        var func = scope.options['on' + fn];
        var args = [elm].concat([].slice.call(arguments).slice(1));

        if ( $.isFunction(func) ) {
          func.apply(elm, args);
        }

        $(elm).trigger(pluginName + '-' + this.toDash(fn), args);
      },

      /**
       * Transform array list to concatenated string and remove empty values
       * @param  {array} arr - Class list
       * @return {string}      Concatenated string
       */
      arrayToClassname: function(arr) {
        var newArr = $.grep(arr, function(item) {
          return !!item;
        });

        return $.trim(newArr.join(' '));
      }
    },

    /** Initializes */
    init: function(opts) {
      var _this = this;

      // Set options
      _this.options = $.extend(true, {}, $.fn[pluginName].defaults, _this.options, opts);

      _this.utils.triggerCallback('BeforeInit', _this);

      // Preserve data
      _this.destroy(true);

      // Disable on mobile browsers
      if ( _this.options.disableOnMobile && _this.utils.isMobile() ) {
        _this.disableOnMobile = true;
        return;
      }

      // Get classes
      _this.classes = _this.getClassNames();

      // Create elements
      var input              = $('<input/>', { 'class': _this.classes.input, 'readonly': _this.utils.isMobile() });
      var items              = $('<div/>',   { 'class': _this.classes.items, 'tabindex': -1 });
      var itemsScroll        = $('<div/>',   { 'class': _this.classes.scroll });
      var wrapper            = $('<div/>',   { 'class': _this.classes.prefix, 'html': _this.options.arrowButtonMarkup });
      var label              = $('<span/>',  { 'class': 'label' });
      var outerWrapper       = _this.$element.wrap('<div/>').parent().append(wrapper.prepend(label), items, input);
      var hideSelectWrapper  = $('<div/>',   { 'class': _this.classes.hideselect });

      _this.elements = {
        input        : input,
        items        : items,
        itemsScroll  : itemsScroll,
        wrapper      : wrapper,
        label        : label,
        outerWrapper : outerWrapper
      };

      if ( _this.options.nativeOnMobile && _this.utils.isMobile() ) {
        _this.elements.input = undefined;
        hideSelectWrapper.addClass(_this.classes.prefix + '-is-native');

        _this.$element.on('change', function() {
          _this.refresh();
        });
      }

      _this.$element
        .on(_this.eventTriggers)
        .wrap(hideSelectWrapper);

      _this.originalTabindex = _this.$element.prop('tabindex');
      _this.$element.prop('tabindex', -1);

      _this.populate();
      _this.activate();

      _this.utils.triggerCallback('Init', _this);
    },

    /** Activates the plugin */
    activate: function() {
      var _this = this;
      var hiddenChildren = _this.elements.items.closest(':visible').children(':hidden').addClass(_this.classes.tempshow);
      var originalWidth = _this.$element.width();

      hiddenChildren.removeClass(_this.classes.tempshow);

      _this.utils.triggerCallback('BeforeActivate', _this);

      _this.elements.outerWrapper.prop('class',
        _this.utils.arrayToClassname([
          _this.classes.wrapper,
          _this.$element.prop('class').replace(/\S+/g, _this.classes.prefix + '-$&'),
          _this.options.responsive ? _this.classes.responsive : ''
        ])
      );

      if ( _this.options.inheritOriginalWidth && originalWidth > 0 ) {
        _this.elements.outerWrapper.width(originalWidth);
      }

      _this.unbindEvents();

      if ( !_this.$element.prop('disabled') ) {
        _this.state.enabled = true;

        // Not disabled, so... Removing disabled class
        _this.elements.outerWrapper.removeClass(_this.classes.disabled);

        // Remove styles from items box
        // Fix incorrect height when refreshed is triggered with fewer options
        _this.$li = _this.elements.items.removeAttr('style').find('li');

        _this.bindEvents();
      } else {
        _this.elements.outerWrapper.addClass(_this.classes.disabled);

        if ( _this.elements.input ) {
          _this.elements.input.prop('disabled', true);
        }
      }

      _this.utils.triggerCallback('Activate', _this);
    },

    /**
     * Generate classNames for elements
     *
     * @return {object} Classes object
     */
    getClassNames: function() {
      var _this = this;
      var customClass = _this.options.customClass;
      var classesObj = {};

      $.each(classList.split(' '), function(i, currClass) {
        var c = customClass.prefix + currClass;
        classesObj[currClass.toLowerCase()] = customClass.camelCase ? c : _this.utils.toDash(c);
      });

      classesObj.prefix = customClass.prefix;

      return classesObj;
    },

    /** Set the label text */
    setLabel: function() {
      var _this = this;
      var labelBuilder = _this.options.labelBuilder;

      if ( _this.state.multiple ) {
        // Make sure currentValues is an array
        var currentValues = $.isArray(_this.state.currValue) ? _this.state.currValue : [_this.state.currValue];
        // I'm not happy with this, but currentValues can be an empty
        // array and we need to fallback to the default option.
        currentValues = currentValues.length === 0 ? [0] : currentValues;

        var labelMarkup = $.map(currentValues, function(value) {
          return $.grep(_this.lookupItems, function(item) {
            return item.index === value;
          })[0]; // we don't want nested arrays here
        });

        labelMarkup = $.grep(labelMarkup, function(item) {
          // Hide default (please choose) if more then one element were selected.
          // If no option value were given value is set to option text by default
          if ( labelMarkup.length > 1 || labelMarkup.length === 0 ) {
            return $.trim(item.value) !== '';
          }
          return item;
        });

        labelMarkup = $.map(labelMarkup, function(item) {
          return $.isFunction(labelBuilder)
            ? labelBuilder(item)
            : _this.utils.format(labelBuilder, item);
        });

        // Limit the amount of selected values shown in label
        if ( _this.options.multiple.maxLabelEntries ) {
          if ( labelMarkup.length >= _this.options.multiple.maxLabelEntries + 1 ) {
            labelMarkup = labelMarkup.slice(0, _this.options.multiple.maxLabelEntries);
            labelMarkup.push(
              $.isFunction(labelBuilder)
                ? labelBuilder({ text: '...' })
                : _this.utils.format(labelBuilder, { text: '...' }));
          } else {
            labelMarkup.slice(labelMarkup.length - 1);
          }
        }
        _this.elements.label.html(labelMarkup.join(_this.options.multiple.separator));

      } else {
        var currItem = _this.lookupItems[_this.state.currValue];

        _this.elements.label.html(
          $.isFunction(labelBuilder)
            ? labelBuilder(currItem)
            : _this.utils.format(labelBuilder, currItem)
        );
      }
    },

    /** Get and save the available options */
    populate: function() {
      var _this = this;
      var $options = _this.$element.children();
      var $justOptions = _this.$element.find('option');
      var $selected = $justOptions.filter(':selected');
      var selectedIndex = $justOptions.index($selected);
      var currIndex = 0;
      var emptyValue = (_this.state.multiple ? [] : 0);

      if ( $selected.length > 1 && _this.state.multiple ) {
        selectedIndex = [];
        $selected.each(function() {
          selectedIndex.push($(this).index());
        });
      }

      _this.state.currValue = (~selectedIndex ? selectedIndex : emptyValue);
      _this.state.selectedIdx = _this.state.currValue;
      _this.state.highlightedIdx = _this.state.currValue;
      _this.items = [];
      _this.lookupItems = [];

      if ( $options.length ) {
        // Build options markup
        $options.each(function(i) {
          var $elm = $(this);

          if ( $elm.is('optgroup') ) {

            var optionsGroup = {
              element       : $elm,
              label         : $elm.prop('label'),
              groupDisabled : $elm.prop('disabled'),
              items         : []
            };

            $elm.children().each(function(i) {
              var $elm = $(this);

              optionsGroup.items[i] = _this.getItemData(currIndex, $elm, optionsGroup.groupDisabled || $elm.prop('disabled'));

              _this.lookupItems[currIndex] = optionsGroup.items[i];

              currIndex++;
            });

            _this.items[i] = optionsGroup;

          } else {

            _this.items[i] = _this.getItemData(currIndex, $elm, $elm.prop('disabled'));

            _this.lookupItems[currIndex] = _this.items[i];

            currIndex++;

          }
        });

        _this.setLabel();
        _this.elements.items.append( _this.elements.itemsScroll.html( _this.getItemsMarkup(_this.items) ) );
      }
    },

    /**
     * Generate items object data
     * @param  {integer} index      - Current item index
     * @param  {node}    $elm       - Current element node
     * @param  {boolean} isDisabled - Current element disabled state
     * @return {object}               Item object
     */
    getItemData: function(index, $elm, isDisabled) {
      var _this = this;

      return {
        index     : index,
        element   : $elm,
        value     : $elm.val(),
        className : $elm.prop('class'),
        text      : $elm.html(),
        slug      : $.trim(_this.utils.replaceDiacritics($elm.html())),
        alt       : $elm.attr('data-alt'),
        selected  : $elm.prop('selected'),
        disabled  : isDisabled
      };
    },

    /**
     * Generate options markup
     *
     * @param  {object} items - Object containing all available options
     * @return {string}         HTML for the options box
     */
    getItemsMarkup: function(items) {
      var _this = this;
      var markup = '<ul>';

      if ( $.isFunction(_this.options.listBuilder) && _this.options.listBuilder ) {
        items = _this.options.listBuilder(items);
      }

      $.each(items, function(i, elm) {
        if ( elm.label !== undefined ) {

          markup += _this.utils.format('<ul class="{1}"><li class="{2}">{3}</li>',
            _this.utils.arrayToClassname([
              _this.classes.group,
              elm.groupDisabled ? 'disabled' : '',
              elm.element.prop('class')
            ]),
            _this.classes.grouplabel,
            elm.element.prop('label')
          );

          $.each(elm.items, function(i, elm) {
            markup += _this.getItemMarkup(elm.index, elm);
          });

          markup += '</ul>';

        } else {

          markup += _this.getItemMarkup(elm.index, elm);

        }
      });

      return markup + '</ul>';
    },

    /**
     * Generate every option markup
     *
     * @param  {number} index    - Index of current item
     * @param  {object} itemData - Current item
     * @return {string}            HTML for the option
     */
    getItemMarkup: function(index, itemData) {
      var _this = this;
      var itemBuilder = _this.options.optionsItemBuilder;
      // limit access to item data to provide a simple interface
      // to most relevant options.
      var filteredItemData = {
        value: itemData.value,
        text : itemData.text,
        slug : itemData.slug,
        index: itemData.index
      };

      return _this.utils.format('<li data-index="{1}" class="{2}">{3}</li>',
        index,
        _this.utils.arrayToClassname([
          itemData.className,
          index === _this.items.length - 1  ? 'last'     : '',
          itemData.disabled                 ? 'disabled' : '',
          itemData.selected                 ? 'selected' : ''
        ]),
        $.isFunction(itemBuilder)
          ? _this.utils.format(itemBuilder(itemData, this.$element, index), itemData)
          : _this.utils.format(itemBuilder, filteredItemData)
      );
    },

    /** Remove events on the elements */
    unbindEvents: function() {
      var _this = this;

      _this.elements.wrapper
        .add(_this.$element)
        .add(_this.elements.outerWrapper)
        .add(_this.elements.input)
        .off(eventNamespaceSuffix);
    },

    /** Bind events on the elements */
    bindEvents: function() {
      var _this = this;

      _this.elements.outerWrapper.on('mouseenter' + eventNamespaceSuffix + ' mouseleave' + eventNamespaceSuffix, function(e) {
        $(this).toggleClass(_this.classes.hover, e.type === 'mouseenter');

        // Delay close effect when openOnHover is true
        if ( _this.options.openOnHover ) {
          clearTimeout(_this.closeTimer);

          if ( e.type === 'mouseleave' ) {
            _this.closeTimer = setTimeout($.proxy(_this.close, _this), _this.options.hoverIntentTimeout);
          } else {
            _this.open();
          }
        }
      });

      // Toggle open/close
      _this.elements.wrapper.on('click' + eventNamespaceSuffix, function(e) {
        _this.state.opened ? _this.close() : _this.open(e);
      });

      // Translate original element focus event to dummy input.
      // Disabled on mobile devices because the default option list isn't
      // shown due the fact that hidden input gets focused
      if ( !(_this.options.nativeOnMobile && _this.utils.isMobile()) ) {
        _this.$element.on('focus' + eventNamespaceSuffix, function() {
          _this.elements.input.focus();
        });

        _this.elements.input
          .prop({ tabindex: _this.originalTabindex, disabled: false })
          .on('keydown' + eventNamespaceSuffix, $.proxy(_this.handleKeys, _this))
          .on('focusin' + eventNamespaceSuffix, function(e) {
            _this.elements.outerWrapper.addClass(_this.classes.focus);

            // Prevent the flicker when focusing out and back again in the browser window
            _this.elements.input.one('blur', function() {
              _this.elements.input.blur();
            });

            if ( _this.options.openOnFocus && !_this.state.opened ) {
              _this.open(e);
            }
          })
          .on('focusout' + eventNamespaceSuffix, function() {
            _this.elements.outerWrapper.removeClass(_this.classes.focus);
          })
          .on('input propertychange', function() {
            var val = _this.elements.input.val();
            var searchRegExp = new RegExp('^' + _this.utils.escapeRegExp(val), 'i');

            // Clear search
            clearTimeout(_this.resetStr);
            _this.resetStr = setTimeout(function() {
              _this.elements.input.val('');
            }, _this.options.keySearchTimeout);

            if ( val.length ) {
              // Search in select options
              $.each(_this.items, function(i, elm) {
                if (elm.disabled) {
                  return;
                }
                if (searchRegExp.test(elm.text) || searchRegExp.test(elm.slug)) {
                  _this.highlight(i);
                  return;
                }
                if (!elm.alt) {
                  return;
                }
                var altItems = elm.alt.split('|');
                for (var ai = 0; ai < altItems.length; ai++) {
                  if (!altItems[ai]) {
                    break;
                  }
                  if (searchRegExp.test(altItems[ai].trim())) {
                    _this.highlight(i);
                    return;
                  }
                }
              });
            }
          });
      }

      _this.$li.on({
        // Prevent <input> blur on Chrome
        mousedown: function(e) {
          e.preventDefault();
          e.stopPropagation();
        },
        click: function() {
          _this.select($(this).data('index'));

          // Chrome doesn't close options box if select is wrapped with a label
          // We need to 'return false' to avoid that
          return false;
        }
      });
    },

    /**
     * Behavior when keyboard keys is pressed
     *
     * @param {object} e - Event object
     */
    handleKeys: function(e) {
      var _this = this;
      var key = e.which;
      var keys = _this.options.keys;

      var isPrevKey = $.inArray(key, keys.previous) > -1;
      var isNextKey = $.inArray(key, keys.next) > -1;
      var isSelectKey = $.inArray(key, keys.select) > -1;
      var isOpenKey = $.inArray(key, keys.open) > -1;
      var idx = _this.state.highlightedIdx;
      var isFirstOrLastItem = (isPrevKey && idx === 0) || (isNextKey && (idx + 1) === _this.items.length);
      var goToItem = 0;

      // Enter / Space
      if ( key === 13 || key === 32 ) {
        e.preventDefault();
      }

      // If it's a directional key
      if ( isPrevKey || isNextKey ) {
        if ( !_this.options.allowWrap && isFirstOrLastItem ) {
          return;
        }

        if ( isPrevKey ) {
          goToItem = _this.utils.previousEnabledItem(_this.lookupItems, idx);
        }

        if ( isNextKey ) {
          goToItem = _this.utils.nextEnabledItem(_this.lookupItems, idx);
        }

        _this.highlight(goToItem);
      }

      // Tab / Enter / ESC
      if ( isSelectKey && _this.state.opened ) {
        _this.select(idx);

        if ( !_this.state.multiple || !_this.options.multiple.keepMenuOpen ) {
          _this.close();
        }

        return;
      }

      // Space / Enter / Left / Up / Right / Down
      if ( isOpenKey && !_this.state.opened ) {
        _this.open();
      }
    },

    /** Update the items object */
    refresh: function() {
      var _this = this;

      _this.populate();
      _this.activate();
      _this.utils.triggerCallback('Refresh', _this);
    },

    /** Set options box width/height */
    setOptionsDimensions: function() {
      var _this = this;

      // Calculate options box height
      // Set a temporary class on the hidden parent of the element
      var hiddenChildren = _this.elements.items.closest(':visible').children(':hidden').addClass(_this.classes.tempshow);
      var maxHeight = _this.options.maxHeight;
      var itemsWidth = _this.elements.items.outerWidth();
      var wrapperWidth = _this.elements.wrapper.outerWidth() - (itemsWidth - _this.elements.items.width());

      // Set the dimensions, minimum is wrapper width, expand for long items if option is true
      if ( !_this.options.expandToItemText || wrapperWidth > itemsWidth ) {
        _this.finalWidth = wrapperWidth;
      } else {
        // Make sure the scrollbar width is included
        _this.elements.items.css('overflow', 'scroll');

        // Set a really long width for _this.elements.outerWrapper
        _this.elements.outerWrapper.width(9e4);
        _this.finalWidth = _this.elements.items.width();
        // Set scroll bar to auto
        _this.elements.items.css('overflow', '');
        _this.elements.outerWrapper.width('');
      }

      _this.elements.items.width(_this.finalWidth).height() > maxHeight && _this.elements.items.height(maxHeight);

      // Remove the temporary class
      hiddenChildren.removeClass(_this.classes.tempshow);
    },

    /** Detect if the options box is inside the window */
    isInViewport: function() {
      var _this = this;

      if (_this.options.forceRenderAbove === true) {
        _this.elements.outerWrapper.addClass(_this.classes.above);
      } else if (_this.options.forceRenderBelow === true) {
        _this.elements.outerWrapper.addClass(_this.classes.below);
      } else {
        var scrollTop = $win.scrollTop();
        var winHeight = $win.height();
        var uiPosX = _this.elements.outerWrapper.offset().top;
        var uiHeight = _this.elements.outerWrapper.outerHeight();

        var fitsDown = (uiPosX + uiHeight + _this.itemsHeight) <= (scrollTop + winHeight);
        var fitsAbove = (uiPosX - _this.itemsHeight) > scrollTop;

        // If it does not fit below, only render it
        // above it fit's there.
        // It's acceptable that the user needs to
        // scroll the viewport to see the cut off UI
        var renderAbove = !fitsDown && fitsAbove;
        var renderBelow = !renderAbove;

        _this.elements.outerWrapper.toggleClass(_this.classes.above, renderAbove);
        _this.elements.outerWrapper.toggleClass(_this.classes.below, renderBelow);
      }
    },

    /**
     * Detect if currently selected option is visible and scroll the options box to show it
     *
     * @param {Number|Array} index - Index of the selected items
     */
    detectItemVisibility: function(index) {
      var _this = this;
      var $filteredLi = _this.$li.filter('[data-index]');

      if ( _this.state.multiple ) {
        // If index is an array, we can assume a multiple select and we
        // want to scroll to the uppermost selected item!
        // Math.min.apply(Math, index) returns the lowest entry in an Array.
        index = ($.isArray(index) && index.length === 0) ? 0 : index;
        index = $.isArray(index) ? Math.min.apply(Math, index) : index;
      }

      var liHeight = $filteredLi.eq(index).outerHeight();
      var liTop = $filteredLi[index].offsetTop;
      var itemsScrollTop = _this.elements.itemsScroll.scrollTop();
      var scrollT = liTop + liHeight * 2;

      _this.elements.itemsScroll.scrollTop(
        scrollT > itemsScrollTop + _this.itemsHeight ? scrollT - _this.itemsHeight :
          liTop - liHeight < itemsScrollTop ? liTop - liHeight :
            itemsScrollTop
      );
    },

    /**
     * Open the select options box
     *
     * @param {Event} e - Event
     */
    open: function(e) {
      var _this = this;

      if ( _this.options.nativeOnMobile && _this.utils.isMobile()) {
        return false;
      }

      _this.utils.triggerCallback('BeforeOpen', _this);

      if ( e ) {
        e.preventDefault();
        if (_this.options.stopPropagation) {
          e.stopPropagation();
        }
      }

      if ( _this.state.enabled ) {
        _this.setOptionsDimensions();

        // Find any other opened instances of select and close it
        $('.' + _this.classes.hideselect, '.' + _this.classes.open).children()[pluginName]('close');

        _this.state.opened = true;
        _this.itemsHeight = _this.elements.items.outerHeight();
        _this.itemsInnerHeight = _this.elements.items.height();

        // Toggle options box visibility
        _this.elements.outerWrapper.addClass(_this.classes.open);

        // Give dummy input focus
        _this.elements.input.val('');
        if ( e && e.type !== 'focusin' ) {
          _this.elements.input.focus();
        }

        // Delayed binds events on Document to make label clicks work
        setTimeout(function() {
          $doc
            .on('click' + eventNamespaceSuffix, $.proxy(_this.close, _this))
            .on('scroll' + eventNamespaceSuffix, $.proxy(_this.isInViewport, _this));
        }, 1);

        _this.isInViewport();

        // Prevent window scroll when using mouse wheel inside items box
        if ( _this.options.preventWindowScroll ) {
          /* istanbul ignore next */
          $doc.on('mousewheel' + eventNamespaceSuffix + ' DOMMouseScroll' + eventNamespaceSuffix, '.' + _this.classes.scroll, function(e) {
            var orgEvent = e.originalEvent;
            var scrollTop = $(this).scrollTop();
            var deltaY = 0;

            if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1; }
            if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;  }
            if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY; }
            if ( 'deltaY'      in orgEvent ) { deltaY = orgEvent.deltaY * -1; }

            if ( scrollTop === (this.scrollHeight - _this.itemsInnerHeight) && deltaY < 0 || scrollTop === 0 && deltaY > 0 ) {
              e.preventDefault();
            }
          });
        }

        _this.detectItemVisibility(_this.state.selectedIdx);

        _this.highlight(_this.state.multiple ? -1 : _this.state.selectedIdx);

        _this.utils.triggerCallback('Open', _this);
      }
    },

    /** Close the select options box */
    close: function() {
      var _this = this;

      _this.utils.triggerCallback('BeforeClose', _this);

      // Remove custom events on document
      $doc.off(eventNamespaceSuffix);

      // Remove visible class to hide options box
      _this.elements.outerWrapper.removeClass(_this.classes.open);

      _this.state.opened = false;

      _this.utils.triggerCallback('Close', _this);
    },

    /** Select current option and change the label */
    change: function() {
      var _this = this;

      _this.utils.triggerCallback('BeforeChange', _this);

      if ( _this.state.multiple ) {
        // Reset old selected
        $.each(_this.lookupItems, function(idx) {
          _this.lookupItems[idx].selected = false;
          _this.$element.find('option').prop('selected', false);
        });

        // Set new selected
        $.each(_this.state.selectedIdx, function(idx, value) {
          _this.lookupItems[value].selected = true;
          _this.$element.find('option').eq(value).prop('selected', true);
        });

        _this.state.currValue = _this.state.selectedIdx;

        _this.setLabel();

        _this.utils.triggerCallback('Change', _this);
      } else if ( _this.state.currValue !== _this.state.selectedIdx ) {
        // Apply changed value to original select
        _this.$element
          .prop('selectedIndex', _this.state.currValue = _this.state.selectedIdx)
          .data('value', _this.lookupItems[_this.state.selectedIdx].text);

        // Change label text
        _this.setLabel();

        _this.utils.triggerCallback('Change', _this);
      }
    },

    /**
     * Highlight option
     * @param {number} index - Index of the options that will be highlighted
     */
    highlight: function(index) {
      var _this = this;
      var $filteredLi = _this.$li.filter('[data-index]').removeClass('highlighted');

      _this.utils.triggerCallback('BeforeHighlight', _this);

      // Parameter index is required and should not be a disabled item
      if ( index === undefined || index === -1 || _this.lookupItems[index].disabled ) {
        return;
      }

      $filteredLi
        .eq(_this.state.highlightedIdx = index)
        .addClass('highlighted');

      _this.detectItemVisibility(index);

      _this.utils.triggerCallback('Highlight', _this);
    },

    /**
     * Select option
     *
     * @param {number} index - Index of the option that will be selected
     */
    select: function(index) {
      var _this = this;
      var $filteredLi = _this.$li.filter('[data-index]');

      _this.utils.triggerCallback('BeforeSelect', _this, index);

      // Parameter index is required and should not be a disabled item
      if ( index === undefined || index === -1 || _this.lookupItems[index].disabled ) {
        return;
      }

      if ( _this.state.multiple ) {
        // Make sure selectedIdx is an array
        _this.state.selectedIdx = $.isArray(_this.state.selectedIdx) ? _this.state.selectedIdx : [_this.state.selectedIdx];

        var hasSelectedIndex = $.inArray(index, _this.state.selectedIdx);
        if ( hasSelectedIndex !== -1 ) {
          _this.state.selectedIdx.splice(hasSelectedIndex, 1);
        } else {
          _this.state.selectedIdx.push(index);
        }

        $filteredLi
          .removeClass('selected')
          .filter(function(index) {
            return $.inArray(index, _this.state.selectedIdx) !== -1;
          })
          .addClass('selected');
      } else {
        $filteredLi
          .removeClass('selected')
          .eq(_this.state.selectedIdx = index)
          .addClass('selected');
      }

      if ( !_this.state.multiple || !_this.options.multiple.keepMenuOpen ) {
        _this.close();
      }

      _this.change();

      _this.utils.triggerCallback('Select', _this, index);
    },

    /**
     * Unbind and remove
     *
     * @param {boolean} preserveData - Check if the data on the element should be removed too
     */
    destroy: function(preserveData) {
      var _this = this;

      if ( _this.state && _this.state.enabled ) {
        _this.elements.items.add(_this.elements.wrapper).add(_this.elements.input).remove();

        if ( !preserveData ) {
          _this.$element.removeData(pluginName).removeData('value');
        }

        _this.$element.prop('tabindex', _this.originalTabindex).off(eventNamespaceSuffix).off(_this.eventTriggers).unwrap().unwrap();

        _this.state.enabled = false;
      }
    }
  };

  // A really lightweight plugin wrapper around the constructor,
  // preventing against multiple instantiations
  $.fn[pluginName] = function(args) {
    return this.each(function() {
      var data = $.data(this, pluginName);

      if ( data && !data.disableOnMobile ) {
        (typeof args === 'string' && data[args]) ? data[args]() : data.init(args);
      } else {
        $.data(this, pluginName, new Selectric(this, args));
      }
    });
  };

  /**
   * Default plugin options
   *
   * @type {object}
   */
  $.fn[pluginName].defaults = {
    onChange             : function(elm) { $(elm).change(); },
    maxHeight            : 300,
    keySearchTimeout     : 500,
    arrowButtonMarkup    : '<b class="button">&#x25be;</b>',
    disableOnMobile      : false,
    nativeOnMobile       : true,
    openOnFocus          : true,
    openOnHover          : false,
    hoverIntentTimeout   : 500,
    expandToItemText     : false,
    responsive           : false,
    preventWindowScroll  : true,
    inheritOriginalWidth : false,
    allowWrap            : true,
    forceRenderAbove     : false,
    forceRenderBelow     : false,
    stopPropagation      : true,
    optionsItemBuilder   : '{text}', // function(itemData, element, index)
    labelBuilder         : '{text}', // function(currItem)
    listBuilder          : false,    // function(items)
    keys                 : {
      previous : [37, 38],                 // Left / Up
      next     : [39, 40],                 // Right / Down
      select   : [9, 13, 27],              // Tab / Enter / Escape
      open     : [13, 32, 37, 38, 39, 40], // Enter / Space / Left / Up / Right / Down
      close    : [9, 27]                   // Tab / Escape
    },
    customClass          : {
      prefix: pluginName,
      camelCase: false
    },
    multiple              : {
      separator: ', ',
      keepMenuOpen: true,
      maxLabelEntries: false
    }
  };
}));


/***/ }),

/***/ "./node_modules/sortablejs/modular/sortable.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/sortablejs/modular/sortable.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiDrag: () => (/* binding */ MultiDragPlugin),
/* harmony export */   Sortable: () => (/* binding */ Sortable),
/* harmony export */   Swap: () => (/* binding */ SwapPlugin),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* provided dependency */ var __webpack_provided_window_dot_jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/**!
 * Sortable 1.15.6
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.15.6";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = __webpack_provided_window_dot_jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}
function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, 'pointerup', _this._onDrop);
        // Native D&D triggers pointercancel
        !this.nativeDraggable && on(ownerDocument, 'pointercancel', _this._onDrop);
      } else {
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop);
      }

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        if (options.supportPointer) {
          on(ownerDocument, 'pointerup', _this._disableDelayedDrag);
          on(ownerDocument, 'pointercancel', _this._disableDelayedDrag);
        } else {
          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        }
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'pointerup', this._disableDelayedDrag);
    off(ownerDocument, 'pointercancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'pointercancel', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild,
  expando: expando
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }
  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
        target = _ref2.target,
        onMove = _ref2.onMove,
        activeSortable = _ref2.activeSortable,
        changed = _ref2.changed,
        cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
        options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
        putSortable = _ref3.putSortable,
        dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
    p2 = n2.parentNode,
    i1,
    i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
  multiDragClones = [],
  lastMultiDragSelect,
  // for selection with modifier key down (SHIFT)
  multiDragSortable,
  initialFolding = false,
  // Initial multi-drag fold when drag started
  folding = false,
  // Folding any other time
  dragStarted = false,
  dragEl$1,
  clonesFromRect,
  clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }
    }
    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }
        dataTransfer.setData('Text', data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
        cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
        rootEl = _ref3.rootEl,
        dispatchSortableEvent = _ref3.dispatchSortableEvent,
        cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
        rootEl = _ref4.rootEl,
        cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      var sortable = _ref5.sortable,
        cloneNowHidden = _ref5.cloneNowHidden,
        cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');
        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });

      // Sort multi-drag elements
      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;
      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM

        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        }

        // Remove all auxiliary multidrag items from el, if sorting enabled
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
        completed = _ref8.completed,
        cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
        rootEl = _ref9.rootEl,
        sortable = _ref9.sortable,
        dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
        isOwner = _ref10.isOwner,
        insertion = _ref10.insertion,
        activeSortable = _ref10.activeSortable,
        parentEl = _ref10.parentEl,
        putSortable = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        // If leaving sort:false root, or already folding - Fold to new location
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute);

            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        }

        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);

            // Unfold animation for clones if showing from hidden
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
        isOwner = _ref11.isOwner,
        activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
        rootEl = _ref12.rootEl,
        parentEl = _ref12.parentEl,
        sortable = _ref12.sortable,
        dispatchSortableEvent = _ref12.dispatchSortableEvent,
        oldIndex = _ref12.oldIndex,
        putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
        children = parentEl.children;

      // Multi-drag selection
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvent: evt
          });

          // Modifier activated, select from last to dragEl
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
              currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              (function () {
                // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                // (but previous selection existed)
                var n, i;
                if (currentIndex > lastIndex) {
                  i = lastIndex;
                  n = currentIndex;
                } else {
                  i = currentIndex;
                  n = lastIndex + 1;
                }
                var filter = options.filter;
                for (; i < n; i++) {
                  if (~multiDragElements.indexOf(children[i])) continue;
                  // Check if element is draggable
                  if (!closest(children[i], options.draggable, parentEl, false)) continue;
                  // Check if element is filtered
                  var filtered = filter && (typeof filter === 'function' ? filter.call(sortable, evt, children[i], sortable) : filter.split(',').some(function (criteria) {
                    return closest(children[i], criteria.trim(), parentEl, false);
                  }));
                  if (filtered) continue;
                  toggleClass(children[i], options.selectedClass, true);
                  multiDragElements.push(children[i]);
                  dispatchEvent({
                    sortable: sortable,
                    rootEl: rootEl,
                    name: 'select',
                    targetEl: children[i],
                    originalEvent: evt
                  });
                }
              })();
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      }

      // Multi-drag drop
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;

                  // Prepare unfold animation
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            }

            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed
            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });

            // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.
            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent('update');
                dispatchSortableEvent('sort');
              }
            }
          }

          // Must be done after capturing individual rects (scroll bar)
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }

      // Remove clones if necessary
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return;

      // Only deselect if selection is in this sortable
      if (multiDragSortable !== this.sortable) return;

      // Only deselect if target is not item in this sortable
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;

      // Only deselect if left click
      if (evt && evt.button !== 0) return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
          index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [],
        newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        });

        // multiDragElements will already be sorted if folding
        var newIndex;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}

/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */
function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sortable);



/***/ }),

/***/ "./node_modules/worker-timers-broker/build/es2019/interfaces/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/worker-timers-broker/build/es2019/interfaces/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _worker_timers_broker_definition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-timers-broker-definition */ "./node_modules/worker-timers-broker/build/es2019/interfaces/worker-timers-broker-definition.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/worker-timers-broker/build/es2019/interfaces/worker-timers-broker-definition.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/worker-timers-broker/build/es2019/interfaces/worker-timers-broker-definition.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=worker-timers-broker-definition.js.map

/***/ }),

/***/ "./node_modules/worker-timers-broker/build/es2019/module.js":
/*!******************************************************************!*\
  !*** ./node_modules/worker-timers-broker/build/es2019/module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
/* harmony import */ var broker_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! broker-factory */ "./node_modules/broker-factory/build/es2019/module.js");
/* harmony import */ var fast_unique_numbers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-unique-numbers */ "./node_modules/fast-unique-numbers/build/es5/bundle.js");
/* harmony import */ var fast_unique_numbers__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_unique_numbers__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _interfaces_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interfaces/index */ "./node_modules/worker-timers-broker/build/es2019/interfaces/index.js");
/* harmony import */ var _types_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types/index */ "./node_modules/worker-timers-broker/build/es2019/types/index.js");


/*
 * @todo Explicitly referencing the barrel file seems to be necessary when enabling the
 * isolatedModules compiler option.
 */


// Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.
const scheduledIntervalsState = new Map([[0, null]]); // tslint:disable-line no-empty
const scheduledTimeoutsState = new Map([[0, null]]); // tslint:disable-line no-empty
const wrap = (0,broker_factory__WEBPACK_IMPORTED_MODULE_0__.createBroker)({
    clearInterval: ({ call }) => {
        return (timerId) => {
            if (typeof scheduledIntervalsState.get(timerId) === 'symbol') {
                scheduledIntervalsState.set(timerId, null);
                call('clear', { timerId, timerType: 'interval' }).then(() => {
                    scheduledIntervalsState.delete(timerId);
                });
            }
        };
    },
    clearTimeout: ({ call }) => {
        return (timerId) => {
            if (typeof scheduledTimeoutsState.get(timerId) === 'symbol') {
                scheduledTimeoutsState.set(timerId, null);
                call('clear', { timerId, timerType: 'timeout' }).then(() => {
                    scheduledTimeoutsState.delete(timerId);
                });
            }
        };
    },
    setInterval: ({ call }) => {
        return (func, delay = 0, ...args) => {
            const symbol = Symbol();
            const timerId = (0,fast_unique_numbers__WEBPACK_IMPORTED_MODULE_1__.generateUniqueNumber)(scheduledIntervalsState);
            scheduledIntervalsState.set(timerId, symbol);
            const schedule = () => call('set', {
                delay,
                now: performance.timeOrigin + performance.now(),
                timerId,
                timerType: 'interval'
            }).then(() => {
                const state = scheduledIntervalsState.get(timerId);
                if (state === undefined) {
                    throw new Error('The timer is in an undefined state.');
                }
                if (state === symbol) {
                    func(...args);
                    // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().
                    if (scheduledIntervalsState.get(timerId) === symbol) {
                        schedule();
                    }
                }
            });
            schedule();
            return timerId;
        };
    },
    setTimeout: ({ call }) => {
        return (func, delay = 0, ...args) => {
            const symbol = Symbol();
            const timerId = (0,fast_unique_numbers__WEBPACK_IMPORTED_MODULE_1__.generateUniqueNumber)(scheduledTimeoutsState);
            scheduledTimeoutsState.set(timerId, symbol);
            call('set', {
                delay,
                now: performance.timeOrigin + performance.now(),
                timerId,
                timerType: 'timeout'
            }).then(() => {
                const state = scheduledTimeoutsState.get(timerId);
                if (state === undefined) {
                    throw new Error('The timer is in an undefined state.');
                }
                if (state === symbol) {
                    // A timeout can be savely deleted because it is only called once.
                    scheduledTimeoutsState.delete(timerId);
                    func(...args);
                }
            });
            return timerId;
        };
    }
});
const load = (url) => {
    const worker = new Worker(url);
    return wrap(worker);
};
//# sourceMappingURL=module.js.map

/***/ }),

/***/ "./node_modules/worker-timers-broker/build/es2019/types/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/worker-timers-broker/build/es2019/types/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _worker_timers_broker_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-timers-broker-loader */ "./node_modules/worker-timers-broker/build/es2019/types/worker-timers-broker-loader.js");
/* harmony import */ var _worker_timers_broker_wrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-timers-broker-wrapper */ "./node_modules/worker-timers-broker/build/es2019/types/worker-timers-broker-wrapper.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/worker-timers-broker/build/es2019/types/worker-timers-broker-loader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/worker-timers-broker/build/es2019/types/worker-timers-broker-loader.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=worker-timers-broker-loader.js.map

/***/ }),

/***/ "./node_modules/worker-timers-broker/build/es2019/types/worker-timers-broker-wrapper.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/worker-timers-broker/build/es2019/types/worker-timers-broker-wrapper.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=worker-timers-broker-wrapper.js.map

/***/ }),

/***/ "./node_modules/worker-timers/build/es2019/factories/load-or-return-broker.js":
/*!************************************************************************************!*\
  !*** ./node_modules/worker-timers/build/es2019/factories/load-or-return-broker.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLoadOrReturnBroker: () => (/* binding */ createLoadOrReturnBroker)
/* harmony export */ });
const createLoadOrReturnBroker = (loadBroker, worker) => {
    let broker = null;
    return () => {
        if (broker !== null) {
            return broker;
        }
        const blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });
        const url = URL.createObjectURL(blob);
        broker = loadBroker(url);
        // Bug #1: Edge up until v18 didn't like the URL to be revoked directly.
        setTimeout(() => URL.revokeObjectURL(url));
        return broker;
    };
};
//# sourceMappingURL=load-or-return-broker.js.map

/***/ }),

/***/ "./node_modules/worker-timers/build/es2019/module.js":
/*!***********************************************************!*\
  !*** ./node_modules/worker-timers/build/es2019/module.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearInterval: () => (/* binding */ clearInterval),
/* harmony export */   clearTimeout: () => (/* binding */ clearTimeout),
/* harmony export */   setInterval: () => (/* binding */ setInterval),
/* harmony export */   setTimeout: () => (/* binding */ setTimeout)
/* harmony export */ });
/* harmony import */ var worker_timers_broker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! worker-timers-broker */ "./node_modules/worker-timers-broker/build/es2019/module.js");
/* harmony import */ var _factories_load_or_return_broker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./factories/load-or-return-broker */ "./node_modules/worker-timers/build/es2019/factories/load-or-return-broker.js");
/* harmony import */ var _worker_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker/worker */ "./node_modules/worker-timers/build/es2019/worker/worker.js");



const loadOrReturnBroker = (0,_factories_load_or_return_broker__WEBPACK_IMPORTED_MODULE_1__.createLoadOrReturnBroker)(worker_timers_broker__WEBPACK_IMPORTED_MODULE_0__.load, _worker_worker__WEBPACK_IMPORTED_MODULE_2__.worker);
const clearInterval = (timerId) => loadOrReturnBroker().clearInterval(timerId);
const clearTimeout = (timerId) => loadOrReturnBroker().clearTimeout(timerId);
const setInterval = (...args) => loadOrReturnBroker().setInterval(...args);
const setTimeout = (...args) => loadOrReturnBroker().setTimeout(...args);
//# sourceMappingURL=module.js.map

/***/ }),

/***/ "./node_modules/worker-timers/build/es2019/worker/worker.js":
/*!******************************************************************!*\
  !*** ./node_modules/worker-timers/build/es2019/worker/worker.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   worker: () => (/* binding */ worker)
/* harmony export */ });
// This is the minified and stringified code of the worker-timers-worker package.
const worker = `(()=>{var e={455:function(e,t){!function(e){"use strict";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,s=2*o,a=function(e,t){return function(r){var a=t.get(r),i=void 0===a?r.size:a<s?a+1:0;if(!r.has(i))return e(r,i);if(r.size<o){for(;r.has(i);)i=Math.floor(Math.random()*s);return e(r,i)}if(r.size>n)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,u=r(i),c=a(u,i),d=t(c);e.addUniqueNumber=d,e.generateUniqueNumber=c}(t)}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(()=>{"use strict";const e=-32603,t=-32602,n=-32601,o=(e,t)=>Object.assign(new Error(e),{status:t}),s=t=>o('The handler of the method called "'.concat(t,'" returned an unexpected result.'),e),a=(t,r)=>async({data:{id:a,method:i,params:u}})=>{const c=r[i];try{if(void 0===c)throw(e=>o('The requested method called "'.concat(e,'" is not supported.'),n))(i);const r=void 0===u?c():c(u);if(void 0===r)throw(t=>o('The handler of the method called "'.concat(t,'" returned no required result.'),e))(i);const d=r instanceof Promise?await r:r;if(null===a){if(void 0!==d.result)throw s(i)}else{if(void 0===d.result)throw s(i);const{result:e,transferables:r=[]}=d;t.postMessage({id:a,result:e},r)}}catch(e){const{message:r,status:n=-32603}=e;t.postMessage({error:{code:n,message:r},id:a})}};var i=r(455);const u=new Map,c=(e,r,n)=>({...r,connect:({port:t})=>{t.start();const n=e(t,r),o=(0,i.generateUniqueNumber)(u);return u.set(o,(()=>{n(),t.close(),u.delete(o)})),{result:o}},disconnect:({portId:e})=>{const r=u.get(e);if(void 0===r)throw(e=>o('The specified parameter called "portId" with the given value "'.concat(e,'" does not identify a port connected to this worker.'),t))(e);return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=({data:t})=>e(null!==t),n.postMessage(t,[t])}))){const e=n();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),d=(e,t,r=()=>!0)=>{const n=c(d,t,r),o=a(e,n);return e.addEventListener("message",o),()=>e.removeEventListener("message",o)},l=e=>t=>{const r=e.get(t);if(void 0===r)return Promise.resolve(!1);const[n,o]=r;return clearTimeout(n),e.delete(t),o(!1),Promise.resolve(!0)},f=(e,t,r)=>(n,o,s)=>{const{expected:a,remainingDelay:i}=e(n,o);return new Promise((e=>{t.set(s,[setTimeout(r,i,a,t,e,s),e])}))},m=(e,t)=>{const r=performance.now(),n=e+t-r-performance.timeOrigin;return{expected:r+n,remainingDelay:n}},p=(e,t,r,n)=>{const o=e-performance.now();o>0?t.set(n,[setTimeout(p,o,e,t,r,n),r]):(t.delete(n),r(!0))},h=new Map,v=l(h),w=new Map,g=l(w),M=f(m,h,p),y=f(m,w,p);d(self,{clear:async({timerId:e,timerType:t})=>({result:await("interval"===t?v(e):g(e))}),set:async({delay:e,now:t,timerId:r,timerType:n})=>({result:await("interval"===n?M:y)(e,t,r)})})})()})();`; // tslint:disable-line:max-line-length
//# sourceMappingURL=worker.js.map

/***/ }),

/***/ "./resources/js/Autocomplete.js":
/*!**************************************!*\
  !*** ./resources/js/Autocomplete.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Autocomplete)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var Autocomplete = /*#__PURE__*/function () {
  function Autocomplete() {
    _classCallCheck(this, Autocomplete);
    this.$doc = $(document);
    this.init();
    this.listenEvents();
  }
  return _createClass(Autocomplete, [{
    key: "listenEvents",
    value: function listenEvents() {
      var _this = this;
      var $doc = _this.$doc;
      $doc.on('click', '.autocomplete-item', function (e) {
        e.preventDefault();
        var $this = $(this);
        var val = $this.attr('data-val');
        var href = $this.attr('href');
        var text = $this.text().trim();
        var $container = $this.closest('.autocomplete');
        var $wrapper = $container.find('.autocomplete-wrapper');
        $container.find('.autocomplete-text').val(text);
        $container.find('.autocomplete-value').val(val);
        $wrapper.hide();
        if (href !== '#') {
          window.location.href = href;
        }
      });
      $doc.mouseup(function (e) {
        var div = $(".autocomplete");
        if (!div.is(e.target) && div.has(e.target).length === 0) {
          div.find('.autocomplete-wrapper').hide();
        }
      });
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;
      var $doc = _this.$doc;
      $doc.on('focus', '.autocomplete-input', function () {
        var $input = $(this);
        var val = $input.val();
        var $container = $input.closest('.autocomplete');
        var $wrapper = $container.find('.autocomplete-wrapper');
        if ($wrapper.find('.autocomplete-item').length > 0) {
          $wrapper.slideDown();
        }
      });
      $doc.on('input', '.autocomplete-input', function () {
        var $input = $(this);
        var val = $input.val();
        var $container = $input.closest('.autocomplete');
        var $wrapper = $container.find('.autocomplete-wrapper');
        var action = $input.attr('data-action');
        var exclude = $input.attr('data-exclude');
        var html = '';
        if (val.length < 3) {
          $wrapper.html(html);
          $wrapper.hide();
          return;
        }
        var args = {
          action: action,
          string: val
        };
        if (exclude !== undefined) {
          args.exclude = exclude;
        }
        if (action !== undefined) {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.sendRequest)(adminAjax, args, 'POST').then(function (res) {
            $wrapper.html(html);
            if (res) {
              res.forEach(function (item) {
                var val = item.val || false;
                var name = item.name;
                var link = item.link || '#';
                if (val) {
                  html += "<a href=\"".concat(link, "\" data-val=\"").concat(val, "\" class=\"autocomplete-item\">").concat(name, "</a>");
                } else {
                  if (link) {
                    html += "<a href=\"".concat(link, "\" data-val=\"").concat(val, "\" class=\"autocomplete-item\">").concat(name, "</a>");
                  } else {
                    html += "<span class=\"autocomplete-item not-active\">".concat(name, "</span>");
                  }
                }
              });
              $wrapper.html(html);
              $wrapper.slideDown();
            } else {
              $wrapper.hide();
            }
          });
        }
      });
    }
  }]);
}();


/***/ }),

/***/ "./resources/js/Board.js":
/*!*******************************!*\
  !*** ./resources/js/Board.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Board)
/* harmony export */ });
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var parser = new DOMParser();
var Board = /*#__PURE__*/function () {
  function Board() {
    _classCallCheck(this, Board);
    this.init();
    this.eventListener();
  }
  return _createClass(Board, [{
    key: "eventListener",
    value: function eventListener() {
      var t = this;
      $(document).on('input', '.board-wrapper-head-form input', function (e) {
        var $i = $(this);
        var val = $i.val().trim();
        var $form = $i.closest('form');
        var status = $form.find('[name="post_status"]').val();
        if (status === undefined) return;
        (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
        var param = {
          type: $form.attr('method'),
          url: $form.attr('action'),
          data: $form.serialize()
        };
        $.ajax(param).done(function (r) {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
          if (r) {
            var $requestBody = $(parser.parseFromString(r, "text/html"));
            $(document).find(".board-column[data-status=\"".concat(status, "\"]")).html($requestBody.find(".board-column[data-status=\"".concat(status, "\"]")).html());
            $(document).find(".board-wrapper-footer__item[data-status=\"".concat(status, "\"]")).html($requestBody.find(".board-wrapper-footer__item[data-status=\"".concat(status, "\"]")).html());
          }
        });
      });
      $(document).on('click', '.get-next-board-projects', function (e) {
        e.preventDefault();
        var $t = $(this);
        var href = $t.attr('href');
        var status = $t.attr('data-status');
        $t.remove();
        (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
        var param = {
          type: 'GET',
          url: href
        };
        $.ajax(param).done(function (r) {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
          if (r) {
            var $requestBody = $(parser.parseFromString(r, "text/html"));
            $(document).find(".board-column[data-status=\"".concat(status, "\"]")).append($requestBody.find(".board-column[data-status=\"".concat(status, "\"]")).html());
            $(document).find(".board-wrapper-footer__item[data-status=\"".concat(status, "\"]")).html($requestBody.find(".board-wrapper-footer__item[data-status=\"".concat(status, "\"]")).html());
            t.removeDuplicates();
          }
        });
      });
    }
  }, {
    key: "onEnd",
    value: function onEnd(evt) {
      var sortedItems = [];
      var _status = false;
      _toConsumableArray(evt.to.children).forEach(function (item) {
        var id = item.id;
        var status = item.closest('.board-column').getAttribute('data-status');
        _status = status;
        item.classList.remove('archive');
        item.classList.remove('pending');
        item.classList.remove('publish');
        item.classList.add(status);
        item.setAttribute('data-status', status);
        sortedItems.push(Number(id));
      });
      sendChanges(sortedItems, _status);
    }
  }, {
    key: "initBoard",
    value: function initBoard() {
      var _this = this;
      document.querySelectorAll(".board-column").forEach(function (column) {
        new sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"](column, {
          group: {
            name: 'shared'
          },
          animation: 150,
          sort: false,
          ghostClass: "sortable-placeholder",
          onEnd: _this.onEnd
        });
      });
    }
  }, {
    key: "removeDuplicates",
    value: function removeDuplicates() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ".board-item";
      var items = document.querySelectorAll(selector);
      var seenIds = new Set();
      items.forEach(function (item) {
        var itemId = item.id;
        if (seenIds.has(itemId)) {
          item.remove();
        } else {
          seenIds.add(itemId);
        }
      });
    }
  }, {
    key: "init",
    value: function init() {
      var _this2 = this;
      $(document).ready(function () {
        return _this2.initBoard();
      });
    }
  }]);
}();

function sendChanges(sortedItems, status) {
  if (!status) return;
  if (sortedItems.length === 0) return;
  var param = {
    type: 'POST',
    url: adminAjax,
    data: {
      action: 'update_status_projects',
      status: status,
      sortedItems: sortedItems
    }
  };
  (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
  $.ajax(param).done(function (r) {
    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
    console.log(r);
  });
}
var b = new Board();
b.init();

/***/ }),

/***/ "./resources/js/BulkEdit.js":
/*!**********************************!*\
  !*** ./resources/js/BulkEdit.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BulkEdit)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var BulkEdit = /*#__PURE__*/function () {
  function BulkEdit() {
    _classCallCheck(this, BulkEdit);
    this.$doc = $(document);
    this.cookieName = 'selected_project';
    this.init();
  }
  return _createClass(BulkEdit, [{
    key: "test",
    value: function test() {
      var _this = this;
      var $doc = _this.$doc;
      return $doc.find('body').hasClass('user-admin');
    }
  }, {
    key: "setSelectedProjects",
    value: function setSelectedProjects() {
      var _this = this;
      var $doc = _this.$doc;
      $doc.find('.project-item').addClass('selected');
    }
  }, {
    key: "unselectedProjects",
    value: function unselectedProjects() {
      var _this = this;
      var $doc = _this.$doc;
      $doc.find('.project-item.selected').removeClass('selected');
    }
  }, {
    key: "toggleArchiveButton",
    value: function toggleArchiveButton() {
      var _this = this;
      var $doc = _this.$doc;
      var cookieName = _this.cookieName;
      var selectedProject = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCookie)(cookieName);
      if (selectedProject) {
        selectedProject = selectedProject.split(',');
        $doc.find('.archive-projects').removeClass('show');
      } else {
        selectedProject = [];
      }
      if (selectedProject.length === 0) {
        $doc.find('.archive-projects').removeClass('show');
        _this.unselectedProjects();
      } else {
        $doc.find('.archive-projects').addClass('show');
      }
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;
      var $doc = _this.$doc;
      var test = _this.test();
      var cookieName = _this.cookieName;
      if (test) {
        $doc.on('click', '.project-item.select-edit .project-item-icon', function (e) {
          e.preventDefault();
          var $t = $(this);
          $t = $t.closest('.project-item');
          var selectedProject = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCookie)(cookieName);
          if (selectedProject) {
            selectedProject = selectedProject.split(',');
          } else {
            selectedProject = [];
          }
          var id = $t.attr('data-id');
          var isSelected = $t.hasClass('selected');
          if (isSelected) {
            $t.removeClass('selected');
            if (selectedProject.includes('-1')) {
              selectedProject = [];
            } else {
              if (selectedProject) selectedProject = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.removeArrayElement)(id, selectedProject);
            }
          } else {
            $t.addClass('selected');
            selectedProject.push(id);
          }
          (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.setCookie)(cookieName, selectedProject ? selectedProject.join(',') : '', 1);
          _this.toggleArchiveButton();
        });
        $doc.on('click', '.select-all-project', function (e) {
          e.preventDefault();
          var selectedProject = [];
          var $t = $(this);
          var activeSting = $t.attr('data-active');
          var notActiveString = $t.attr('data-not-active');
          if ($t.hasClass('active')) {
            $t.removeClass('active');
            selectedProject = [];
            $t.text(activeSting);
            _this.unselectedProjects();
          } else {
            $t.addClass('active');
            selectedProject = ['-1'];
            $t.text(notActiveString);
            _this.setSelectedProjects();
          }
          (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.setCookie)(cookieName, selectedProject ? selectedProject.join(',') : '', 1);
          _this.toggleArchiveButton();
        });
        $doc.on('click', '.archive-projects', function (e) {
          e.preventDefault();
          var query = document.query || false;
          (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.sendRequest)(adminAjax, {
            'action': 'archive_projects',
            query: query
          }).then(function (res) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.setCookie)(cookieName, '', 1);
            _this.toggleArchiveButton();
            (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.renderMain)({
              url: res.url
            });
          });
        });
      }
    }
  }]);
}();


/***/ }),

/***/ "./resources/js/CommentObserver.js":
/*!*****************************************!*\
  !*** ./resources/js/CommentObserver.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CommentObserver)
/* harmony export */ });
/* harmony import */ var _$isInViewPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_$isInViewPort */ "./resources/js/_$isInViewPort.js");
/* harmony import */ var _$isInViewPort__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_$isInViewPort__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var CommentObserver = /*#__PURE__*/function () {
  function CommentObserver() {
    _classCallCheck(this, CommentObserver);
    this.requestQueue = [];
    this.readedCommentID = [];
    this.isRequesting = false;
    this.selector = '[data-reading-id]';
    this.$doc = $(document);
    this.obsever();
    this.readingCommentsInViewport();
    this.showComment();
  }
  return _createClass(CommentObserver, [{
    key: "getQueryParams",
    value: function getQueryParams() {
      var params = {};
      var queryString = window.location.search.substring(1);
      var queryArray = queryString.split("&");
      for (var i = 0; i < queryArray.length; i++) {
        var pair = queryArray[i].split("=");
        var key = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair[1] || '');
        params[key] = value;
      }
      return params;
    }
  }, {
    key: "getHash",
    value: function getHash() {
      return window.location.hash.substring(1);
    }
  }, {
    key: "highlightText",
    value: function highlightText(element, textToHighlight) {
      $(element).html(function (_, html) {
        var regex = new RegExp('(' + textToHighlight + ')', 'gi');
        return html.replace(regex, '<mark>$1</mark>');
      });
    }
  }, {
    key: "showComment",
    value: function showComment() {
      var _this = this;
      var hash = _this.getHash();
      var params = _this.getQueryParams();
      if (hash === undefined) return;
      if (hash === '') return;
      var $el = $(document).find('#' + hash);
      if ($el.length === 0) return;
      $el.addClass('showing-element');
      setTimeout(function () {
        $el.removeClass('showing-element');
      }, 5000);
      if (params.string === undefined) return;
      _this.highlightText('.content', params.string);
    }
  }, {
    key: "readingComment",
    value: function readingComment(id) {
      var _this = this;
      var isRequesting = _this.isRequesting;
      if (isRequesting || _this.readedCommentID.includes(id)) {
        var test = !_this.requestQueue.includes(id) || !_this.readedCommentID.includes(id);
        if (!_this.requestQueue.includes(id)) {
          _this.requestQueue.push(id);
        }
        console.log(_this.requestQueue);
        console.log(_this.readedCommentID);
        return;
      }
      _this.readedCommentID.push(id);
      _this.isRequesting = true;
      (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.sendRequest)(adminAjax, {
        action: 'reading_discussion',
        id: id
      }, 'POST', false).then(function (r) {
        _this.$doc.find("[data-reading-id=\"".concat(id, "\"]")).removeClass('unread');
        _this.$doc.find("[data-reading-id=\"".concat(id, "\"]")).addClass('read');
        _this.$doc.find("[data-reading-id=\"".concat(id, "\"] .discussion-item__check.unread")).removeClass('unread');
        _this.$doc.find("[data-reading-id=\"".concat(id, "\"] .discussion-item__check")).addClass('read');
        _this.$doc.find("[data-reading-id=\"".concat(id, "\"]")).removeAttr('data-reading-id');
        _this.isRequesting = false;
        if (_this.requestQueue.length > 0) {
          _this.readingComment(_this.requestQueue.shift());
        }
      });
    }
  }, {
    key: "obsever",
    value: function obsever() {
      var _this = this;
      $(window).on('load resize scroll', function () {
        _this.readingCommentsInViewport();
      });
    }
  }, {
    key: "readingCommentsInViewport",
    value: function readingCommentsInViewport() {
      var _this = this;
      var $elements = _this.$doc.find(_this.selector);
      $elements.each(function () {
        var $t = $(this);
        if ($t.isInViewport()) {
          var id = $t.attr('data-reading-id');
          _this.readingComment(id);
        }
      });
    }
  }]);
}();


/***/ }),

/***/ "./resources/js/Invite.js":
/*!********************************!*\
  !*** ./resources/js/Invite.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Invite)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var Invite = /*#__PURE__*/function () {
  function Invite() {
    _classCallCheck(this, Invite);
    this.users = {};
    this.loading = false;
    this.setUsersData();
    this.$doc = $(document);
  }
  return _createClass(Invite, [{
    key: "setUsersData",
    value: function setUsersData() {
      var t = this;
      var isLoading = t.loading;
      var storage = localStorage.getItem('users');
      var storageDate = localStorage.getItem('users-date') || '';
      var currentDate = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)();
      if (currentDate === storageDate && storage) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(storage)) {
          storage = JSON.parse(storage);
          if (storage && !(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isObjectEmpty)(storage)) {
            t.users = storage;
            t.setUsersAvatar();
            return;
          }
        }
      }
      if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isObjectEmpty)(t.users) && !isLoading) {
        t.loading = true;
        $.ajax({
          type: "post",
          url: adminAjax,
          data: {
            action: 'get_data_users'
          }
        }).done(function (r) {
          if (r && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(r)) t.users = JSON.parse(r);
          t.loading = false;
          localStorage.setItem('users', r);
          localStorage.setItem('users-date', currentDate);
          t.setUsersAvatar();
        });
      }
    }
  }, {
    key: "setUsersAvatar",
    value: function setUsersAvatar() {
      var t = this;
      var isLoading = t.loading;
      var $doc = t.$doc;
      if (!isLoading) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isObjectEmpty)(t.users)) {
          t.setUsersData();
        } else {
          $(document).find('.invite').each(function () {
            var $t = $(this);
            if ($t.find('.invite__image').length === 0) {
              var id = $t.attr('data-user-id');
              if (id) {
                var src = t.users[id].src;
                if (src) $t.prepend('<span class="invite__image"><img class="cover" alt="" src="' + src + '"></span>');
              }
            }
          });
        }
      }
    }
  }]);
}();


/***/ }),

/***/ "./resources/js/Shadow.js":
/*!********************************!*\
  !*** ./resources/js/Shadow.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Shadow)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* harmony import */ var _js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_js */ "./resources/js/_js.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var Shadow = /*#__PURE__*/function () {
  function Shadow() {
    _classCallCheck(this, Shadow);
    this.$doc = $(document);
    this.loading = false;
    this.init();
  }
  return _createClass(Shadow, [{
    key: "openShadowModal",
    value: function openShadowModal(args) {
      var _this = this;
      var loading = _this.loading;
      var $doc = _this.$doc;
      var url = args.url;
      var $container = $doc.find('#shadow-js');
      if (url === undefined) return;
      if (loading) return;
      $doc.find('body').addClass('loading');
      _this.loading = true;
      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showPreloader)();
      var param = {
        type: 'GET',
        url: url
      };
      $.ajax(param).done(function (r) {
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.hidePreloader)();
        _this.loading = false;
        if (r) {
          var shadowHost = document.getElementById('shadow-js');
          var shadowRoot = shadowHost.attachShadow({
            mode: 'open'
          });
          shadowRoot.innerHTML = r;
          $doc.find('body').removeClass('loading');
          // openWindow($container);
        }
      }).fail(function (jqXHR, textStatus, errorThrown) {
        _this.openShadowModal({
          url: url
        });
      });
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;
      var $doc = _this.$doc;
      $doc.on('click', '.shadow-window-open', function (e) {
        e.preventDefault();
        var $t = $(this);
        var url = $t.attr('href');
        _this.openShadowModal({
          url: url
        });
      });
    }
  }]);
}();


/***/ }),

/***/ "./resources/js/Stopwatch.js":
/*!***********************************!*\
  !*** ./resources/js/Stopwatch.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stopwatch)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* harmony import */ var worker_timers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! worker-timers */ "./node_modules/worker-timers/build/es2019/module.js");
/* harmony import */ var _check_notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_check-notification */ "./resources/js/_check-notification.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var Stopwatch = /*#__PURE__*/function () {
  function Stopwatch() {
    _classCallCheck(this, Stopwatch);
    this.loading = false;
    this.date = false;
    this.stopwatches = [];
    this.workTimes = [];
    this.startTimestamp = 0;
    this.finishTimestamp = 0;
    this.sum = 0;
    this.interval = null;
    this.timersInterval = null;
    this.status = 0;
    this.$doc = $(document);
    this.listenEvents();
    this.getCurrentData();
    this.cyclicallyUpdated();
  }
  return _createClass(Stopwatch, [{
    key: "clearStorage",
    value: function clearStorage() {
      var _this = this;
      _this.stopwatches = [];
      _this.workTimes = [];
      _this.startTimestamp = 0;
      _this.finishTimestamp = 0;
      _this.sum = 0;
      clearInterval(_this.interval);
      _this.interval = null;
      _this.status = 0;
      _this.$doc.find('.timer').removeClass('play').removeClass('pause');
    }
  }, {
    key: "getTimers",
    value: function getTimers() {
      var _this = this;
      var _stopwatches = _this.stopwatches;
      $.ajax({
        type: 'POST',
        url: adminAjax,
        data: {
          action: 'get_timers_html'
        }
      }).done(function (r) {
        if (r) {
          _this.$doc.find('.timer-control').html(r);
        }
      });
    }
  }, {
    key: "listenEvents",
    value: function listenEvents() {
      var _this = this;
      var _stopwatches = _this.stopwatches;
      var $doc = _this.$doc;
      _this.$doc.on('click', '.timer-button-start', function (e) {
        e.preventDefault();
        var $t = $(this);
        var $timer = $t.closest('.timer');
        _this.status = 1;
        $timer.addClass('play');
        $timer.removeClass('pause');
        _this.start();
      });
      _this.$doc.on('click', '.timer-button-finish', function (e) {
        e.preventDefault();
        var $t = $(this);
        var $timer = $t.closest('.timer');
        _this.status = 0;
        $timer.removeClass('play');
        $timer.removeClass('pause');
        _this.finish();
      });
      _this.$doc.on('click', '.timer-button-pause', function (e) {
        e.preventDefault();
        var $t = $(this);
        var $timer = $t.closest('.timer');
        _this.status = -1;
        $timer.removeClass('play');
        $timer.addClass('pause');
        _this.pauseEvent();
      });
      _this.$doc.on('click', '.timer-button-play-pause', function (e) {
        e.preventDefault();
        var $t = $(this);
        var $timer = $t.closest('.timer');
        _this.status = 1;
        $timer.addClass('play');
        $timer.removeClass('pause');
        _this.start();
      });
      _this.$doc.on('click', '.timer-result', function (e) {
        e.preventDefault();
        var $t = $(this);
        var $timer = $t.closest('.timer');
        var isOpen = $timer.hasClass('open-controls');
        if (!isOpen) {
          $timer.addClass('open-controls');
          $('body').addClass('open-timer');
          console.log(_this.status);
          console.log(_this.workTimes);
          console.log(_this.workTimes.length);
          if ((_this.status === 0 || isNaN(_this.status)) && _this.workTimes.length === 0) {
            _this.$doc.find('.timer-button-start').trigger('click');
          }
        } else {
          $timer.removeClass('open-controls');
          $('body').removeClass('open-timer');
        }
        if ($t.hasClass('admin-timers')) {
          _this.getTimers();
          clearInterval(_this.timersInterval);
          _this.timersInterval = (0,worker_timers__WEBPACK_IMPORTED_MODULE_1__.setInterval)(function () {
            _this.getTimers();
          }, 60000);
        }
      });
      _this.$doc.on('click', '.report-button-trigger', function (e) {
        e.preventDefault();
        var $t = $(this);
        _this.$doc.find('.report-footer-control').hide();
        _this.$doc.find('.report-footer-form').show();
      });
      _this.$doc.mouseup(function (e) {
        var div = $(".timer");
        if (!div.is(e.target) && div.has(e.target).length === 0) {
          div.removeClass('open-controls');
          $('body').removeClass('open-timer');
          clearInterval(_this.timersInterval);
        }
      });
      document.onvisibilitychange = function () {
        if (document.visibilityState === "hidden") {
          _this.$doc.find('.timer').addClass('not-active');
        }
        if (document.visibilityState === "visible") {
          _this.getCurrentData();
        }
      };
      _this.$doc.on('click', '.project-start', function (e) {
        e.preventDefault();
        var $t = $(this);
        var id = $t.attr('data-id');
        var title = $t.attr('data-title');
        var permalink = $t.attr('data-permalink');
        var $timer = _this.$doc.find('.timer');
        if (!$timer.hasClass('play')) {
          _this.$doc.find('.timer-button-start').trigger('click');
        }
        $t.addClass('not-active');
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showPreloader)();
        $.ajax({
          type: 'POST',
          url: adminAjax,
          data: {
            action: 'starting_project',
            project_id: id
          }
        }).done(function (r) {
          $doc.find('.timer-project span').text(title);
          $doc.find('.timer-project').attr('href', permalink);
          if (r) {
            if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(r)) {
              var res = JSON.parse(r);
              if (res.msg !== '' && res.msg !== undefined) {
                (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(res.msg);
              }
            } else {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(r);
            }
            (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.hidePreloader)();
          }
        });
      });
    }
  }, {
    key: "tick",
    value: function tick(data) {
      var _this = this;
      if (_this.$doc.find('.test-timer').length > 0) {
        var status = Number(data.status);
        var results = data.results;
        var work = results.work;
        var pause = results.pause;
        var pauseSeconds = pause.seconds;
        var workSeconds = work.seconds;
        (0,worker_timers__WEBPACK_IMPORTED_MODULE_1__.setInterval)(function () {
          if (status === 1) {
            workSeconds = workSeconds + 1;
          } else if (status === -1) {
            pauseSeconds = pauseSeconds + 1;
          }
          var formatedTime = _this.convertMillisecondsToTime(workSeconds * 1000);
          var formatedPauseTime = _this.convertMillisecondsToTime(pauseSeconds * 1000);
          var formatedTimeString = formatedTime['hours'] + ':' + formatedTime['minutes'] + ':' + formatedTime['seconds'];
          var formatedPauseTimeString = formatedPauseTime['hours'] + ':' + formatedPauseTime['minutes'] + ':' + formatedPauseTime['seconds'];
          _this.$doc.find('.timer-work-time span').text(formatedTimeString);
          _this.$doc.find('.timer-pause-time span').text(formatedPauseTimeString);
        }, 1000);
      }
    }
  }, {
    key: "runTick",
    value: function runTick() {
      var _this = this;
      var _status = _this.status;
      console.log(_status);
      // if (_this.$doc.find('.test-timer').length > 0) return;
      if (_status === 0) {
        if (_this.interval !== null) {
          clearInterval(_this.interval);
        }
      } else {
        console.log(_this.interval);
        if (_this.interval === null) {
          _this.interval = (0,worker_timers__WEBPACK_IMPORTED_MODULE_1__.setInterval)(function () {
            _this.renderResults();
          }, 1000);
        }
      }
    }
  }, {
    key: "renderResults",
    value: function renderResults() {
      var _this = this;
      var _stopwatches = _this.stopwatches;
      var _startTimestamp = _this.startTimestamp;
      var _finishTimestamp = _this.finishTimestamp;
      var _status = _this.status;
      var currentTime = _this.getCurrentTimestamp();
      var stopwatchSum = _this.getStopwatchSum();
      var workTimesSum = _this.getWorkTimesSum();
      var finish = _finishTimestamp > 0 ? _finishTimestamp : currentTime;
      var sum = workTimesSum - stopwatchSum;
      var formatedTime = _this.convertMillisecondsToTime(workTimesSum);
      var formatedPauseTime = _this.convertMillisecondsToTime(stopwatchSum);
      var formatedTimeString = formatedTime['hours'] + ':' + formatedTime['minutes'] + ':' + formatedTime['seconds'];
      var formatedPauseTimeString = formatedPauseTime['hours'] + ':' + formatedPauseTime['minutes'] + ':' + formatedPauseTime['seconds'];
      if (workTimesSum > 0) _this.$doc.find('.timer-result').text(formatedTimeString);
      _this.$doc.find('.timer-work-time span').text(formatedTimeString);
      _this.$doc.find('.timer-pause-time span').text(formatedPauseTimeString);
    }
  }, {
    key: "getStopwatchSum",
    value: function getStopwatchSum() {
      var _this = this;
      var _stopwatches = _this.stopwatches;
      var _sum = 0;
      var l = _stopwatches.length - 1;
      for (var a = 0; a < _stopwatches.length; a++) {
        var item = _stopwatches[a];
        var start = Number(item.start || 0);
        var finish = item.finish ? Number(item.finish) : _this.getCurrentTimestamp();
        finish = Number(finish);
        if (finish === 0) {
          if (a < l) {
            finish = start;
          } else {
            finish = finish === 0 ? Number(_this.getCurrentTimestamp()) : finish;
          }
        }
        var subSum = finish - start;
        _sum = _sum + subSum;
      }
      return _sum;
    }
  }, {
    key: "getWorkTimesSum",
    value: function getWorkTimesSum() {
      var _this = this;
      var _workTimes = _this.workTimes;
      var _stopwatches = _this.stopwatches;
      var _status = _this.status;
      var l = _workTimes.length - 1;
      var _sum = 0;
      var test = 0;
      for (var a = 0; a < _workTimes.length; a++) {
        var item = _workTimes[a];
        var start = Number(item.start || 0);
        var finish = Number(item.finish);
        if (finish === 0) {
          if (a < l) {
            finish = start;
          } else {
            finish = finish === 0 ? _this.getCurrentTimestamp() : finish;
          }
        }
        var subSum = finish - start;
        _sum = _sum + subSum;
      }
      return _sum;
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;
      var _status = _this.status;
      var _finishTimestamp = _this.finishTimestamp;
      var _stopwatches = _this.stopwatches;
      var _workTimes = _this.workTimes;
      var unix = Number(_this.getCurrentTimestamp());
      var lastIndexWorkTimes = _workTimes.length - 1;
      if (lastIndexWorkTimes >= 0) {
        var lastFinishWorkTimes = Number(_workTimes[lastIndexWorkTimes].finish) || 0;
        if (lastFinishWorkTimes === 0) {
          _workTimes[lastIndexWorkTimes].finish = unix;
        }
      }
      if (_status === 1) {
        _workTimes.push({
          start: unix,
          finish: 0
        });
      }
      _this.workTimes = _workTimes;
      if (_this.startTimestamp === 0) {
        _this.startTimestamp = unix;
      } else {
        var lastIndex = _stopwatches.length - 1;
        if (lastIndex >= 0) {
          var lastFinish = Number(_stopwatches[lastIndex].finish);
          if (lastFinish === 0) {
            _stopwatches[lastIndex].finish = unix;
            _this.stopwatches = _stopwatches;
          }
        }
        if (_finishTimestamp > 0) {
          _this.finishTimestamp = 0;
        }
      }
      _this.saveData(false, true, true);
    }
  }, {
    key: "pauseEvent",
    value: function pauseEvent() {
      var _this = this;
      var _stopwatches = _this.stopwatches;
      var unix = Number(_this.getCurrentTimestamp());
      var _workTimes = _this.workTimes;
      var lastIndex = _stopwatches.length - 1;
      _stopwatches.push({
        start: unix,
        finish: 0
      });
      _this.stopwatches = _stopwatches;
      var workTimesLastIndex = _workTimes.length - 1;
      if (workTimesLastIndex >= 0) {
        _workTimes[workTimesLastIndex].finish = unix;
        _this.workTimes = _workTimes;
      }
      _this.saveData(false, true, true);
    }
  }, {
    key: "finish",
    value: function finish() {
      var _this = this;
      var _stopwatches = _this.stopwatches;
      var _workTimes = _this.workTimes;
      var lastIndex = _stopwatches.length - 1;
      var unix = Number(_this.getCurrentTimestamp());
      if (lastIndex >= 0) {
        if (Number(_stopwatches[lastIndex].finish) === 0) {
          _stopwatches[lastIndex].finish = unix;
          _this.stopwatches = _stopwatches;
        }
      }
      _this.finishTimestamp = unix;
      var workTimesLastIndex = _workTimes.length - 1;
      if (workTimesLastIndex >= 0) {
        _workTimes[workTimesLastIndex].finish = unix;
        _this.workTimes = _workTimes;
      }
      clearInterval(_this.interval);
      _this.renderResults();
      _this.saveData(true, true, true);
    }
  }, {
    key: "getCurrentTimestamp",
    value: function getCurrentTimestamp() {
      return Number(Date.now());
    }
  }, {
    key: "getTimestampInSeconds",
    value: function getTimestampInSeconds() {
      return Math.floor(Date.now() / 1000);
    }
  }, {
    key: "convertMillisecondsToTime",
    value: function convertMillisecondsToTime(milliseconds) {
      var date = new Date(milliseconds);
      var hours = date.getUTCHours();
      var minutes = date.getUTCMinutes();
      var seconds = date.getUTCSeconds();
      hours = hours < 10 ? "0" + hours : hours;
      minutes = minutes < 10 ? "0" + minutes : minutes;
      seconds = seconds < 10 ? "0" + seconds : seconds;
      return {
        hours: hours,
        minutes: minutes,
        seconds: seconds
      };
    }
  }, {
    key: "getCurrentDate",
    value: function getCurrentDate() {
      var today = new Date();
      var day = today.getDate();
      var month = today.getMonth() + 1;
      var year = today.getFullYear();
      day = day < 10 ? "0" + day : day;
      month = month < 10 ? "0" + month : month;
      return day + "-" + month + "-" + year;
    }
  }, {
    key: "saveData",
    value: function saveData() {
      var getResultModal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var showLoader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var changeStatus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var _this = this;
      var _status = _this.status;
      if (_this.date === false) _this.date = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)();
      if (_this.date !== (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)()) {
        _this.clearStorage();
      }
      if (_this.loading === true) {
        console.log('loading: ' + _this.loading);
        if (changeStatus) {
          alert('🚨🚨🚨 Увага‼️ Виникла помилка! Сторінка оновиться і повторіть дію знову!');
        }
        window.location.reload();
        return;
      }
      var _finishTimestamp = _this.finishTimestamp;
      var _startTimestamp = _this.startTimestamp;
      var _stopwatches = _this.stopwatches;
      var _workTimes = _this.workTimes;
      var sum = _this.getWorkTimesSum();
      var sumPauses = _this.getStopwatchSum();
      var currentDate = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCurrentDate)();
      _this.loading = true;
      var data = {
        'action': 'save_user_time',
        get_result_modal: getResultModal ? '1' : '0',
        date: currentDate,
        work_times: _workTimes,
        stopwatches: _stopwatches,
        start: _startTimestamp,
        finish: _finishTimestamp,
        costs_sum: sum,
        costs_sum_hour: _this.convertMillisecondsToTime(sum),
        pause_time: sumPauses,
        pause_time_hour: _this.convertMillisecondsToTime(sumPauses)
      };
      if (changeStatus) {
        data.status = _status;
      }
      if (showLoader) {
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showPreloader)();
      }
      $.ajax({
        type: 'POST',
        url: adminAjax,
        data: data
      }).done(function (r) {
        _this.loading = false;
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.hidePreloader)();
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(r)) {
          var res = JSON.parse(r);
          var html = res.timer_modal_html;
          var msg = res.msg;
          var resStaus = res.__status;
          if (resStaus !== undefined) {
            resStaus = Number(resStaus);
            if (resStaus !== _this.status) {
              alert('🚨🚨🚨 Увага‼️ Виникла помилка! Сторінка оновиться і повторіть дію знову!');
              window.location.reload();
            } else {
              if (_this.status === 1) {
                (0,_check_notification__WEBPACK_IMPORTED_MODULE_2__.playSoundPlay)();
              } else if (_this.status === -1) {
                (0,_check_notification__WEBPACK_IMPORTED_MODULE_2__.pauseSoundPlay)();
              }
            }
          }
          if (changeStatus) {
            if (msg !== undefined && msg !== '') {
              _this.runTick();
            } else {
              alert('🚨🚨🚨 Увага‼️ Виникла помилка! Сторінка оновиться і повторіть дію знову!');
              window.location.reload();
            }
          }
          if (res.title !== undefined && res.title !== '') {
            $(document).find('title').text(res.title);
          }
          if (msg !== undefined && msg !== '') {
            alert(msg);
          }
          if (html !== undefined && html !== '') {
            if (_this.$doc.find('#report-window').length > 0) (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.closeWindow)(_this.$doc.find('#report-window'));
            $('body').append(html);
            setTimeout(function () {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.openWindow)(_this.$doc.find('#report-window'));
            }, 500);
          }
        } else {
          alert(r);
        }
      }).fail(function (jqXHR, textStatus, errorThrown) {
        console.log(jqXHR);
        console.log(textStatus);
        console.log(errorThrown);
        _this.loading = false;
        _this.saveData(getResultModal, showLoader, changeStatus);
      });
    }
  }, {
    key: "getCurrentData",
    value: function getCurrentData() {
      var saveData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var _this = this;
      var date = _this.getCurrentDate();
      if (_this.date !== date) {
        _this.clearStorage();
      }
      var data = {
        action: 'get_user_time',
        date: date
      };
      $.ajax({
        type: 'POST',
        url: adminAjax,
        data: data
      }).done(function (r) {
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.hidePreloader)();
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(r)) {
          var res = JSON.parse(r);
          console.log(res);
          console.log(res.cost_id);
          if (res) {
            _this.$doc.find('.timer').removeClass('not-active');
            if (res.cost_id !== 0) {
              var pauses = res.pauses || [];
              var costs_data = res.costs_data || [];
              var costs_status = res.costs_status;
              var costs_start = res.costs_start || 0;
              var costs_finish = res.costs_finish || 0;
              var timer_modal_html = res.timer_modal_html;
              var costs_sum_hour = res.costs_sum_hour;
              var costs_sum = res.costs_sum;
              var costs_sum_hour_pause = res.costs_sum_hour_pause;
              var costs_sum_pause = res.costs_sum_pause;
              if (res.title !== undefined && res.title !== '') {
                $(document).find('title').text(res.title);
              }
              if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(pauses)) pauses = JSON.parse(pauses);
              if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(costs_data)) costs_data = JSON.parse(costs_data);
              _this.stopwatches = pauses;
              _this.workTimes = costs_data;
              _this.startTimestamp = Number(costs_start || 0);
              _this.finishTimestamp = Number(costs_finish || 0);
              _this.status = Number(costs_status);
              _this.renderResults();
              console.log(_this.status);
              if (_this.status === 1) {
                _this.$doc.find('.timer').removeClass('pause');
                _this.$doc.find('.timer').addClass('play');
                _this.runTick();
              } else if (_this.status === -1) {
                _this.$doc.find('.timer').addClass('pause');
                _this.$doc.find('.timer').removeClass('play');
                _this.runTick();
                (0,_check_notification__WEBPACK_IMPORTED_MODULE_2__.pauseSoundPlay)();
              } else {
                _this.$doc.find('.timer').removeClass('pause');
                _this.$doc.find('.timer').removeClass('play');
              }
              if (res.reload) {
                window.location.reload();
                return;
              }
              if (saveData) _this.saveData();
            }
          } else {
            window.location.reload();
          }
        }
      }).fail(function (jqXHR, textStatus, errorThrown) {
        console.log(jqXHR);
        console.log(textStatus);
        console.log(errorThrown);
        _this.getCurrentData();
      });
    }
  }, {
    key: "cyclicallyUpdated",
    value: function cyclicallyUpdated() {
      var _this = this;
      (0,worker_timers__WEBPACK_IMPORTED_MODULE_1__.setInterval)(function () {
        _this.getCurrentData(true);
      }, 60000);
    }
  }]);
}();


/***/ }),

/***/ "./resources/js/_$isInViewPort.js":
/*!****************************************!*\
  !*** ./resources/js/_$isInViewPort.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
$.fn.isInViewport = function () {
  var elementTop = $(this).offset().top;
  var elementBottom = elementTop + $(this).outerHeight();
  var viewportTop = $(window).scrollTop();
  var viewportBottom = viewportTop + $(window).height();
  return elementBottom > viewportTop && elementTop < viewportBottom;
};

/***/ }),

/***/ "./resources/js/_check-notification.js":
/*!*********************************************!*\
  !*** ./resources/js/_check-notification.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ checkingNotifications),
/* harmony export */   newMessageSoundPlay: () => (/* binding */ newMessageSoundPlay),
/* harmony export */   pauseSoundPlay: () => (/* binding */ pauseSoundPlay),
/* harmony export */   playSoundPlay: () => (/* binding */ playSoundPlay),
/* harmony export */   setNotificationsNumber: () => (/* binding */ setNotificationsNumber)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* harmony import */ var worker_timers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! worker-timers */ "./node_modules/worker-timers/build/es2019/module.js");
/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! howler */ "./node_modules/howler/dist/howler.js");
/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(howler__WEBPACK_IMPORTED_MODULE_2__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");



function checkingNotifications() {
  setNotificationsNumber();
  (0,worker_timers__WEBPACK_IMPORTED_MODULE_1__.setInterval)(setNotificationsNumber, 20000);
}
var setNotificationsNumber = function setNotificationsNumber() {
  var $selector = $(document).find('.header-notification-button span');
  if ($selector.length === 0) return;
  var oldNum = $selector.text() || 0;
  oldNum = Number(oldNum);
  (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.sendRequest)(adminAjax, {
    action: 'get_user_notifications'
  }, 'POST', false).then(function (res) {
    var newNum = res.count || 0;
    var notifications = res.notifications || [];
    var hash = res.hash || '';
    var notificationsHash = localStorage.getItem('notificationsHash') || '';
    if (hash !== notificationsHash && newNum > 0) {
      setTimeout(newMessageSoundPlay, 1000);
      var title = localStorage.getItem('title') || $(document).find('title').text();
      $(document).find('title').text('(' + newNum + ') ' + title);
    }
    localStorage.setItem('notificationsHash', hash);
    newNum = Number(newNum);
    $selector.text(newNum);
  })["catch"](function (error) {
    console.error('Помилка:', error);
  });
};
function newMessageSoundPlay() {
  var audioElement = document.getElementById('new-message-sound');
  var src = audioElement.getAttribute('src');
  if (src) {
    var audio = new Audio(src);
    audio.play();
    var sound = new howler__WEBPACK_IMPORTED_MODULE_2__.Howl({
      src: [src]
    });
    sound.play();
  }
}
function pauseSoundPlay() {
  var audioElement = document.getElementById('pause-sound');
  var src = audioElement.getAttribute('src');
  if (src) {
    var audio = new Audio(src);
    audio.play();
    var sound = new howler__WEBPACK_IMPORTED_MODULE_2__.Howl({
      src: [src]
    });
    sound.play();
  }
}
function playSoundPlay() {
  var audioElement = document.getElementById('play-sound');
  var src = audioElement.getAttribute('src');
  if (src) {
    var audio = new Audio(src);
    audio.play();
    var sound = new howler__WEBPACK_IMPORTED_MODULE_2__.Howl({
      src: [src]
    });
    sound.play();
  }
}

/***/ }),

/***/ "./resources/js/_forms.js":
/*!********************************!*\
  !*** ./resources/js/_forms.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isValidForm: () => (/* binding */ isValidForm)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* harmony import */ var _quill_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_quill-init */ "./resources/js/_quill-init.js");
/* harmony import */ var _Invite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Invite */ "./resources/js/Invite.js");
/* harmony import */ var _js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_js */ "./resources/js/_js.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");





var $doc = $(document);
$doc.ready(function () {
  $doc.on('submit', '.form-js', function (e) {
    e.preventDefault();
    var $form = $(this);
    var this_form = $form.attr('id');
    var test = isValidForm($form);
    if (test) {
      var thisForm = document.getElementById(this_form);
      var formData = new FormData(thisForm);
      (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showPreloader)();
      $.ajax({
        type: $form.attr('method'),
        url: adminAjax,
        processData: false,
        contentType: false,
        data: formData
      }).done(function (r) {
        $(document).find('.comment-form-title').slideUp();
        $(document).find('.parent-comment-id').val(0);
        var projectID = $form.find('[name="project_id"]').val();
        if (projectID !== undefined) localStorage.removeItem('comment-for-project-' + projectID);
        var _r = r || '';
        var resetTriggerTest = !$form.hasClass('profile-form') && !$form.hasClass('profile-notifications') && !$form.hasClass('change-user-form');
        if (!_r.includes('Error establishing a database connection')) {
          if (resetTriggerTest) $form.trigger('reset');
          $form.find('.form-files-result').html('');
        }
        if ($form.hasClass('event-window-form')) {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.closeWindow)();
        }
        if (r) {
          if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isJsonString)(r)) {
            var res = JSON.parse(r);
            if (res.avatar !== undefined) {
              $doc.find('.profile-head-user__avatar img').attr('src', res.avatar);
              $doc.find('.header-avatar img').attr('src', res.avatar);
              $doc.find('.avatar-modal-image img').attr('src', res.avatar);
            }
            if ($form.hasClass('user-avatar-form')) {
              if (res.avatar !== undefined) {
                $form.addClass('uploaded-avatar');
              } else {
                $form.removeClass('uploaded-avatar');
              }
            }
            if (res.change_data !== undefined) {
              var changedData = res.change_data;
              if (changedData.user_id === undefined) {
                if (changedData.name) {
                  $doc.find('.profile-head-user__name').text(changedData.name);
                }
                if (changedData.email) {
                  $doc.find('.profile-email').text(changedData.email);
                }
                if (changedData.user_tel) {
                  $doc.find('.profile-tel').text(changedData.user_tel);
                }
                if (changedData.position) {
                  $doc.find('.profile-head-position').text(changedData.position);
                }
              } else {
                var $row = $doc.find('.users-table-body-row[data-id="' + changedData.user_id + '"]');
                if (changedData.name) {
                  $row.find('.users-table-item__name').text(changedData.name);
                }
                if (changedData.email) {
                  $row.find('.profile-email').text(changedData.email);
                }
                if (changedData.user_tel) {
                  $row.find('.profile-tel').text(changedData.user_tel);
                }
                if (changedData.position) {
                  $row.find('.users-table__position').text(changedData.position);
                }
              }
            }
            if (res.msg !== '' && res.msg !== undefined) {
              if ($form.hasClass('report-footer-form')) {
                $doc.find('.report-cart-changed').text(res.msg);
              } else {
                (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(res.msg);
              }
            }
            if ($form.hasClass('login-form') && res.type === 'success' || res.is_reload === 'true') {
              window.location.reload();
              return false;
            }
            if (res.comment_html !== '' && res.comment_html !== undefined) {
              $doc.find('.section-comments-list').prepend(res.comment_html);
            }
            if (res.comments_html !== '' && res.comments_html !== undefined) {
              $doc.find('.section-comments-content').html(res.comments_html);
            }
            if (res.events_html !== undefined) {
              $doc.find('.events-section .container').html(res.events_html);
            }
            if (res.event_html !== undefined && res.event_id !== undefined) {
              $doc.find('#event-' + res.event_id).replaceWith(res.event_html);
            }
            if (res.comment_html_update !== '' && res.comment_html_update !== undefined) {
              var comment_id = res.comment_id;
              $doc.find('#comment-' + comment_id).replaceWith(res.comment_html_update);
            }
            if (res.comment_answers !== '' && res.comment_answers !== undefined) {
              var _comment_id = res.comment_id;
              $doc.find('#comment-answers-' + _comment_id).html(res.comment_answers);
              if ($doc.find('#comment-answers-' + _comment_id).length > 0) {
                if ($form.closest('.window-main').length === 0) {
                  $('html, body').animate({
                    scrollTop: $doc.find('#comment-answers-' + _comment_id).offset().top - 200
                  });
                } else {
                  $form.closest('.window-main').animate({
                    scrollTop: $form.closest('.window-main').find('#comment-answers-' + _comment_id).offset().top - 200
                  });
                }
              }
            }
            if ($form.hasClass('report-footer-form')) {
              if (res.time !== '' && res.time !== undefined) {
                $doc.find('.report-cart-sum').text(res.time);
                $doc.find('.timer-result').text(res.time);
                $doc.find('.timer-work-time span').text(res.time);
                $form.remove();
              }
            }
            if (res.url !== undefined) {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showPreloader)();
              (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.renderMain)({
                url: res.url,
                addToHistory: true
              });
            }
          } else {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(r);
          }
        }
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.hidePreloader)();
        (0,_quill_init__WEBPACK_IMPORTED_MODULE_1__.setQiullText)();
        var invite = new _Invite__WEBPACK_IMPORTED_MODULE_2__["default"]();
      });
    }
  });
  $doc.on('change', '.profile-notifications input', function (e) {
    $(this).closest('form').trigger('submit');
  });
});
function isValidForm($form) {
  var test = true,
    thsInputs = $form.find('input, textarea'),
    $select = $form.find('select[required]');
  var $address = $form.find('input.address-js[required]');
  $select.each(function () {
    var $ths = $(this);
    var $label = $ths.closest('.form-group');
    var val = $ths.val();
    console.log(val);
    if (Array.isArray(val) && val.length === 0) {
      console.log(1);
      test = false;
      $label.addClass('error');
    } else {
      console.log(2);
      $label.removeClass('error');
      if (val === null || val === undefined) {
        console.log(3);
        test = false;
        $label.addClass('error');
      }
    }
  });
  thsInputs.each(function () {
    var thsInput = $(this),
      $label = thsInput.closest('.form_element'),
      thsInputType = thsInput.attr('type'),
      thsInputVal = thsInput.val().trim(),
      inputReg = new RegExp(thsInput.data('reg')),
      inputTest = inputReg.test(thsInputVal);
    if (thsInput.attr('required')) {
      if (thsInputVal.length <= 0) {
        test = false;
        thsInput.addClass('error');
        $label.addClass('error');
        thsInput.focus();
        if (thsInputType === 'file') {
          $form.find('.cabinet-item__photo-item').eq(0).addClass('error');
          $('html, body').animate({
            scrollTop: $form.find('.cabinet-item__photo-item').eq(0).offset().top
          });
        }
      } else {
        thsInput.removeClass('error');
        $label.removeClass('error');
        if (thsInput.data('reg')) {
          if (inputTest === false) {
            test = false;
            thsInput.addClass('error');
            $label.addClass('error');
            thsInput.focus();
          } else {
            thsInput.removeClass('error');
            $label.removeClass('error');
          }
        }
        if (thsInputType === 'file') {
          $form.find('.cabinet-item__photo-item').eq(0).removeClass('error');
        }
      }
    }
    if (thsInput.hasClass('time-input')) {
      if ((0,_js__WEBPACK_IMPORTED_MODULE_3__.validateTime)(thsInputVal)) {
        thsInput.removeClass('error');
        $label.removeClass('error');
      } else {
        test = false;
        thsInput.addClass('error');
        $label.addClass('error');
        thsInput.focus();
      }
    }
  });
  var $password = $form.find('input[name="password"]');
  var $passwordRepeat = $form.find('input[name="repeat_password"]');
  var $passwordOld = $form.find('input[name="old_password"]');
  var $passwordNew = $form.find('input[name="new_password"]');
  if (!$form.hasClass('login-form')) {
    if ($password.length > 0 && $passwordRepeat.length > 0) {
      if ($password.val() !== $passwordRepeat.val()) {
        $password.addClass('error');
        $passwordRepeat.addClass('error');
        return false;
      }
      if (!isValidPassword($password.val())) {
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(errorPswMsg);
        $password.addClass('error');
        $passwordRepeat.addClass('error');
        return false;
      }
      $password.removeClass('error');
      $passwordRepeat.removeClass('error');
    } else if ($password.length > 0 && $password.val().length > 0) {
      if (!isValidPassword($password.val())) {
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(errorPswMsg);
        $password.addClass('error');
        $passwordRepeat.addClass('error');
        return false;
      }
      $password.removeClass('error');
      $passwordRepeat.removeClass('error');
    }
    if ($passwordOld.length > 0 && $passwordNew.length > 0) {
      if (!isValidPassword($passwordNew.val())) {
        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(errorPswMsg);
        $passwordNew.addClass('error');
        return false;
      }
      $passwordNew.removeClass('error');
    }
  }
  var $inp = $form.find('input[name="consent"]');
  if ($inp.length > 0) {
    if ($inp.prop('checked') === false) {
      $inp.closest('.form-consent').addClass('error');
      return false;
    }
    $inp.closest('.form-consent').removeClass('error');
  }
  if ($address.length > 0) {
    var addressTest = true;
    $address.each(function (index) {
      var $el = $(this);
      var val = $el.val() || '';
      var selected = $el.attr('data-selected') || '';
      if (selected.trim() !== val.trim()) {
        test = false;
        addressTest = false;
        $el.addClass('error');
      } else {
        $el.removeClass('error');
      }
      if (val.length === 0) {
        test = false;
        $el.addClass('error');
      }
    });
    if (!addressTest) (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.showMassage)(locationErrorString);
  }
  if ($form.hasClass('comment-form')) {
    if ($form.find('.value-field').val().trim().length === 0) return false;
  }
  return test;
}

/***/ }),

/***/ "./resources/js/_header.js":
/*!*********************************!*\
  !*** ./resources/js/_header.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function burgerInit() {
  var $doc = $(document);
  var $window = $(window);
  var $el = $doc.find('.header-bottom');
  var $header = $doc.find('.header');
  var $burger = $doc.find('.burger');
  var status = false;
  $doc.ready(function () {
    $doc.on('click', '.burger', function (e) {
      e.preventDefault();
      var $t = $(this);
      if ($t.hasClass('active')) {
        $t.removeClass('active');
        $header.removeClass('active-menu');
        $el.slideUp();
        status = false;
      } else {
        $t.addClass('active');
        $header.addClass('active-menu');
        $el.slideDown();
        status = true;
      }
    });
  });
  $window.on('resize', function () {
    if ($window.width() >= 870 && status) {
      status = false;
      $el.removeAttr('style');
      $header.removeClass('active-menu');
      $burger.removeClass('active');
    }
  });
}
burgerInit();

/***/ }),

/***/ "./resources/js/_helpers.js":
/*!**********************************!*\
  !*** ./resources/js/_helpers.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bytesToKB: () => (/* binding */ bytesToKB),
/* harmony export */   bytesToMB: () => (/* binding */ bytesToMB),
/* harmony export */   changeProjectStatus: () => (/* binding */ changeProjectStatus),
/* harmony export */   closeWindow: () => (/* binding */ closeWindow),
/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard),
/* harmony export */   getCookie: () => (/* binding */ getCookie),
/* harmony export */   getCurrentDate: () => (/* binding */ getCurrentDate),
/* harmony export */   hidePreloader: () => (/* binding */ hidePreloader),
/* harmony export */   isElementInViewport: () => (/* binding */ isElementInViewport),
/* harmony export */   isImageUrl: () => (/* binding */ isImageUrl),
/* harmony export */   isJsonString: () => (/* binding */ isJsonString),
/* harmony export */   isObjectEmpty: () => (/* binding */ isObjectEmpty),
/* harmony export */   openWindow: () => (/* binding */ openWindow),
/* harmony export */   removeArrayElement: () => (/* binding */ removeArrayElement),
/* harmony export */   renderInModalHTML: () => (/* binding */ renderInModalHTML),
/* harmony export */   renderMain: () => (/* binding */ renderMain),
/* harmony export */   renderMainInModal: () => (/* binding */ renderMainInModal),
/* harmony export */   sendRequest: () => (/* binding */ sendRequest),
/* harmony export */   setCookie: () => (/* binding */ setCookie),
/* harmony export */   showMassage: () => (/* binding */ showMassage),
/* harmony export */   showPreloader: () => (/* binding */ showPreloader)
/* harmony export */ });
/* harmony import */ var _quill_init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_quill-init */ "./resources/js/_quill-init.js");
/* harmony import */ var _Invite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Invite */ "./resources/js/Invite.js");
/* harmony import */ var _js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_js */ "./resources/js/_js.js");
/* harmony import */ var _CommentObserver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CommentObserver */ "./resources/js/CommentObserver.js");
/* harmony import */ var _Board__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Board */ "./resources/js/Board.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }





var $doc = $(document);
var load = false;
var loading = false;
var parser = new DOMParser();
function openWindow($window) {
  $window.addClass('active');
  $('body').addClass('open-window');
  if ($window.find('.close-window').length > 0) return;
  $window.append('<button class="close-window"><svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15" fill="none">\n' + '<path d="M0.732457 15C0.3282 15 0.000106331 14.6719 0.000106331 14.2677C0.000106331 14.0743 0.0762708 13.8868 0.213953 13.7492L13.7478 0.215311C14.0349 -0.0717704 14.4977 -0.0717704 14.7848 0.215311C15.0719 0.502393 15.0719 0.965239 14.7848 1.25232L1.25096 14.7862C1.11328 14.9238 0.925798 15 0.732457 15Z" fill="white"/>\n' + '<path d="M14.2647 15C14.0714 15 13.8839 14.9238 13.7462 14.7862L0.212381 1.25232C-0.0747001 0.965239 -0.0747001 0.502393 0.212381 0.215311C0.499463 -0.0717704 0.962309 -0.0717704 1.24939 0.215311L14.7832 13.7492C15.0703 14.0362 15.0703 14.4991 14.7832 14.7862C14.6456 14.9238 14.4581 15 14.2647 15Z" fill="white"/>\n' + '</svg></button>');
}
function closeWindow() {
  var $window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $('.modal-window, .dialog-window, .window-main');
  $window.removeClass('active');
  $('body').removeClass('open-window');
  $doc.find('.window-main:not(.active)').html('');
  $doc.find('.report.window-main').remove();
}
function isJsonString(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }
  return true;
}
function showPreloader() {
  $('.preloader').addClass('active');
}
function hidePreloader() {
  $('.preloader').removeClass('active');
}
function showMassage(message) {
  // closeWindow();
  $('#dialog-js .dialog-title').html(message);
  openWindow($('#dialog-js'));
  setTimeout(function () {
    closeWindow($('#dialog-js'));
  }, 3000);
}
function renderMain(args) {
  closeWindow();
  var url = args.url;
  var addToHistory = args.addToHistory || false;
  var $container = $doc.find('main.content');
  if (url === undefined) return;
  if (loading) return;
  $doc.find('body').addClass('loading');
  loading = true;
  showPreloader();
  var param = {
    type: 'GET',
    url: url
  };
  $.ajax(param).done(function (r) {
    loading = false;
    if (r) {
      var $requestBody = $(parser.parseFromString(r, "text/html"));
      var title = $requestBody.find('title').html();
      $container.html($requestBody.find('main.content').html());
      $doc.find('title').html(title);
      if (addToHistory) history.pushState({}, "", url);
      $doc.find('body').removeClass('loading');
      localStorage.setItem('title', title);
      (0,_js__WEBPACK_IMPORTED_MODULE_2__.initPlugins)();
      (0,_quill_init__WEBPACK_IMPORTED_MODULE_0__["default"])();
      var invite = new _Invite__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var hash = undefined;
      if (_typeof(url) === 'object') {
        hash = url.hash || undefined;
      } else {
        hash = url.split('#')[1];
      }
      if (hash !== undefined) {
        var $el = $doc.find('#' + hash);
        if ($el.length === 0) return;
        $('html, body').animate({
          scrollTop: $el.offset().top
        }, 500);
      } else {
        $('html,body').animate({
          scrollTop: 0
        }, 400);
      }
      var $menuItem = $doc.find(".header-menu a[href=\"".concat(url, "\"]"));
      if ($menuItem.length > 0) {
        $doc.find(".header-menu li").removeClass('current-menu-item');
        $menuItem.closest('li').addClass('current-menu-item');
      }
      var commentObserver = new _CommentObserver__WEBPACK_IMPORTED_MODULE_3__["default"]();
      var board = new _Board__WEBPACK_IMPORTED_MODULE_4__["default"]();
      board.initBoard();
    }
    hidePreloader();
  }).fail(function (jqXHR, textStatus, errorThrown) {
    loading = false;
    renderMain({
      url: url
    });
  });
}
function renderMainInModal(args) {
  closeWindow();
  var url = args.url;
  var $container = $doc.find('#window-main-js');
  $container.html('');
  if (url === undefined) return;
  if (loading) return;
  $doc.find('body').addClass('loading');
  loading = true;
  showPreloader();
  var param = {
    type: 'GET',
    url: url,
    data: {
      subtype: 'modal'
    }
  };
  $.ajax(param).done(function (r) {
    hidePreloader();
    loading = false;
    if (r) {
      var $requestBody = $(parser.parseFromString(r, "text/html"));
      $container.html(r);
      $doc.find('body').removeClass('loading');
      (0,_js__WEBPACK_IMPORTED_MODULE_2__.initPlugins)();
      (0,_quill_init__WEBPACK_IMPORTED_MODULE_0__["default"])();
      var invite = new _Invite__WEBPACK_IMPORTED_MODULE_1__["default"]();
      openWindow($container);
      var commentObserver = new _CommentObserver__WEBPACK_IMPORTED_MODULE_3__["default"]();
    }
  }).fail(function (jqXHR, textStatus, errorThrown) {
    console.log(jqXHR);
    console.log(textStatus);
    console.log(errorThrown);
    renderMainInModal({
      url: url
    });
  });
}
function renderInModalHTML(html) {
  var $container = $doc.find('#window-main-js');
  $container.html('');
  $container.html(html);
  $doc.find('body').removeClass('loading');
  (0,_js__WEBPACK_IMPORTED_MODULE_2__.initPlugins)();
  (0,_quill_init__WEBPACK_IMPORTED_MODULE_0__["default"])();
  var invite = new _Invite__WEBPACK_IMPORTED_MODULE_1__["default"]();
  openWindow($container);
  var commentObserver = new _CommentObserver__WEBPACK_IMPORTED_MODULE_3__["default"]();
}
function changeProjectStatus(args) {
  args.action = 'change_project_status';
  showPreloader();
  $.ajax({
    type: 'POST',
    url: adminAjax,
    data: args
  }).done(function (r) {
    if (r) {
      if (isJsonString(r)) {
        var res = JSON.parse(r);
        if (res.comment_html !== '' && res.comment_html !== undefined) {
          $doc.find('.section-comments-list').prepend(res.comment_html);
        }
        if (res.msg !== '' && res.msg !== undefined) {
          showMassage(res.msg);
        }
        if (res.comments_html !== '' && res.comments_html !== undefined) {
          $doc.find('.section-comments-content').html(res.comments_html);
        }
        if (res.url !== undefined) {
          showPreloader();
          setTimeout(function () {
            window.location.href = res.url;
            return;
          }, 3100);
        }
        if (res.button_text !== undefined) {
          $doc.find('.project-button-action').text(res.button_text);
        }
      } else {
        showMassage(r);
      }
    }
    hidePreloader();
  });
}
var isObjectEmpty = function isObjectEmpty(objectName) {
  return JSON.stringify(objectName) === "{}";
};
function isElementInViewport(el) {
  if (typeof jQuery === "function" && el instanceof jQuery) {
    el = el[0];
  }
  var rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
}
function sendRequest(url) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';
  var isShowPreloader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return new Promise(function (resolve, reject) {
    $doc.find('body').addClass('loading');
    if (isShowPreloader) showPreloader();
    var param = {
      type: method,
      url: url,
      success: function success(r) {
        hidePreloader();
        $doc.find('body').removeClass('loading');
        if (r) {
          if (isJsonString(r)) {
            resolve(JSON.parse(r));
          } else {
            resolve(r);
          }
        } else {
          alert('Error');
        }
      },
      error: function error(jqXHR, textStatus, errorThrown) {
        hidePreloader();
        console.log(jqXHR, textStatus, errorThrown);
        reject(errorThrown);
      }
    };
    if (args) param.data = args;
    $.ajax(param);
  });
}
function getCurrentDate() {
  var today = new Date();
  var day = today.getDate();
  var month = today.getMonth() + 1;
  var year = today.getFullYear();
  day = day < 10 ? "0" + day : day;
  month = month < 10 ? "0" + month : month;
  return day + "-" + month + "-" + year;
}
function setCookie(name, value, days) {
  var expires = "";
  if (days) {
    var date = new Date();
    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
    expires = "; expires=" + date.toUTCString();
  }
  document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/; Secure; SameSite=None";
}
function getCookie(name) {
  var matches = document.cookie.match(new RegExp("(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
  return matches ? decodeURIComponent(matches[1]) : undefined;
}
function removeArrayElement(element, array) {
  array = array.filter(function (item) {
    return item !== element;
  });
  return array;
}
var bytesToMB = function bytesToMB(bytes) {
  return (bytes / (1024 * 1024)).toFixed(2);
};
var bytesToKB = function bytesToKB(bytes) {
  return Math.floor(bytes / 1000);
};
function copyToClipboard(text) {
  var tempInput = document.createElement('textarea');
  tempInput.value = text;
  document.body.appendChild(tempInput);
  tempInput.select();
  tempInput.setSelectionRange(0, 99999);
  document.execCommand('copy');
  document.body.removeChild(tempInput);
  console.log('Скопійовано в буфер обміну: ' + text);
  showMassage('Copied 🖇️');
}
function isImageUrl(string) {
  return /(jpg|gif|png|JPG|GIF|PNG|JPEG|jpeg|HEIF|heif)$/.test(string);
}

/***/ }),

/***/ "./resources/js/_js.js":
/*!*****************************!*\
  !*** ./resources/js/_js.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initPlugins: () => (/* binding */ initPlugins),
/* harmony export */   initTriggers: () => (/* binding */ initTriggers),
/* harmony export */   validateTime: () => (/* binding */ validateTime)
/* harmony export */ });
/* harmony import */ var selectric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! selectric */ "./node_modules/selectric/public/jquery.selectric.js");
/* harmony import */ var selectric__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(selectric__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery_ui_ui_widgets_datepicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-ui/ui/widgets/datepicker */ "./node_modules/jquery-ui/ui/widgets/datepicker.js");
/* harmony import */ var jquery_ui_ui_widgets_datepicker__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_widgets_datepicker__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* harmony import */ var _quill_init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_quill-init */ "./resources/js/_quill-init.js");
/* harmony import */ var _Invite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Invite */ "./resources/js/Invite.js");
/* harmony import */ var _Stopwatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Stopwatch */ "./resources/js/Stopwatch.js");
/* harmony import */ var _Shadow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Shadow */ "./resources/js/Shadow.js");
/* harmony import */ var _CommentObserver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CommentObserver */ "./resources/js/CommentObserver.js");
/* harmony import */ var _check_notification__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_check-notification */ "./resources/js/_check-notification.js");
/* harmony import */ var _BulkEdit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./BulkEdit */ "./resources/js/BulkEdit.js");
/* harmony import */ var _forms__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_forms */ "./resources/js/_forms.js");
/* harmony import */ var _profile__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_profile */ "./resources/js/_profile.js");
/* harmony import */ var _notice__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_notice */ "./resources/js/_notice.js");
/* harmony import */ var _Autocomplete__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Autocomplete */ "./resources/js/Autocomplete.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");














var $doc = $(document);
function validateTime(time) {
  var timeRegex = /^([01]\d|2[0-3]):([0-5]\d)$/;
  return timeRegex.test(time);
}
function initTriggers() {
  $doc.on('change', '.trigger-on-select', function (e) {
    var $this = $(this);
    var $option = $this.find('option:selected');
    if ($option.length === 0) return;
    var selector = $option.attr('data-selector');
    var val = $option.attr('data-val');
    var $selector = $doc.find(selector);
    if ($selector.length === 0) return;
    $selector.val(val);
  });
  $doc.on('change', '.submit-on-select', function (e) {
    $(this).closest('form').trigger('submit');
  });
  $doc.on('click', '.modal-open', function (e) {
    e.preventDefault();
    var $t = $(this);
    var href = $t.attr('href');
    if (href === undefined) return;
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isImageUrl)(href)) {
      $doc.find('.window-main').html('<div class="window-main-image"><img src="' + href + '"  alt=""></div>');
      (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.openWindow)($doc.find('.window-main'));
      return;
    }
    var $el = $doc.find(href);
    if ($el.length === 0) return;
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.openWindow)($el);
  });
  $doc.on('click', '.close-window', function (e) {
    e.preventDefault();
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.closeWindow)();
  });
  $doc.on('change', '.show-on-change', function (e) {
    var $t = $(this);
    var elem = $t.attr('data-element');
    if (elem === undefined) return;
    var $el = $doc.find(elem);
    if ($el.length === 0) return;
    if ($t.prop('checked') === true) {
      $el.slideDown(500);
      $el.find('input[type="text"]').attr('required', 'required');
    } else {
      $el.slideUp(500);
      $el.find('input[type="text"]').removeAttr('required');
    }
  });
  $doc.on('focus', '.copy-on-change', function (e) {
    var $t = $(this);
    var isCopied = $t.attr('data-copied') !== undefined;
    if (!isCopied) {
      var $copiedElement = $t.clone();
      $copiedElement.insertAfter($t);
      $t.attr('data-copied', 'copied');
      $copiedElement.removeAttr('required');
    }
  });
}
function initPlugins() {
  $('.selectric').selectric().on('change', function () {
    var $t = $(this);
    if ($t.attr('name') === 'project_tag') {
      var $option = $t.find('option:selected');
      if ($option.length > 0) {
        var color = $option.attr('data-color');
        if (color !== undefined) {
          $t.closest('.project-tag-form').css('background-color', color);
        }
      }
    }
  });
  $('input.date-input').datepicker({
    changeMonth: true,
    changeYear: true,
    dateFormat: "dd-mm-yy"
  });
}
$(document).ready(function () {
  (0,_check_notification__WEBPACK_IMPORTED_MODULE_8__["default"])();
  initTriggers();
  initPlugins();
  $doc.on('click', '.project-button-action', function (e) {
    e.preventDefault();
    var $t = $(this);
    var isOpen = $t.hasClass('project-open');
    var id = $t.attr('data-id');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.changeProjectStatus)({
      id: id,
      status: isOpen ? 'pending' : 'archive'
    });
    if (isOpen) {
      $t.removeClass('project-open');
      $t.addClass('project-close');
    } else {
      $t.addClass('project-open');
      $t.removeClass('project-close');
    }
  });
  $doc.on('click', '.link-js', function (e) {
    e.preventDefault();
    var $t = $(this);
    var url = $t.attr('href');
    var test = $t.hasClass('open-in-modal') && !$t.closest('section').hasClass('project-section-children');
    if (test && $(window).width() > 450) {
      (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.renderMainInModal)({
        url: url
      });
      return;
    }
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.renderMain)({
      url: url,
      addToHistory: true
    });
  });
  $doc.on('click', '.comment-remove_answer', function (e) {
    e.preventDefault();
    var $t = $(this);
    $t.closest('.comment-form-title').slideUp();
    $doc.find('.parent-comment-id').val(0);
  });
  $doc.on('click', '.comment-answers__next-page', function (e) {
    e.preventDefault();
    var $t = $(this);
    var url = $t.attr('href');
    var $wrapper = $t.closest('.comment-answers');
    $t.addClass('not-active');
    if (url === undefined || url === '#') {
      return;
    }
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showPreloader)();
    $.ajax({
      type: "GET",
      url: url
    }).done(function (r) {
      $t.remove();
      (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.hidePreloader)();
      if (r) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isJsonString)(r)) {
          var res = JSON.parse(r);
          if (res.msg !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(res.msg);
          }
          if (res.html !== '' && res.html !== undefined) {
            $wrapper.append(res.html);
            var _invite = new _Invite__WEBPACK_IMPORTED_MODULE_4__["default"]();
          }
        }
      }
    });
  });
  $doc.on('click', '.window-close', function (e) {
    e.preventDefault();
    var $t = $(this);
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.closeWindow)($t.closest('.dialog-window'));
  });
  $doc.on('click', '.dismiss-user__button', function (e) {
    e.preventDefault();
    var $t = $(this);
    var userID = $t.attr('data-user-id');
    if (userID !== undefined) {
      var data = {
        action: 'dismiss_user',
        userID: userID
      };
      (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.sendRequest)(adminAjax, data, 'POST').then(function (res) {
        if (res) {
          if (res.msg !== '' && res.msg !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(res.msg);
          }
          if (res.type === 'success' && res.user_id !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.closeWindow)();
            $doc.find('.users-table-body-row[data-user="' + res.user_id + '"]').remove();
            $doc.find('#change-user-' + res.user_id).remove();
            $doc.find('#dismiss-user-' + res.user_id).remove();
          }
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)('Error');
        }
      });
    }
  });
  $doc.on('click', '.return-user__button', function (e) {
    e.preventDefault();
    var $t = $(this);
    var userID = $t.attr('data-user-id');
    if (userID !== undefined) {
      var data = {
        action: 'return_user',
        userID: userID
      };
      (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.sendRequest)(adminAjax, data, 'POST').then(function (res) {
        if (res) {
          if (res.msg !== '' && res.msg !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(res.msg);
          }
          if (res.type === 'success' && res.user_id !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.closeWindow)();
            $doc.find('.users-table-body-row[data-user="' + res.user_id + '"]').remove();
            $doc.find('#change-user-' + res.user_id).remove();
            $doc.find('#dismiss-user-' + res.user_id).remove();
          }
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)('Error');
        }
      });
    }
  });
  $doc.on('click auxclick mousedown', '.discussion-item:not(.change-user-time-item)', function (e) {
    e.preventDefault();
    var $t = $(this);
    var $title = $t.find('.discussion-item__title');
    var url = $title.attr('href');
    var target = e.target;
    var $el = $(target);
    if ($el.attr('href') && $el.attr('href') !== url) {
      if (e.button === 1) {
        console.log("Середня кнопка миші натиснута!");
        window.open($el.attr('href'), "_blank");
        return;
      }
    }
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.renderMain)({
      url: url,
      addToHistory: true
    });
  });
  $doc.on('click', '.copy-link', function (e) {
    e.preventDefault();
    var $t = $(this);
    var url = $t.attr('href');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(url);
  });
  $doc.on('click', 'div.profile-head-user__avatar', function (e) {
    e.preventDefault();
    var $t = $(this);
    var $img = $t.find('img');
    if ($img.length === 0) return;
    var url = $img.attr('src');
    $doc.find('.window-main').html('<div class="window-main-image"><img src="' + url + '"  alt=""></div>');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.openWindow)($doc.find('.window-main'));
  });
  $doc.on('click', '.text img', function (e) {
    e.preventDefault();
    var $t = $(this);
    var url = $t.attr('src');
    if (url === undefined) return;
    if (url.includes('cleanshot')) {
      return;
    }
    $doc.find('.window-main').html('<div class="window-main-image"><img src="' + url + '"  alt=""></div>');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.openWindow)($doc.find('.window-main'));
  });
  $doc.on('click', '.header-notification-button', function (e) {
    e.preventDefault();
    var $t = $(this);
    $t.find('span').text(0);
    $.ajax({
      type: "POST",
      url: adminAjax,
      data: {
        action: 'delete_user_notifications'
      }
    }).done(function (r) {
      console.log(r);
    });
  });
  $doc.on('click', '.calendar-table-item', function (e) {
    e.preventDefault();
    var $t = $(this);
    var id = $t.attr('data-id');
    var href = $t.attr('href');
    $t.addClass('active');
    if (href === undefined) return;
    var $el = $doc.find(href);
    if ($el.length === 0) return;
    $('html, body').animate({
      scrollTop: $el.offset().top
    });
    $el.addClass('shake');
    setTimeout(function () {
      $el.removeClass('shake');
      $t.removeClass('active');
    }, 1000);
    // if (id === undefined) return;
    // $doc.find('.delete-absence').attr('data-id', id);
    // $doc.find('.delete-absence').addClass('active');
    // showMassage('Натисніть "Esc" ⌨️ щоб відмінити операцію')
  });
  $doc.on('click', '.delete-absence', function (e) {
    e.preventDefault();
    var $t = $(this);
    var id = $t.attr('data-id');
    if (id === undefined) return;
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showPreloader)();
    $.ajax({
      type: "POST",
      url: adminAjax,
      data: {
        action: 'delete_user_absence',
        id: id
      }
    }).done(function (r) {
      (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.hidePreloader)();
      $t.removeClass('active');
      $t.removeAttr('data-id');
      if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isJsonString)(r)) {
        var res = JSON.parse(r);
        if (res) {
          if (res.deleted_id !== undefined && res.deleted_id !== '') {
            $doc.find(".calendar-table-item[data-id=\"".concat(res.deleted_id, "\"]")).remove();
          }
          if (res.msg !== undefined && res.msg !== '') {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(res.msg);
          }
        }
      } else {
        (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(r);
      }
    });
  });
  $doc.on('click', '.vote-js', function (e) {
    e.preventDefault();
    var $t = $(this);
    var $form = $t.closest('form');
    var test = 0;
    $form.find('.vote-status-input').val('1');
    $form.find('input[type="checkbox"],input[type="radio"]').each(function () {
      if ($(this).prop('checked') === true) test = test + 1;
    });
    if (test > 0) {
      $form.removeClass('vote-error');
      $form.trigger('submit');
    } else {
      $form.addClass('vote-error');
    }
  });
  $doc.on('click', '.header-menu a', function (e) {
    e.preventDefault();
    var $t = $(this);
    var url = $t.attr('href');
    $('.header-menu li').removeClass('current-menu-item');
    $t.closest('li').addClass('current-menu-item');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.renderMain)({
      url: url,
      addToHistory: true
    });
  });
  $doc.on('click', 'a[href^="http"]', function (e) {
    var $t = $(this);
    if (this.hostname !== window.location.hostname) {
      e.preventDefault();
      window.open($t.attr('href'), '_blank');
    }
  });
  $doc.on('click', '.comment-remove-js', function (e) {
    e.preventDefault();
    var $t = $(this);
    var id = $t.attr('data-id');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showPreloader)();
    $.ajax({
      type: 'POST',
      url: adminAjax,
      data: {
        action: 'remove_comment',
        comment_id: id
      }
    }).done(function (r) {
      if (r) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isJsonString)(r)) {
          var res = JSON.parse(r);
          if (res.msg !== '' && res.msg !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(res.msg);
          }
          if (res.type === 'success') {
            $t.closest('.comment').remove();
          } else {
            $t.remove();
          }
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(r);
        }
        (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.hidePreloader)();
      }
    });
  });
  $doc.on('click', '.comment-like-js', function (e) {
    e.preventDefault();
    var $t = $(this);
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showPreloader)();
    $t.closest('.comment-like-wrapper').removeAttr('data-time');
    $.ajax({
      type: 'GET',
      url: $t.attr('href')
    }).done(function (r) {
      if (r) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isJsonString)(r)) {
          var res = JSON.parse(r);
          if (res.msg !== '' && res.msg !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(res.msg);
            return;
          }
          var likes = res.likes || [];
          var userID = res.userID || 0;
          var counter = res.count || 0;
          var html = res.html || '';
          $t.closest('.comment-like-wrapper').find('.comment-likes-counter').text(counter);
          $t.closest('.comment-like-wrapper').find('.comment-like-wrapper-list').html(html);
          if (likes.includes(userID)) {
            $t.addClass('active');
          } else {
            $t.removeClass('active');
          }
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(r);
        }
        (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.hidePreloader)();
      }
    });
  });
  $doc.on('mouseenter', '.comment-like-wrapper', function (e) {
    e.preventDefault();
    var $t = $(this);
    var start = Date.now() / 1000;
    var last = $t.attr('data-time');
    if (last !== undefined) {
      last = Number(last);
      console.log(last);
      console.log(start);
      var diff = start - last;
      console.log(diff);
      if (diff <= 60) return;
    }
    $t.attr('data-time', start);
    $.ajax({
      type: 'POST',
      url: adminAjax,
      data: {
        'action': 'get_comment_liked',
        'id': $t.attr('data-id')
      }
    }).done(function (r) {
      if (r) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isJsonString)(r)) {
          var res = JSON.parse(r);
          if (res.msg !== '' && res.msg !== undefined) {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(res.msg);
            return;
          }
          var html = res.html || '';
          var time = res.time || 0;
          var counter = res.count || 0;
          $t.closest('.comment-like-wrapper').find('.comment-likes-counter').text(counter);
          $t.find('.comment-like-wrapper-list').html(html);
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)(r);
        }
      }
    });
  });
  $doc.on('input', 'input[type="tel"]', function () {
    $(this).val($(this).val().replace(/[A-Za-zА-Яа-яЁё]/, ''));
  });
  $doc.on('change', 'input.upload-files', function () {
    var t = this;
    var $t = $(t);
    var $form = $t.closest('form');
    var filesList = t.files;
    var HTML = "";
    if (filesList) {
      var l = filesList.length;
      for (var index = 0; index < l; index++) {
        var item = filesList[index];
        var name = item.name;
        var size = item.size;
        size = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.bytesToKB)(size);
        var html = "<li>".concat(name, " (").concat(size, "KB)</li>");
        HTML += html;
      }
    }
    $form.find('.form-files-result').html(HTML);
  });
  $doc.on('keyup', function (e) {
    //modal-window
    //window-main
    if (e.key === "Escape") {
      $doc.find('.delete-absence').removeClass('active');
      $doc.find('.calendar-table-item').removeClass('active');
      var $window = $doc.find('.modal-window.active');
      if ($window.length > 0) {
        $window.removeClass('active');
        $('body').removeClass('open-window');
      } else {
        $window = $doc.find('.window-main.active');
        if ($window.length > 0) {
          $window.removeClass('active');
          $('body').removeClass('open-window');
        } else {
          $doc.find('.timer.open-controls').removeClass('open-controls');
          $('body').removeClass('open-timer');
        }
      }
    }
  });
  $doc.mouseup(function (e) {
    var div = $(".window-main.active, .modal-window.active, .dialog-window.active");
    if (!div.is(e.target) && div.has(e.target).length === 0) {
      if (!$doc.find('.ui-datepicker').is(':visible')) div.find('.close-window').trigger('click');
    }
  });
  $doc.on('click', '[data-cost-id]', function (e) {
    e.preventDefault();
    var $t = $(this);
    var id = $t.attr('data-cost-id');
    var date = $t.attr('data-date');
    var user = $t.attr('data-user-id');
    if (id === undefined || date === undefined) return;
    var data = {
      action: 'get_user_time_modal',
      id: id,
      date: date,
      user: user
    };
    $doc.find('body').addClass('loading');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showPreloader)();
    $doc.find('.report.window-main').remove();
    var param = {
      type: 'POST',
      url: adminAjax,
      data: data
    };
    $.ajax(param).done(function (r) {
      $doc.find('body').removeClass('loading');
      if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isJsonString)(r)) {
        var res = JSON.parse(r);
        var html = res.timer_modal_html;
        if (html !== undefined && html !== '') {
          $('body').append(html);
          setTimeout(function () {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.hidePreloader)();
            (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.openWindow)($doc.find('#report-window'));
          }, 500);
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.hidePreloader)();
        }
      }
    }).fail(function (jqXHR, textStatus, errorThrown) {
      $doc.find('body').removeClass('loading');
      console.log(jqXHR);
    });
  });
  var invite = new _Invite__WEBPACK_IMPORTED_MODULE_4__["default"]();
  var stopwatch = new _Stopwatch__WEBPACK_IMPORTED_MODULE_5__["default"]();
  var shadow = new _Shadow__WEBPACK_IMPORTED_MODULE_6__["default"]();
  var commentObserver = new _CommentObserver__WEBPACK_IMPORTED_MODULE_7__["default"]();
  var bulkEditor = new _BulkEdit__WEBPACK_IMPORTED_MODULE_9__["default"]();
  var autocomplete = new _Autocomplete__WEBPACK_IMPORTED_MODULE_13__["default"]();
});
document.addEventListener('visibilitychange', function () {
  if (!document.hidden) {
    (0,_check_notification__WEBPACK_IMPORTED_MODULE_8__.setNotificationsNumber)();
  }
});
window.onpopstate = function (event) {
  (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.renderMain)({
    url: document.location
  });
};

/***/ }),

/***/ "./resources/js/_logo-init.js":
/*!************************************!*\
  !*** ./resources/js/_logo-init.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tm */ "./resources/js/tm.js");
/* harmony import */ var _tm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tm__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

var LogoWM = function () {
  function LogoWM(option) {
    var _ = this;
    _.elem = option.element;
    _.params = option;
    _.speed = option.speed || 1;
    _.reinitOnFocus = option.reinitOnFocus || false;
    _.callCallback = true;
    _.timelineArray = [];
    _.played = false;
    return _.inite();
  }
  ;
  LogoWM.prototype.forEachTL = function (event) {
    var _ = this;
    _.timelineArray.forEach(function (el, index, arr) {
      el[event]();
    });
  };
  LogoWM.prototype.reverse = function (func, index) {
    var _ = this;
    if (_.played === true) {
      return;
    }
    if (typeof func == "function") {
      TweenLite.delayedCall(_.timelineArray[_.timelineArray.length - 1].time() - (index !== undefined ? _.speed : .5), func);
    }
    if (index === undefined) {
      _.forEachTL("reverse");
      _.animateEnd = false;
    } else {
      _.timelineArray[index].reverse(-(_.speed / 3));
    }
  };
  LogoWM.prototype.play = function (index) {
    var _ = this;
    if (_.played === false) {
      if (index === undefined) {
        _.forEachTL("play");
        _.animateEnd = false;
      } else {
        window.setTimeout(function () {
          _.animateEnd = true;
        }, _.speed * 1000);
        _.timelineArray[index].play(_.speed / 3);
      }
      return;
    }
    _.played = true;
  };
  LogoWM.prototype.inite = function () {
    var _ = this;
    if (_.reinitOnFocus) {
      _.elem.get(0).addEventListener("click", function () {
        if (!_.animateEnd) {
          return;
        }
        _.callCallback = false;
        _.animateEnd = false;
        _.reverse(function () {
          _.play(0);
        }, 0);
      });
    }
    _.shapes = _.elem.find("polygon");
    _.paths = _.elem.find('> path');
    _.polylion_stagger = 0.04;
    _.polylion_staggerFrom = {
      opacity: 0,
      scale: 0,
      transformOrigin: "center center"
    };
    _.polylion_staggerTo = {
      opacity: 1,
      scale: 1,
      transformOrigin: "center center",
      ease: Elastic.easeInOut
    };
    _.path_staggerTo = {
      opacity: 1,
      scale: 1,
      delay: .4,
      transformOrigin: "center center",
      ease: Elastic.easeInOut
    };
    tMax.set(_.elem, {
      autoAlpha: 1
    });
    _.newPolylion = new TimelineMax({
      paused: _.params.paused
    });
    _.timelineArray.push(_.newPolylion);
    _.newPolylion.staggerFromTo(_.shapes, _.speed, _.polylion_staggerFrom, _.polylion_staggerTo, _.polylion_stagger);
    if (_.paths.length) {
      _.newPath = new TimelineMax({
        paused: _.params.paused
      });
      _.newPath.staggerFromTo(_.paths, _.speed, _.polylion_staggerFrom, _.path_staggerTo, _.polylion_stagger, .5);
      _.timelineArray.push(_.newPath);
    }
    _.timelineArray[_.timelineArray.length - 1].eventCallback("onComplete", function () {
      _.animateEnd = true;
      if (_.callCallback) {
        (_.params.onComplete || function () {})(this);
      } else {
        _.callCallback = true;
      }
    });
    if (!_.params.paused) {
      _.play();
    }
  };
  return LogoWM;
}();
var tMax = TweenMax;
$(document).ready(function () {
  if ($('.wm_logo').length > 0) {
    var joystick_logo = new LogoWM({
      element: $(".wm_logo"),
      paused: false,
      speed: 1,
      reinitOnFocus: true
    });
    setTimeout(function () {
      joystick_logo.play();
    }, 10000);
    setTimeout(function () {
      $('.preload').fadeOut(300);
    }, 4000);
  }
});

/***/ }),

/***/ "./resources/js/_notice.js":
/*!*********************************!*\
  !*** ./resources/js/_notice.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNotice: () => (/* binding */ getNotice)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

$(document).ready(function () {
  getNotice();
  updateNotice();
  $(document).on('click', '.close-notice', function (e) {
    e.preventDefault();
    var $t = $(this);
    var id = $t.attr('data-id');
    if (id === undefined) {
      return;
    }
    $t.closest('div').slideUp();
    $.ajax({
      type: "POST",
      url: adminAjax,
      data: {
        action: 'remove_user_notice',
        id: id
      }
    }).done(function (r) {
      $t.closest('div').remove();
      if (r) {
        $(document).find('.notifications').html(r);
        $(document).find('.notifications > *').show();
      }
    });
  });
});
document.addEventListener('visibilitychange', function () {
  console.log(document.visibilityState);
  if (document.visibilityState === 'visible') {
    getNotice();
  }
});
function updateNotice() {
  var time = 60000;
  setInterval(getNotice, time);
}
function getNotice() {
  console.log('getNotice');
  $.ajax({
    type: "POST",
    url: adminAjax,
    data: {
      action: 'get_user_notice'
    }
  }).done(function (r) {
    if (r) {
      $(document).find('.notifications').html(r);
      $(document).find('.notifications > *').slideDown();
    }
  });
}

/***/ }),

/***/ "./resources/js/_profile.js":
/*!**********************************!*\
  !*** ./resources/js/_profile.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

var $doc = $(document);
$doc.ready(function () {
  $doc.on('click', '.remove-avatar', function (e) {
    e.preventDefault();
    var $t = $(this);
    var $form = $t.closest('form');
    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.sendRequest)(adminAjax, {
      action: 'remove_avatar'
    }).then(function (res) {
      $form.removeClass('uploaded-avatar');
      if (res.avatar !== undefined) {
        $doc.find('.profile-head-user__avatar img').attr('src', res.avatar);
        $doc.find('.header-avatar img').attr('src', res.avatar);
        $doc.find('.avatar-modal-image img').attr('src', res.avatar);
      }
    })["catch"](function (error) {
      console.error('Помилка:', error);
    });
  });
  $doc.on('change', '.upload-avatar', function (e) {
    e.preventDefault();
    var $t = $(this);
    var $form = $t.closest('form');
    var val = $t.val();
    if (val) {
      $form.trigger('submit');
    }
  });
});

/***/ }),

/***/ "./resources/js/_projects.js":
/*!***********************************!*\
  !*** ./resources/js/_projects.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   renderContainer: () => (/* binding */ renderContainer)
/* harmony export */ });
/* harmony import */ var selectric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! selectric */ "./node_modules/selectric/public/jquery.selectric.js");
/* harmony import */ var selectric__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(selectric__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* harmony import */ var _CommentObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CommentObserver */ "./resources/js/CommentObserver.js");
/* harmony import */ var _js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_js */ "./resources/js/_js.js");
/* harmony import */ var _Invite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Invite */ "./resources/js/Invite.js");
/* harmony import */ var _forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_forms */ "./resources/js/_forms.js");
/* harmony import */ var _quill_init__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_quill-init */ "./resources/js/_quill-init.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");







var $doc = $(document);
var load = false;
var loading = false;
var parser = new DOMParser();
var $body = $('body');
$doc.ready(function () {
  $doc.on('click', '.project-item-status', function (e) {
    e.preventDefault();
    var $this = $(this);
    var status = $this.attr('data-status');
    var id = $this.attr('data-id');
    var $wrapper = $this.closest('.project-item-statuses');
    var $elements = $wrapper.find('.project-item-status');
    var $showed = $wrapper.find('.project-item-status').not('.active');
    var $active = $wrapper.find('.project-item-status.active');
    var activeStatus = $active.attr('data-status');
    if ($wrapper.hasClass('active')) {
      $wrapper.removeClass('active');
      $showed.slideUp();
    } else {
      $wrapper.addClass('active');
      $showed.slideDown();
    }
    if (!$this.hasClass('active')) {
      if (activeStatus !== status) {
        $active.attr('data-status', status);
        $active.attr('style', $this.attr('style'));
        $active.text($this.text());
        if (status === undefined) return;
        if (id === undefined) return;
        (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
        $.ajax({
          type: "POST",
          url: adminAjax,
          data: {
            action: 'change_project_status',
            status: status,
            id: id
          }
        }).done(function (r) {
          if (r) {
            if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isJsonString)(r)) {
              var res = JSON.parse(r);
              if (res) {
                if (res.msg !== undefined && res.msg !== '') {
                  (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(res.msg);
                }
              }
            } else {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(r);
            }
          }
          (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
        });
      }
    }
  });
  $doc.on('click', '.project-colors__item', function (e) {
    e.preventDefault();
    var $this = $(this);
    var isActive = $this.hasClass('active');
    var $wrapper = $this.closest('.project-colors');
    var $active = $wrapper.find('.project-colors-active');
    var $list = $wrapper.find('.project-colors-list');
    var id = $this.attr('data-id');
    var tagID = $this.attr('data-tag-id');
    var color = $this.attr('data-color');
    $wrapper.find('.project-colors__item').removeClass('active');
    $wrapper.find('.project-colors__item').text('+');
    if (isActive) {
      $this.removeClass('active');
      $this.text('+');
      $active.css('background-color', '#fff');
    } else {
      $this.addClass('active');
      $this.text('✕');
      if (color !== undefined) $active.css('background-color', color);
    }
    $list.slideUp();
    console.table(id, tagID);
    if (id === undefined) return;
    if (tagID === undefined) return;
    $.ajax({
      type: "POST",
      url: adminAjax,
      data: {
        action: 'change_color_tag',
        id: id,
        tagID: tagID,
        'type': isActive ? 'remove' : 'add'
      }
    }).done(function (r) {
      (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
      if (r) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isJsonString)(r)) {
          var res = JSON.parse(r);
          if (res) {
            console.log(res.color);
            if (res.msg !== undefined && res.msg !== '') {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(res.msg);
            }
            if (res.color !== undefined && res.color !== '') {
              $active.css('background-color', res.color);
            }
          }
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(r);
        }
      }
    });
  });
  $doc.on('click', '.next-post-link', function (e) {
    e.preventDefault();
    var $button = $(this);
    var href = $button.attr('href');
    appendContainer(href, $button);
  });
  $doc.on('submit', '.filter-project-form', function (e) {
    e.preventDefault();
    var $form = $(this);
    var url = $form.attr('action');
    var serialize = $form.serialize();
    renderContainer(url + '?' + serialize);
  });
  $doc.on('click', '.save-preset', function (e) {
    e.preventDefault();
    var $t = $(this);
    var $form = $t.closest('form');
    if ((0,_forms__WEBPACK_IMPORTED_MODULE_5__.isValidForm)($form)) {
      var this_form = $form.attr('id');
      var thisForm = document.getElementById(this_form);
      var formData = new FormData(thisForm);
      formData.append('type', 'preset');
      (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
      $.ajax({
        type: $form.attr('method'),
        url: adminAjax,
        processData: false,
        contentType: false,
        data: formData
      }).done(function (r) {
        if (r) {
          if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isJsonString)(r)) {
            var res = JSON.parse(r);
            if (res.presets_select_html !== undefined && res.presets_select_html !== '') {
              $doc.find('.presets-wrapper').html(res.presets_select_html);
              (0,_js__WEBPACK_IMPORTED_MODULE_3__.initPlugins)();
            }
          } else {
            (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(r);
          }
        }
        (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
        var invite = new _Invite__WEBPACK_IMPORTED_MODULE_4__["default"]();
      });
    }
  });
  $doc.on('change', '.presets-select', function (e) {
    var $t = $(this);
    var val = $t.val();
    var $form = $doc.find('.create-form');
    $form.trigger('reset');
    $form.find('.autocomplete-value').val('');
    (0,_quill_init__WEBPACK_IMPORTED_MODULE_6__.setProjectQuillText)('Опис');
    var $select = $form.find('select.selectric');
    $select.each(function () {
      $(this).prop('selectedIndex', 0).selectric('refresh');
    });
    if (val === undefined || val === "") return;
    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
    $.ajax({
      type: "POST",
      url: adminAjax,
      data: {
        action: 'get_preset_data',
        id: val
      }
    }).done(function (r) {
      if (r) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isJsonString)(r)) {
          var res = JSON.parse(r);
          if (res) {
            if (res.title !== undefined) $form.find('input[name="title"]').val(res.title);
            if (res.text !== undefined) {
              var html = res.text;
              var $html = $('<div>').html(html);
              $html.find('.invite').removeAttr('data-user-id');
              $html.find('.invite__image').remove();
              html = $html.html();
              html = html.replaceAll('<span class="invite">', '@[');
              html = html.replaceAll('</span>', ']@');
              $doc.find('#project-editor').html(html);
              $doc.find('.ql-toolbar').remove();
              $doc.find('#project-editor').removeClass('ql-container').removeClass('ql-snow');
              $form.find('#project-editor').html(html);
              $form.find('.value-field').val(html);
              (0,_quill_init__WEBPACK_IMPORTED_MODULE_6__.initProjectQuill)();
            }
            if (res.parent_id !== undefined) {
              $form.find('.autocomplete-value').val(res.parent_id);
              $form.find('.autocomplete-input').val(res.parent_title);
            }
            if (res.observers !== undefined) {
              var _$select = $form.find('select[name="observers[]"]');
              if (_$select.length > 0) {
                _$select.find('option').removeAttr('selected');
                res.observers.forEach(function (item) {
                  _$select.find("option[value=\"".concat(item, "\"]")).attr('selected', 'selected');
                });
                _$select.selectric('refresh');
              }
            }
            if (res.performers !== undefined) {
              var _$select2 = $form.find('select[name="responsible[]"]');
              if (_$select2.length > 0) {
                _$select2.find('option').removeAttr('selected');
                res.performers.forEach(function (item) {
                  _$select2.find("option[value=\"".concat(item, "\"]")).attr('selected', 'selected');
                });
                _$select2.selectric('refresh');
              }
            }
            if (res.tags !== undefined) {
              var _$select3 = $form.find('select[name="tags[]"]');
              if (_$select3.length > 0) {
                _$select3.find('option').removeAttr('selected');
                res.tags.forEach(function (item) {
                  _$select3.find("option[value=\"".concat(item, "\"]")).attr('selected', 'selected');
                });
                _$select3.selectric('refresh');
              }
            }
            if (res.status !== undefined) {
              var _$select4 = $form.find('select[name="post_status"]');
              if (_$select4.length > 0) {
                _$select4.find('option').removeAttr('selected');
                _$select4.find("option[value=\"".concat(res.status, "\"]")).attr('selected', 'selected');
                _$select4.selectric('refresh');
              }
            }
          }
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(r);
        }
      }
      (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
    });
  });
  $doc.on('click', '.deleting-project', function (e) {
    e.preventDefault();
    var $t = $(this);
    var $wrapper = $t.closest('.project-item');
    var id = $t.attr('data-id');
    if (id === undefined) return;
    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
    $.ajax({
      type: "POST",
      url: adminAjax,
      data: {
        action: 'remove_project',
        id: id
      }
    }).done(function (r) {
      (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
      if (r) {
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isJsonString)(r)) {
          var res = JSON.parse(r);
          if (res) {
            if (res.msg !== undefined && res.msg !== '') {
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(res.msg);
            }
            if (res.deleted !== undefined) {
              $doc.find('.project-item[data-id="' + res.deleted + '"]').remove();
              (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.closeWindow)($doc.find('.deleting-window'));
            }
          }
        } else {
          (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showMassage)(r);
        }
      }
    });
  });
});
function appendContainer(href) {
  var $button = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var $container = $doc.find('.container-js');
  var $pagination = $doc.find('.pagination-js');
  if ($button) {
    var $section = $button.closest('section');
    $container = $section.find('.container-js');
    $pagination = $section.find('.pagination-js');
  }
  if (href === undefined) return;
  if (loading) return;
  loading = true;
  (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
  var hrefHasType = href.indexOf('next_project_page');
  var param = {
    type: 'GET',
    url: href
  };
  if (hrefHasType === -1) {
    param.data = {
      type: 'next_project_page'
    };
  }
  $.ajax(param).done(function (r) {
    loading = false;
    if (r) {
      var $requestBody = $(parser.parseFromString(r, "text/html"));
      $container.append($requestBody.find('.container-js').html());
      $pagination.html($requestBody.find('.pagination-js').html());
      (0,_js__WEBPACK_IMPORTED_MODULE_3__.initPlugins)();
    } else {
      $pagination.html('');
    }
    var commentObserver = new _CommentObserver__WEBPACK_IMPORTED_MODULE_2__["default"]();
    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
  }).fail(function (jqXHR, textStatus, errorThrown) {
    appendContainer(href, $button);
  });
}
function renderContainer(url) {
  var $container = $doc.find('.container-js');
  var $pagination = $doc.find('.pagination-js');
  var $postsCounter = $doc.find('.found-posts');
  if (url === undefined) return;
  if (loading) return;
  loading = true;
  (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.showPreloader)();
  var param = {
    type: 'GET',
    url: url
  };
  $.ajax(param).done(function (r) {
    loading = false;
    if (r) {
      var $requestBody = $(parser.parseFromString(r, "text/html"));
      $container.html($requestBody.find('.container-js').html());
      $pagination.html($requestBody.find('.pagination-js').html());
      $postsCounter.html($requestBody.find('.found-posts').html());
      (0,_js__WEBPACK_IMPORTED_MODULE_3__.initPlugins)();
    } else {
      $pagination.html('');
    }
    var commentObserver = new _CommentObserver__WEBPACK_IMPORTED_MODULE_2__["default"]();
    (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.hidePreloader)();
  }).fail(function (jqXHR, textStatus, errorThrown) {
    renderContainer(url);
  });
}

/***/ }),

/***/ "./resources/js/_quill-init.js":
/*!*************************************!*\
  !*** ./resources/js/_quill-init.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ initQuill),
/* harmony export */   initProjectQuill: () => (/* binding */ initProjectQuill),
/* harmony export */   setProjectQuillText: () => (/* binding */ setProjectQuillText),
/* harmony export */   setQiullText: () => (/* binding */ setQiullText)
/* harmony export */ });
/* harmony import */ var _quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_quill */ "./resources/js/_quill.js");
/* harmony import */ var _quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_quill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var selectric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! selectric */ "./node_modules/selectric/public/jquery.selectric.js");
/* harmony import */ var selectric__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(selectric__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_helpers */ "./resources/js/_helpers.js");
/* provided dependency */ var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");



var doc = document;
var $doc = $(doc);
var load = false;
var loading = false;
var quill = null;
var quillProject = null;
$(document).ready(function () {
  $doc.mouseup(function (e) {
    var div = $(".text-editor-list");
    if (!div.is(e.target) && div.has(e.target).length === 0) {
      div.closest('form').removeClass('open-users-select');
    }
  });
  $doc.on('change', '.select-user-quill-js', function (e) {
    var $t = $(this);
    var val = $t.val();
    var name = $t.find('option:selected').text().trim();
    $doc.find('.open-users-select').removeClass('open-users-select');
    if ($t.closest('form').hasClass('create-form')) {
      var currentIndex = quillProject.getSelection().index;
      quillProject.insertText(currentIndex, '[' + name + ']@');
    } else {
      var _currentIndex = quill.getSelection().index;
      quill.insertText(_currentIndex, '[' + name + ']@');
    }
    $t.prop('selectedIndex', 0).selectric('refresh');
  });
  $doc.on('keypress', '#editor, #project-editor', function (e) {
    var currentTarget = e.currentTarget;
    var $currentTarget = $(currentTarget);
    var $form = $currentTarget.closest('form');
    if (e.key === '@') {
      $form.addClass('open-users-select');
      $form.find('.select-user-quill-js').selectric('open');
    }
  });
  $doc.on('keydown', '#editor, #project-editor', function (event) {
    if (event.ctrlKey && event.key === 'Enter') {
      $(this).closest('form').trigger('submit');
    }
  });
  $doc.on('click', '.comment-change-js', function (e) {
    e.preventDefault();
    var $this = $(this);
    var id = $this.attr('data-id');
    var $wrapper = $this.closest('.comment');
    var $text = $wrapper.find('.comment-content');
    var html = $text.html();
    var $html = $('<div>').html(html);
    $html.find('.invite').removeAttr('data-user-id');
    $html.find('.invite__image').remove();
    html = $html.html();
    html = html.replaceAll('<span class="invite">', '@[');
    html = html.replaceAll('</span>', ']@');
    $doc.find('#editor').html(html);
    $doc.find('.ql-toolbar').remove();
    $doc.find('#editor').removeClass('ql-container').removeClass('ql-snow');
    $doc.find('.comment-field-id').val(id);
    $doc.find('.value-field').val(html);
    initQuill(false);
    $(document).find('.parent-comment-id').val(0);
    if ($this.closest('.window-main').length > 0) {
      $('.window-main').animate({
        scrollTop: $doc.find('#editor').offset().top - ($doc.find('.header').outerHeight() + 50)
      }, 400);
    } else {
      $('html,body').animate({
        scrollTop: $doc.find('#editor').offset().top - ($doc.find('.header').outerHeight() + 50)
      }, 400);
    }
  });
  $doc.on('click', '.comment-answer__link', function (e) {
    e.preventDefault();
    (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.hidePreloader)();
    var $t = $(this);
    var url = $t.attr('href');
    var text = $t.attr('data-text');
    var commentID = $t.attr('data-comment-id');
    var user = $t.attr('data-user');
    if (commentID === undefined) {
      (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.showMassage)('Помилка спробуйти ще раз після перезавантаження сторінки!');
    }
    if ($(document).find(url).length > 0) {
      if ($t.closest('.window-main').length === 0) {
        $('html, body').animate({
          scrollTop: $(document).find(url).offset().top
        });
      } else {
        $t.closest('.window-main').animate({
          scrollTop: 0
        });
      }
    }
    $(document).find('.comment-form-title').slideDown();
    $(document).find('.comment-form-title__text').text(text);
    $(document).find('.parent-comment-id').val(commentID);
    $doc.find('.comment-field-id').val(0);
    if (user !== undefined && user !== '') {
      var $editor = $doc.find('#editor');
      var projectID = $editor.attr('data-project-id');
      var html = $editor.html().trim();
      html = '@[' + user + ']@ ' + html;
      $doc.find('#editor').html(html);
      $doc.find('.ql-toolbar').remove();
      $doc.find('#editor').removeClass('ql-container').removeClass('ql-snow');
      initQuill(false);
      var val = quill.getSemanticHTML();
      $doc.find('.value-field').val(val);
    }
  });
  initQuill();
  initProjectQuill();
});
function setQiullText() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  if (quill !== null) quill.setText(text);
}
function setProjectQuillText() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  if (quillProject !== null) quillProject.setText(text);
}
function initProjectQuill() {
  var $editor = $doc.find('#project-editor');
  if ($editor.length === 0) return;
  var projectID = $editor.attr('data-project-id');
  if (projectID !== undefined) {
    var text = localStorage.getItem('comment-for-project-' + projectID);
    if (text !== null) {
      if (text.trim().length !== 0) {
        $editor.closest('form').find('.value-field').val(text);
        $editor.html(text);
      }
    }
  }
  quillProject = new (_quill__WEBPACK_IMPORTED_MODULE_0___default())('#project-editor', {
    theme: 'snow'
  });
  quillProject.on('text-change', function (delta, oldDelta, source) {
    var val = quillProject.getSemanticHTML();
    $editor.closest('form').find('.value-field').val(val);
    if ($editor.attr('data-project-id') !== undefined) {
      if (val && val !== '<p></p>') {
        localStorage.setItem('comment-for-project-' + $editor.attr('data-project-id'), val);
      } else {
        localStorage.removeItem('comment-for-project-' + $editor.attr('data-project-id'));
      }
    }
  });
}
function initQuill() {
  var checkHTML = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  if (quill !== null) quill = null;
  var $editor = $doc.find('#editor');
  if ($editor.length === 0) return;
  if ($editor.html().trim().length === 0) {
    var projectID = $editor.attr('data-project-id');
    if (projectID !== undefined) {
      var text = localStorage.getItem('comment-for-project-' + projectID);
      if (text !== null) {
        if (text.trim().length !== 0) {
          $editor.closest('form').find('.value-field').val(text);
          $editor.html(text);
        }
      }
    }
  }
  if (checkHTML) {
    $editor.find('span.invite').each(function () {
      var text = $(this).text();
      $(this).replaceWith('@[' + text + ']@');
    });
    var html = $editor.html().trim();
    if (html.length > 0) {
      $editor.html(html);
      $editor.closest('form').find('.value-field').val(html);
    }
  }
  quill = new (_quill__WEBPACK_IMPORTED_MODULE_0___default())('#editor', {
    theme: 'snow'
  });
  quill.on('text-change', function (delta, oldDelta, source) {
    var val = quill.getSemanticHTML();
    $editor.closest('form').find('.value-field').val(val);
    if ($editor.attr('data-project-id') !== undefined) {
      if (val && val !== '<p></p>') {
        localStorage.setItem('comment-for-project-' + $editor.attr('data-project-id'), val);
      } else {
        localStorage.removeItem('comment-for-project-' + $editor.attr('data-project-id'));
      }
    }
  });
}

/***/ }),

/***/ "./resources/js/_quill.js":
/*!********************************!*\
  !*** ./resources/js/_quill.js ***!
  \********************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _excluded = ["modules"],
  _excluded2 = ["modules"];
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/*! For license information please see quill.js.LICENSE.txt */
!function (t, e) {
  "object" == ( false ? 0 : _typeof(exports)) && "object" == ( false ? 0 : _typeof(module)) ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
}(self, function () {
  return function () {
    var t = {
        9698: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Ay: function Ay() {
              return c;
            },
            Ji: function Ji() {
              return d;
            },
            mG: function mG() {
              return h;
            },
            zo: function zo() {
              return u;
            }
          });
          var r = n(6003),
            i = n(5232),
            s = n.n(i),
            o = n(3036),
            l = n(4850),
            a = n(5508);
          var c = /*#__PURE__*/function (_r$BlockBlot) {
            function c() {
              var _this;
              _classCallCheck(this, c);
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              _this = _callSuper(this, c, [].concat(args));
              _defineProperty(_this, "cache", {});
              return _this;
            }
            _inherits(c, _r$BlockBlot);
            return _createClass(c, [{
              key: "delta",
              value: function delta() {
                return null == this.cache.delta && (this.cache.delta = h(this)), this.cache.delta;
              }
            }, {
              key: "deleteAt",
              value: function deleteAt(t, e) {
                _superPropGet(c, "deleteAt", this, 3)([t, e]), this.cache = {};
              }
            }, {
              key: "formatAt",
              value: function formatAt(t, e, n, i) {
                e <= 0 || (this.scroll.query(n, r.Scope.BLOCK) ? t + e === this.length() && this.format(n, i) : _superPropGet(c, "formatAt", this, 3)([t, Math.min(e, this.length() - t - 1), n, i]), this.cache = {});
              }
            }, {
              key: "insertAt",
              value: function insertAt(t, e, n) {
                if (null != n) return _superPropGet(c, "insertAt", this, 3)([t, e, n]), void (this.cache = {});
                if (0 === e.length) return;
                var r = e.split("\n"),
                  i = r.shift();
                i.length > 0 && (t < this.length() - 1 || null == this.children.tail ? _superPropGet(c, "insertAt", this, 3)([Math.min(t, this.length() - 1), i]) : this.children.tail.insertAt(this.children.tail.length(), i), this.cache = {});
                var s = this;
                r.reduce(function (t, e) {
                  return s = s.split(t, !0), s.insertAt(0, e), e.length;
                }, t + i.length);
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(t, e) {
                var n = this.children.head;
                _superPropGet(c, "insertBefore", this, 3)([t, e]), n instanceof o.A && n.remove(), this.cache = {};
              }
            }, {
              key: "length",
              value: function length() {
                return null == this.cache.length && (this.cache.length = _superPropGet(c, "length", this, 3)([]) + 1), this.cache.length;
              }
            }, {
              key: "moveChildren",
              value: function moveChildren(t, e) {
                _superPropGet(c, "moveChildren", this, 3)([t, e]), this.cache = {};
              }
            }, {
              key: "optimize",
              value: function optimize(t) {
                _superPropGet(c, "optimize", this, 3)([t]), this.cache = {};
              }
            }, {
              key: "path",
              value: function path(t) {
                return _superPropGet(c, "path", this, 3)([t, !0]);
              }
            }, {
              key: "removeChild",
              value: function removeChild(t) {
                _superPropGet(c, "removeChild", this, 3)([t]), this.cache = {};
              }
            }, {
              key: "split",
              value: function split(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (e && (0 === t || t >= this.length() - 1)) {
                  var _e = this.clone();
                  return 0 === t ? (this.parent.insertBefore(_e, this), this) : (this.parent.insertBefore(_e, this.next), _e);
                }
                var n = _superPropGet(c, "split", this, 3)([t, e]);
                return this.cache = {}, n;
              }
            }]);
          }(r.BlockBlot);
          c.blotName = "block", c.tagName = "P", c.defaultChild = o.A, c.allowedChildren = [o.A, l.A, r.EmbedBlot, a.A];
          var u = /*#__PURE__*/function (_r$EmbedBlot) {
            function u() {
              _classCallCheck(this, u);
              return _callSuper(this, u, arguments);
            }
            _inherits(u, _r$EmbedBlot);
            return _createClass(u, [{
              key: "attach",
              value: function attach() {
                _superPropGet(u, "attach", this, 3)([]), this.attributes = new r.AttributorStore(this.domNode);
              }
            }, {
              key: "delta",
              value: function delta() {
                return new (s())().insert(this.value(), _objectSpread(_objectSpread({}, this.formats()), this.attributes.values()));
              }
            }, {
              key: "format",
              value: function format(t, e) {
                var n = this.scroll.query(t, r.Scope.BLOCK_ATTRIBUTE);
                null != n && this.attributes.attribute(n, e);
              }
            }, {
              key: "formatAt",
              value: function formatAt(t, e, n, r) {
                this.format(n, r);
              }
            }, {
              key: "insertAt",
              value: function insertAt(t, e, n) {
                var _this2 = this;
                if (null != n) return void _superPropGet(u, "insertAt", this, 3)([t, e, n]);
                var r = e.split("\n"),
                  i = r.pop(),
                  s = r.map(function (t) {
                    var e = _this2.scroll.create(c.blotName);
                    return e.insertAt(0, t), e;
                  }),
                  o = this.split(t);
                s.forEach(function (t) {
                  _this2.parent.insertBefore(t, o);
                }), i && this.parent.insertBefore(this.scroll.create("text", i), o);
              }
            }]);
          }(r.EmbedBlot);
          function h(t) {
            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return t.descendants(r.LeafBlot).reduce(function (t, n) {
              return 0 === n.length() ? t : t.insert(n.value(), d(n, {}, e));
            }, new (s())()).insert("\n", d(t));
          }
          function d(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
              n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            return null == t ? e : ("formats" in t && "function" == typeof t.formats && (e = _objectSpread(_objectSpread({}, e), t.formats()), n && delete e["code-token"]), null == t.parent || "scroll" === t.parent.statics.blotName || t.parent.statics.scope !== t.statics.scope ? e : d(t.parent, e, n));
          }
          u.scope = r.Scope.BLOCK_BLOT;
        },
        3036: function _(t, e, n) {
          "use strict";

          var r = n(6003);
          var i = /*#__PURE__*/function (_r$EmbedBlot2) {
            function i() {
              _classCallCheck(this, i);
              return _callSuper(this, i, arguments);
            }
            _inherits(i, _r$EmbedBlot2);
            return _createClass(i, [{
              key: "optimize",
              value: function optimize() {
                (this.prev || this.next) && this.remove();
              }
            }, {
              key: "length",
              value: function length() {
                return 0;
              }
            }, {
              key: "value",
              value: function value() {
                return "";
              }
            }], [{
              key: "value",
              value: function value() {}
            }]);
          }(r.EmbedBlot);
          i.blotName = "break", i.tagName = "BR", e.A = i;
        },
        580: function _(t, e, n) {
          "use strict";

          var r = n(6003);
          var i = /*#__PURE__*/function (_r$ContainerBlot) {
            function i() {
              _classCallCheck(this, i);
              return _callSuper(this, i, arguments);
            }
            _inherits(i, _r$ContainerBlot);
            return _createClass(i);
          }(r.ContainerBlot);
          e.A = i;
        },
        4541: function _(t, e, n) {
          "use strict";

          var r = n(6003),
            i = n(5508);
          var s = /*#__PURE__*/function (_r$EmbedBlot3) {
            function s(t, e, n) {
              var _this3;
              _classCallCheck(this, s);
              _this3 = _callSuper(this, s, [t, e]), _this3.selection = n, _this3.textNode = document.createTextNode(s.CONTENTS), _this3.domNode.appendChild(_this3.textNode), _this3.savedLength = 0;
              return _this3;
            }
            _inherits(s, _r$EmbedBlot3);
            return _createClass(s, [{
              key: "detach",
              value: function detach() {
                null != this.parent && this.parent.removeChild(this);
              }
            }, {
              key: "format",
              value: function format(t, e) {
                if (0 !== this.savedLength) return void _superPropGet(s, "format", this, 3)([t, e]);
                var n = this,
                  i = 0;
                for (; null != n && n.statics.scope !== r.Scope.BLOCK_BLOT;) i += n.offset(n.parent), n = n.parent;
                null != n && (this.savedLength = s.CONTENTS.length, n.optimize(), n.formatAt(i, s.CONTENTS.length, t, e), this.savedLength = 0);
              }
            }, {
              key: "index",
              value: function index(t, e) {
                return t === this.textNode ? 0 : _superPropGet(s, "index", this, 3)([t, e]);
              }
            }, {
              key: "length",
              value: function length() {
                return this.savedLength;
              }
            }, {
              key: "position",
              value: function position() {
                return [this.textNode, this.textNode.data.length];
              }
            }, {
              key: "remove",
              value: function remove() {
                _superPropGet(s, "remove", this, 3)([]), this.parent = null;
              }
            }, {
              key: "restore",
              value: function restore() {
                if (this.selection.composing || null == this.parent) return null;
                var t = this.selection.getNativeRange();
                for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode;) this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                var e = this.prev instanceof i.A ? this.prev : null,
                  n = e ? e.length() : 0,
                  r = this.next instanceof i.A ? this.next : null,
                  o = r ? r.text : "",
                  l = this.textNode,
                  a = l.data.split(s.CONTENTS).join("");
                var c;
                if (l.data = s.CONTENTS, e) c = e, (a || r) && (e.insertAt(e.length(), a + o), r && r.remove());else if (r) c = r, r.insertAt(0, a);else {
                  var _t2 = document.createTextNode(a);
                  c = this.scroll.create(_t2), this.parent.insertBefore(c, this);
                }
                if (this.remove(), t) {
                  var _i = function _i(t, i) {
                      return e && t === e.domNode ? i : t === l ? n + i - 1 : r && t === r.domNode ? n + a.length + i : null;
                    },
                    _s2 = _i(t.start.node, t.start.offset),
                    _o = _i(t.end.node, t.end.offset);
                  if (null !== _s2 && null !== _o) return {
                    startNode: c.domNode,
                    startOffset: _s2,
                    endNode: c.domNode,
                    endOffset: _o
                  };
                }
                return null;
              }
            }, {
              key: "update",
              value: function update(t, e) {
                var _this4 = this;
                if (t.some(function (t) {
                  return "characterData" === t.type && t.target === _this4.textNode;
                })) {
                  var _t3 = this.restore();
                  _t3 && (e.range = _t3);
                }
              }
            }, {
              key: "optimize",
              value: function optimize(t) {
                _superPropGet(s, "optimize", this, 3)([t]);
                var e = this.parent;
                for (; e;) {
                  if ("A" === e.domNode.tagName) {
                    this.savedLength = s.CONTENTS.length, e.isolate(this.offset(e), this.length()).unwrap(), this.savedLength = 0;
                    break;
                  }
                  e = e.parent;
                }
              }
            }, {
              key: "value",
              value: function value() {
                return "";
              }
            }], [{
              key: "value",
              value: function value() {}
            }]);
          }(r.EmbedBlot);
          _defineProperty(s, "blotName", "cursor");
          _defineProperty(s, "className", "ql-cursor");
          _defineProperty(s, "tagName", "span");
          _defineProperty(s, "CONTENTS", "\uFEFF");
          e.A = s;
        },
        746: function _(t, e, n) {
          "use strict";

          var r = n(6003),
            i = n(5508);
          var s = "\uFEFF";
          var o = /*#__PURE__*/function (_r$EmbedBlot4) {
            function o(t, e) {
              var _this5;
              _classCallCheck(this, o);
              _this5 = _callSuper(this, o, [t, e]), _this5.contentNode = document.createElement("span"), _this5.contentNode.setAttribute("contenteditable", "false"), Array.from(_this5.domNode.childNodes).forEach(function (t) {
                _this5.contentNode.appendChild(t);
              }), _this5.leftGuard = document.createTextNode(s), _this5.rightGuard = document.createTextNode(s), _this5.domNode.appendChild(_this5.leftGuard), _this5.domNode.appendChild(_this5.contentNode), _this5.domNode.appendChild(_this5.rightGuard);
              return _this5;
            }
            _inherits(o, _r$EmbedBlot4);
            return _createClass(o, [{
              key: "index",
              value: function index(t, e) {
                return t === this.leftGuard ? 0 : t === this.rightGuard ? 1 : _superPropGet(o, "index", this, 3)([t, e]);
              }
            }, {
              key: "restore",
              value: function restore(t) {
                var e,
                  n = null;
                var r = t.data.split(s).join("");
                if (t === this.leftGuard) {
                  if (this.prev instanceof i.A) {
                    var _t4 = this.prev.length();
                    this.prev.insertAt(_t4, r), n = {
                      startNode: this.prev.domNode,
                      startOffset: _t4 + r.length
                    };
                  } else e = document.createTextNode(r), this.parent.insertBefore(this.scroll.create(e), this), n = {
                    startNode: e,
                    startOffset: r.length
                  };
                } else t === this.rightGuard && (this.next instanceof i.A ? (this.next.insertAt(0, r), n = {
                  startNode: this.next.domNode,
                  startOffset: r.length
                }) : (e = document.createTextNode(r), this.parent.insertBefore(this.scroll.create(e), this.next), n = {
                  startNode: e,
                  startOffset: r.length
                }));
                return t.data = s, n;
              }
            }, {
              key: "update",
              value: function update(t, e) {
                var _this6 = this;
                t.forEach(function (t) {
                  if ("characterData" === t.type && (t.target === _this6.leftGuard || t.target === _this6.rightGuard)) {
                    var _n = _this6.restore(t.target);
                    _n && (e.range = _n);
                  }
                });
              }
            }]);
          }(r.EmbedBlot);
          e.A = o;
        },
        4850: function _(t, e, n) {
          "use strict";

          var _o2;
          var r = n(6003),
            i = n(3036),
            s = n(5508);
          var o = /*#__PURE__*/function (_r$InlineBlot) {
            function o() {
              _classCallCheck(this, o);
              return _callSuper(this, o, arguments);
            }
            _inherits(o, _r$InlineBlot);
            return _createClass(o, [{
              key: "formatAt",
              value: function formatAt(t, e, n, i) {
                if (o.compare(this.statics.blotName, n) < 0 && this.scroll.query(n, r.Scope.BLOT)) {
                  var _r = this.isolate(t, e);
                  i && _r.wrap(n, i);
                } else _superPropGet(o, "formatAt", this, 3)([t, e, n, i]);
              }
            }, {
              key: "optimize",
              value: function optimize(t) {
                if (_superPropGet(o, "optimize", this, 3)([t]), this.parent instanceof o && o.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                  var _t5 = this.parent.isolate(this.offset(), this.length());
                  this.moveChildren(_t5), _t5.wrap(this);
                }
              }
            }], [{
              key: "compare",
              value: function compare(t, e) {
                var n = o.order.indexOf(t),
                  r = o.order.indexOf(e);
                return n >= 0 || r >= 0 ? n - r : t === e ? 0 : t < e ? -1 : 1;
              }
            }]);
          }(r.InlineBlot);
          _o2 = o;
          _defineProperty(o, "allowedChildren", [_o2, i.A, r.EmbedBlot, s.A]);
          _defineProperty(o, "order", ["cursor", "inline", "link", "underline", "strike", "italic", "bold", "script", "code"]);
          e.A = o;
        },
        5508: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return i;
            },
            X: function X() {
              return s;
            }
          });
          var r = n(6003);
          var i = /*#__PURE__*/function (_r$TextBlot) {
            function i() {
              _classCallCheck(this, i);
              return _callSuper(this, i, arguments);
            }
            _inherits(i, _r$TextBlot);
            return _createClass(i);
          }(r.TextBlot);
          function s(t) {
            return t.replace(/[&<>"']/g, function (t) {
              return {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
              }[t];
            });
          }
        },
        3729: function _(t, e, n) {
          "use strict";

          n.d(e, {
            "default": function _default() {
              return R;
            }
          });
          var r = n(6142),
            i = n(9698),
            s = n(3036),
            o = n(580),
            l = n(4541),
            a = n(746),
            c = n(4850),
            u = n(6003),
            h = n(5232),
            d = n.n(h),
            f = n(5374);
          function p(t) {
            return t instanceof i.Ay || t instanceof i.zo;
          }
          function g(t) {
            return "function" == typeof t.updateContent;
          }
          var m = /*#__PURE__*/function (_u$ScrollBlot) {
            function m(t, e, n) {
              var _this7;
              _classCallCheck(this, m);
              var r = n.emitter;
              _this7 = _callSuper(this, m, [t, e]), _this7.emitter = r, _this7.batch = !1, _this7.optimize(), _this7.enable(), _this7.domNode.addEventListener("dragstart", function (t) {
                return _this7.handleDragStart(t);
              });
              return _this7;
            }
            _inherits(m, _u$ScrollBlot);
            return _createClass(m, [{
              key: "batchStart",
              value: function batchStart() {
                Array.isArray(this.batch) || (this.batch = []);
              }
            }, {
              key: "batchEnd",
              value: function batchEnd() {
                if (!this.batch) return;
                var t = this.batch;
                this.batch = !1, this.update(t);
              }
            }, {
              key: "emitMount",
              value: function emitMount(t) {
                this.emitter.emit(f.A.events.SCROLL_BLOT_MOUNT, t);
              }
            }, {
              key: "emitUnmount",
              value: function emitUnmount(t) {
                this.emitter.emit(f.A.events.SCROLL_BLOT_UNMOUNT, t);
              }
            }, {
              key: "emitEmbedUpdate",
              value: function emitEmbedUpdate(t, e) {
                this.emitter.emit(f.A.events.SCROLL_EMBED_UPDATE, t, e);
              }
            }, {
              key: "deleteAt",
              value: function deleteAt(t, e) {
                var _this$line = this.line(t),
                  _this$line2 = _slicedToArray(_this$line, 2),
                  n = _this$line2[0],
                  r = _this$line2[1],
                  _this$line3 = this.line(t + e),
                  _this$line4 = _slicedToArray(_this$line3, 1),
                  o = _this$line4[0];
                if (_superPropGet(m, "deleteAt", this, 3)([t, e]), null != o && n !== o && r > 0) {
                  if (n instanceof i.zo || o instanceof i.zo) return void this.optimize();
                  var _t6 = o.children.head instanceof s.A ? null : o.children.head;
                  n.moveChildren(o, _t6), n.remove();
                }
                this.optimize();
              }
            }, {
              key: "enable",
              value: function enable() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.domNode.setAttribute("contenteditable", t ? "true" : "false");
              }
            }, {
              key: "formatAt",
              value: function formatAt(t, e, n, r) {
                _superPropGet(m, "formatAt", this, 3)([t, e, n, r]), this.optimize();
              }
            }, {
              key: "insertAt",
              value: function insertAt(t, e, n) {
                if (t >= this.length()) {
                  if (null == n || null == this.scroll.query(e, u.Scope.BLOCK)) {
                    var _t7 = this.scroll.create(this.statics.defaultChild.blotName);
                    this.appendChild(_t7), null == n && e.endsWith("\n") ? _t7.insertAt(0, e.slice(0, -1), n) : _t7.insertAt(0, e, n);
                  } else {
                    var _t8 = this.scroll.create(e, n);
                    this.appendChild(_t8);
                  }
                } else _superPropGet(m, "insertAt", this, 3)([t, e, n]);
                this.optimize();
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(t, e) {
                if (t.statics.scope === u.Scope.INLINE_BLOT) {
                  var _n2 = this.scroll.create(this.statics.defaultChild.blotName);
                  _n2.appendChild(t), _superPropGet(m, "insertBefore", this, 3)([_n2, e]);
                } else _superPropGet(m, "insertBefore", this, 3)([t, e]);
              }
            }, {
              key: "insertContents",
              value: function insertContents(t, e) {
                var _this8 = this;
                var n = this.deltaToRenderBlocks(e.concat(new (d())().insert("\n"))),
                  r = n.pop();
                if (null == r) return;
                this.batchStart();
                var s = n.shift();
                if (s) {
                  var _e2 = "block" === s.type && (0 === s.delta.length() || !this.descendant(i.zo, t)[0] && t < this.length()),
                    _n3 = "block" === s.type ? s.delta : new (d())().insert(_defineProperty({}, s.key, s.value));
                  b(this, t, _n3);
                  var _r2 = "block" === s.type ? 1 : 0,
                    _o3 = t + _n3.length() + _r2;
                  _e2 && this.insertAt(_o3 - 1, "\n");
                  var _l = (0, i.Ji)(this.line(t)[0]),
                    _a = h.AttributeMap.diff(_l, s.attributes) || {};
                  Object.keys(_a).forEach(function (t) {
                    _this8.formatAt(_o3 - 1, 1, t, _a[t]);
                  }), t = _o3;
                }
                var _this$children$find = this.children.find(t),
                  _this$children$find2 = _slicedToArray(_this$children$find, 2),
                  o = _this$children$find2[0],
                  l = _this$children$find2[1];
                n.length && (o && (o = o.split(l), l = 0), n.forEach(function (t) {
                  if ("block" === t.type) b(_this8.createBlock(t.attributes, o || void 0), 0, t.delta);else {
                    var _e3 = _this8.create(t.key, t.value);
                    _this8.insertBefore(_e3, o || void 0), Object.keys(t.attributes).forEach(function (n) {
                      _e3.format(n, t.attributes[n]);
                    });
                  }
                })), "block" === r.type && r.delta.length() && b(this, o ? o.offset(o.scroll) + l : this.length(), r.delta), this.batchEnd(), this.optimize();
              }
            }, {
              key: "isEnabled",
              value: function isEnabled() {
                return "true" === this.domNode.getAttribute("contenteditable");
              }
            }, {
              key: "leaf",
              value: function leaf(t) {
                var e = this.path(t).pop();
                if (!e) return [null, -1];
                var _e4 = _slicedToArray(e, 2),
                  n = _e4[0],
                  r = _e4[1];
                return n instanceof u.LeafBlot ? [n, r] : [null, -1];
              }
            }, {
              key: "line",
              value: function line(t) {
                return t === this.length() ? this.line(t - 1) : this.descendant(p, t);
              }
            }, {
              key: "lines",
              value: function lines() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
                var _n4 = function n(t, e, r) {
                  var i = [],
                    s = r;
                  return t.children.forEachAt(e, r, function (t, e, r) {
                    p(t) ? i.push(t) : t instanceof u.ContainerBlot && (i = i.concat(_n4(t, e, s))), s -= r;
                  }), i;
                };
                return _n4(this, t, e);
              }
            }, {
              key: "optimize",
              value: function optimize() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.batch || (_superPropGet(m, "optimize", this, 3)([t, e]), t.length > 0 && this.emitter.emit(f.A.events.SCROLL_OPTIMIZE, t, e));
              }
            }, {
              key: "path",
              value: function path(t) {
                return _superPropGet(m, "path", this, 3)([t]).slice(1);
              }
            }, {
              key: "remove",
              value: function remove() {}
            }, {
              key: "update",
              value: function update(t) {
                var _this9 = this;
                if (this.batch) return void (Array.isArray(t) && (this.batch = this.batch.concat(t)));
                var e = f.A.sources.USER;
                "string" == typeof t && (e = t), Array.isArray(t) || (t = this.observer.takeRecords()), (t = t.filter(function (t) {
                  var e = t.target;
                  var n = _this9.find(e, !0);
                  return n && !g(n);
                })).length > 0 && this.emitter.emit(f.A.events.SCROLL_BEFORE_UPDATE, e, t), _superPropGet(m, "update", this, 3)([t.concat([])]), t.length > 0 && this.emitter.emit(f.A.events.SCROLL_UPDATE, e, t);
              }
            }, {
              key: "updateEmbedAt",
              value: function updateEmbedAt(t, e, n) {
                var _this$descendant = this.descendant(function (t) {
                    return t instanceof i.zo;
                  }, t),
                  _this$descendant2 = _slicedToArray(_this$descendant, 1),
                  r = _this$descendant2[0];
                r && r.statics.blotName === e && g(r) && r.updateContent(n);
              }
            }, {
              key: "handleDragStart",
              value: function handleDragStart(t) {
                t.preventDefault();
              }
            }, {
              key: "deltaToRenderBlocks",
              value: function deltaToRenderBlocks(t) {
                var _this0 = this;
                var e = [];
                var n = new (d())();
                return t.forEach(function (t) {
                  var r = t === null || t === void 0 ? void 0 : t.insert;
                  if (r) if ("string" == typeof r) {
                    var _i2 = r.split("\n");
                    _i2.slice(0, -1).forEach(function (r) {
                      var _t$attributes;
                      n.insert(r, t.attributes), e.push({
                        type: "block",
                        delta: n,
                        attributes: (_t$attributes = t.attributes) !== null && _t$attributes !== void 0 ? _t$attributes : {}
                      }), n = new (d())();
                    });
                    var _s3 = _i2[_i2.length - 1];
                    _s3 && n.insert(_s3, t.attributes);
                  } else {
                    var _t$attributes2;
                    var _i3 = Object.keys(r)[0];
                    if (!_i3) return;
                    _this0.query(_i3, u.Scope.INLINE) ? n.push(t) : (n.length() && e.push({
                      type: "block",
                      delta: n,
                      attributes: {}
                    }), n = new (d())(), e.push({
                      type: "blockEmbed",
                      key: _i3,
                      value: r[_i3],
                      attributes: (_t$attributes2 = t.attributes) !== null && _t$attributes2 !== void 0 ? _t$attributes2 : {}
                    }));
                  }
                }), n.length() && e.push({
                  type: "block",
                  delta: n,
                  attributes: {}
                }), e;
              }
            }, {
              key: "createBlock",
              value: function createBlock(t, e) {
                var _this1 = this;
                var n;
                var r = {};
                Object.entries(t).forEach(function (t) {
                  var _t9 = _slicedToArray(t, 2),
                    e = _t9[0],
                    i = _t9[1];
                  null != _this1.query(e, u.Scope.BLOCK & u.Scope.BLOT) ? n = e : r[e] = i;
                });
                var i = this.create(n || this.statics.defaultChild.blotName, n ? t[n] : void 0);
                this.insertBefore(i, e || void 0);
                var s = i.length();
                return Object.entries(r).forEach(function (t) {
                  var _t0 = _slicedToArray(t, 2),
                    e = _t0[0],
                    n = _t0[1];
                  i.formatAt(0, s, e, n);
                }), i;
              }
            }]);
          }(u.ScrollBlot);
          _defineProperty(m, "blotName", "scroll");
          _defineProperty(m, "className", "ql-editor");
          _defineProperty(m, "tagName", "DIV");
          _defineProperty(m, "defaultChild", i.Ay);
          _defineProperty(m, "allowedChildren", [i.Ay, i.zo, o.A]);
          function b(t, e, n) {
            n.reduce(function (e, n) {
              var r = h.Op.length(n);
              var s = n.attributes || {};
              if (null != n.insert) if ("string" == typeof n.insert) {
                var _r3 = n.insert;
                t.insertAt(e, _r3);
                var _t$descendant = t.descendant(u.LeafBlot, e),
                  _t$descendant2 = _slicedToArray(_t$descendant, 1),
                  _o4 = _t$descendant2[0],
                  _l2 = (0, i.Ji)(_o4);
                s = h.AttributeMap.diff(_l2, s) || {};
              } else if ("object" == _typeof(n.insert)) {
                var _r4 = Object.keys(n.insert)[0];
                if (null == _r4) return e;
                if (t.insertAt(e, _r4, n.insert[_r4]), null != t.scroll.query(_r4, u.Scope.INLINE)) {
                  var _t$descendant3 = t.descendant(u.LeafBlot, e),
                    _t$descendant4 = _slicedToArray(_t$descendant3, 1),
                    _n5 = _t$descendant4[0],
                    _r5 = (0, i.Ji)(_n5);
                  s = h.AttributeMap.diff(_r5, s) || {};
                }
              }
              return Object.keys(s).forEach(function (n) {
                t.formatAt(e, r, n, s[n]);
              }), e + r;
            }, e);
          }
          var y = m,
            v = n(5508),
            A = n(584),
            x = n(4266);
          var N = /*#__PURE__*/function (_x$A) {
            function N(t, e) {
              var _this10;
              _classCallCheck(this, N);
              _this10 = _callSuper(this, N, [t, e]), _defineProperty(_assertThisInitialized(_this10), "lastRecorded", 0), _defineProperty(_assertThisInitialized(_this10), "ignoreChange", !1), _defineProperty(_assertThisInitialized(_this10), "stack", {
                undo: [],
                redo: []
              }), _defineProperty(_assertThisInitialized(_this10), "currentRange", null), _this10.quill.on(r.Ay.events.EDITOR_CHANGE, function (t, e, n, i) {
                t === r.Ay.events.SELECTION_CHANGE ? e && i !== r.Ay.sources.SILENT && (_this10.currentRange = e) : t === r.Ay.events.TEXT_CHANGE && (_this10.ignoreChange || (_this10.options.userOnly && i !== r.Ay.sources.USER ? _this10.transform(e) : _this10.record(e, n)), _this10.currentRange = w(_this10.currentRange, e));
              }), _this10.quill.keyboard.addBinding({
                key: "z",
                shortKey: !0
              }, _this10.undo.bind(_assertThisInitialized(_this10))), _this10.quill.keyboard.addBinding({
                key: ["z", "Z"],
                shortKey: !0,
                shiftKey: !0
              }, _this10.redo.bind(_assertThisInitialized(_this10))), /Win/i.test(navigator.platform) && _this10.quill.keyboard.addBinding({
                key: "y",
                shortKey: !0
              }, _this10.redo.bind(_assertThisInitialized(_this10))), _this10.quill.root.addEventListener("beforeinput", function (t) {
                "historyUndo" === t.inputType ? (_this10.undo(), t.preventDefault()) : "historyRedo" === t.inputType && (_this10.redo(), t.preventDefault());
              });
              return _this10;
            }
            _inherits(N, _x$A);
            return _createClass(N, [{
              key: "change",
              value: function change(t, e) {
                if (0 === this.stack[t].length) return;
                var n = this.stack[t].pop();
                if (!n) return;
                var i = this.quill.getContents(),
                  s = n.delta.invert(i);
                this.stack[e].push({
                  delta: s,
                  range: w(n.range, s)
                }), this.lastRecorded = 0, this.ignoreChange = !0, this.quill.updateContents(n.delta, r.Ay.sources.USER), this.ignoreChange = !1, this.restoreSelection(n);
              }
            }, {
              key: "clear",
              value: function clear() {
                this.stack = {
                  undo: [],
                  redo: []
                };
              }
            }, {
              key: "cutoff",
              value: function cutoff() {
                this.lastRecorded = 0;
              }
            }, {
              key: "record",
              value: function record(t, e) {
                if (0 === t.ops.length) return;
                this.stack.redo = [];
                var n = t.invert(e),
                  r = this.currentRange;
                var i = Date.now();
                if (this.lastRecorded + this.options.delay > i && this.stack.undo.length > 0) {
                  var _t1 = this.stack.undo.pop();
                  _t1 && (n = n.compose(_t1.delta), r = _t1.range);
                } else this.lastRecorded = i;
                0 !== n.length() && (this.stack.undo.push({
                  delta: n,
                  range: r
                }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift());
              }
            }, {
              key: "redo",
              value: function redo() {
                this.change("redo", "undo");
              }
            }, {
              key: "transform",
              value: function transform(t) {
                E(this.stack.undo, t), E(this.stack.redo, t);
              }
            }, {
              key: "undo",
              value: function undo() {
                this.change("undo", "redo");
              }
            }, {
              key: "restoreSelection",
              value: function restoreSelection(t) {
                if (t.range) this.quill.setSelection(t.range, r.Ay.sources.USER);else {
                  var _e5 = function (t, e) {
                    var n = e.reduce(function (t, e) {
                      return t + (e["delete"] || 0);
                    }, 0);
                    var r = e.length() - n;
                    return function (t, e) {
                      var n = e.ops[e.ops.length - 1];
                      return null != n && (null != n.insert ? "string" == typeof n.insert && n.insert.endsWith("\n") : null != n.attributes && Object.keys(n.attributes).some(function (e) {
                        return null != t.query(e, u.Scope.BLOCK);
                      }));
                    }(t, e) && (r -= 1), r;
                  }(this.quill.scroll, t.delta);
                  this.quill.setSelection(_e5, r.Ay.sources.USER);
                }
              }
            }]);
          }(x.A);
          _defineProperty(N, "DEFAULTS", {
            delay: 1e3,
            maxStack: 100,
            userOnly: !1
          });
          function E(t, e) {
            var n = e;
            for (var _e6 = t.length - 1; _e6 >= 0; _e6 -= 1) {
              var _r6 = t[_e6];
              t[_e6] = {
                delta: n.transform(_r6.delta, !0),
                range: _r6.range && w(_r6.range, n)
              }, n = _r6.delta.transform(n), 0 === t[_e6].delta.length() && t.splice(_e6, 1);
            }
          }
          function w(t, e) {
            if (!t) return t;
            var n = e.transformPosition(t.index);
            return {
              index: n,
              length: e.transformPosition(t.index + t.length) - n
            };
          }
          var q = n(8123);
          var k = /*#__PURE__*/function (_x$A2) {
            function k(t, e) {
              var _this11;
              _classCallCheck(this, k);
              _this11 = _callSuper(this, k, [t, e]), t.root.addEventListener("drop", function (e) {
                e.preventDefault();
                var n = null;
                if (document.caretRangeFromPoint) n = document.caretRangeFromPoint(e.clientX, e.clientY);else if (document.caretPositionFromPoint) {
                  var _t10 = document.caretPositionFromPoint(e.clientX, e.clientY);
                  n = document.createRange(), n.setStart(_t10.offsetNode, _t10.offset), n.setEnd(_t10.offsetNode, _t10.offset);
                }
                var r = n && t.selection.normalizeNative(n);
                if (r) {
                  var _e$dataTransfer;
                  var _n6 = t.selection.normalizedToRange(r);
                  ((_e$dataTransfer = e.dataTransfer) === null || _e$dataTransfer === void 0 ? void 0 : _e$dataTransfer.files) && _this11.upload(_n6, e.dataTransfer.files);
                }
              });
              return _this11;
            }
            _inherits(k, _x$A2);
            return _createClass(k, [{
              key: "upload",
              value: function upload(t, e) {
                var _this12 = this;
                var n = [];
                Array.from(e).forEach(function (t) {
                  var _this12$options$mimet;
                  t && ((_this12$options$mimet = _this12.options.mimetypes) === null || _this12$options$mimet === void 0 ? void 0 : _this12$options$mimet.includes(t.type)) && n.push(t);
                }), n.length > 0 && this.options.handler.call(this, t, n);
              }
            }]);
          }(x.A);
          k.DEFAULTS = {
            mimetypes: ["image/png", "image/jpeg"],
            handler: function handler(t, e) {
              var _this13 = this;
              var n = e.map(function (t) {
                return new Promise(function (e) {
                  var n = new FileReader();
                  n.onload = function (t) {
                    e(t.target.result);
                  }, n.readAsDataURL(t);
                });
              });
              Promise.all(n).then(function (e) {
                var n = e.reduce(function (t, e) {
                  return t.insert({
                    image: e
                  });
                }, new (d())().retain(t.index)["delete"](t.length));
                _this13.quill.updateContents(n, f.A.sources.USER), _this13.quill.setSelection(t.index + e.length, f.A.sources.SILENT);
              });
            }
          };
          var _ = k;
          var L = ["insertText", "insertReplacementText"];
          var S = /*#__PURE__*/function (_x$A3) {
            function S(t, e) {
              var _this14;
              _classCallCheck(this, S);
              _this14 = _callSuper(this, S, [t, e]), t.root.addEventListener("beforeinput", function (t) {
                _this14.handleBeforeInput(t);
              }), /Android/i.test(navigator.userAgent) || t.on(r.Ay.events.COMPOSITION_BEFORE_START, function () {
                _this14.handleCompositionStart();
              });
              return _this14;
            }
            _inherits(S, _x$A3);
            return _createClass(S, [{
              key: "deleteRange",
              value: function deleteRange(t) {
                (0, q.Xo)({
                  range: t,
                  quill: this.quill
                });
              }
            }, {
              key: "replaceText",
              value: function replaceText(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                if (0 === t.length) return !1;
                if (e) {
                  var _n7 = this.quill.getFormat(t.index, 1);
                  this.deleteRange(t), this.quill.updateContents(new (d())().retain(t.index).insert(e, _n7), r.Ay.sources.USER);
                } else this.deleteRange(t);
                return this.quill.setSelection(t.index + e.length, 0, r.Ay.sources.SILENT), !0;
              }
            }, {
              key: "handleBeforeInput",
              value: function handleBeforeInput(t) {
                if (this.quill.composition.isComposing || t.defaultPrevented || !L.includes(t.inputType)) return;
                var e = t.getTargetRanges ? t.getTargetRanges()[0] : null;
                if (!e || !0 === e.collapsed) return;
                var n = function (t, _t$dataTransfer) {
                  return "string" == typeof t.data ? t.data : (_t$dataTransfer = t.dataTransfer) !== null && _t$dataTransfer !== void 0 && _t$dataTransfer.types.includes("text/plain") ? t.dataTransfer.getData("text/plain") : null;
                }(t);
                if (null == n) return;
                var r = this.quill.selection.normalizeNative(e),
                  i = r ? this.quill.selection.normalizedToRange(r) : null;
                i && this.replaceText(i, n) && t.preventDefault();
              }
            }, {
              key: "handleCompositionStart",
              value: function handleCompositionStart() {
                var t = this.quill.getSelection();
                t && this.replaceText(t);
              }
            }]);
          }(x.A);
          var O = S;
          var T = /Mac/i.test(navigator.platform);
          var j = /*#__PURE__*/function (_x$A4) {
            function j(t, e) {
              var _this15;
              _classCallCheck(this, j);
              _this15 = _callSuper(this, j, [t, e]), _defineProperty(_assertThisInitialized(_this15), "isListening", !1), _defineProperty(_assertThisInitialized(_this15), "selectionChangeDeadline", 0), _this15.handleArrowKeys(), _this15.handleNavigationShortcuts();
              return _this15;
            }
            _inherits(j, _x$A4);
            return _createClass(j, [{
              key: "handleArrowKeys",
              value: function handleArrowKeys() {
                this.quill.keyboard.addBinding({
                  key: ["ArrowLeft", "ArrowRight"],
                  offset: 0,
                  shiftKey: null,
                  handler: function handler(t, e) {
                    var n = e.line,
                      i = e.event;
                    if (!(n instanceof u.ParentBlot && n.uiNode)) return !0;
                    var s = "rtl" === getComputedStyle(n.domNode).direction;
                    return !!(s && "ArrowRight" !== i.key || !s && "ArrowLeft" !== i.key) || (this.quill.setSelection(t.index - 1, t.length + (i.shiftKey ? 1 : 0), r.Ay.sources.USER), !1);
                  }
                });
              }
            }, {
              key: "handleNavigationShortcuts",
              value: function handleNavigationShortcuts() {
                var _this16 = this;
                this.quill.root.addEventListener("keydown", function (t) {
                  !t.defaultPrevented && function (t) {
                    return "ArrowLeft" === t.key || "ArrowRight" === t.key || "ArrowUp" === t.key || "ArrowDown" === t.key || "Home" === t.key || !(!T || "a" !== t.key || !0 !== t.ctrlKey);
                  }(t) && _this16.ensureListeningToSelectionChange();
                });
              }
            }, {
              key: "ensureListeningToSelectionChange",
              value: function ensureListeningToSelectionChange() {
                var _this17 = this;
                this.selectionChangeDeadline = Date.now() + 100, this.isListening || (this.isListening = !0, document.addEventListener("selectionchange", function () {
                  _this17.isListening = !1, Date.now() <= _this17.selectionChangeDeadline && _this17.handleSelectionChange();
                }, {
                  once: !0
                }));
              }
            }, {
              key: "handleSelectionChange",
              value: function handleSelectionChange() {
                var t = document.getSelection();
                if (!t) return;
                var e = t.getRangeAt(0);
                if (!0 !== e.collapsed || 0 !== e.startOffset) return;
                var n = this.quill.scroll.find(e.startContainer);
                if (!(n instanceof u.ParentBlot && n.uiNode)) return;
                var r = document.createRange();
                r.setStartAfter(n.uiNode), r.setEndAfter(n.uiNode), t.removeAllRanges(), t.addRange(r);
              }
            }]);
          }(x.A);
          var C = j;
          r.Ay.register({
            "blots/block": i.Ay,
            "blots/block/embed": i.zo,
            "blots/break": s.A,
            "blots/container": o.A,
            "blots/cursor": l.A,
            "blots/embed": a.A,
            "blots/inline": c.A,
            "blots/scroll": y,
            "blots/text": v.A,
            "modules/clipboard": A.Ay,
            "modules/history": N,
            "modules/keyboard": q.Ay,
            "modules/uploader": _,
            "modules/input": O,
            "modules/uiNode": C
          });
          var R = r.Ay;
        },
        5374: function _(t, e, n) {
          "use strict";

          var _Class;
          n.d(e, {
            A: function A() {
              return o;
            }
          });
          var r = n(8920),
            i = n(7356);
          var s = (0, n(6078).A)("quill:events");
          ["selectionchange", "mousedown", "mouseup", "click"].forEach(function (t) {
            document.addEventListener(t, function () {
              for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
              Array.from(document.querySelectorAll(".ql-container")).forEach(function (t) {
                var _n$emitter;
                var n = i.A.get(t);
                n && n.emitter && (_n$emitter = n.emitter).handleDOM.apply(_n$emitter, e);
              });
            });
          });
          var o = (_Class = /*#__PURE__*/function (_r7) {
            function o() {
              var _this18;
              _classCallCheck(this, o);
              _this18 = _callSuper(this, o), _this18.domListeners = {}, _this18.on("error", s.error);
              return _this18;
            }
            _inherits(o, _r7);
            return _createClass(o, [{
              key: "emit",
              value: function emit() {
                var _s$log;
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                return (_s$log = s.log).call.apply(_s$log, [s].concat(e)), _superPropGet(o, "emit", this, 3)(e);
              }
            }, {
              key: "handleDOM",
              value: function handleDOM(t) {
                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
                (this.domListeners[t.type] || []).forEach(function (e) {
                  var r = e.node,
                    i = e.handler;
                  (t.target === r || r.contains(t.target)) && i.apply(void 0, [t].concat(n));
                });
              }
            }, {
              key: "listenDOM",
              value: function listenDOM(t, e, n) {
                this.domListeners[t] || (this.domListeners[t] = []), this.domListeners[t].push({
                  node: e,
                  handler: n
                });
              }
            }]);
          }(r), _defineProperty(_Class, "events", {
            EDITOR_CHANGE: "editor-change",
            SCROLL_BEFORE_UPDATE: "scroll-before-update",
            SCROLL_BLOT_MOUNT: "scroll-blot-mount",
            SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount",
            SCROLL_OPTIMIZE: "scroll-optimize",
            SCROLL_UPDATE: "scroll-update",
            SCROLL_EMBED_UPDATE: "scroll-embed-update",
            SELECTION_CHANGE: "selection-change",
            TEXT_CHANGE: "text-change",
            COMPOSITION_BEFORE_START: "composition-before-start",
            COMPOSITION_START: "composition-start",
            COMPOSITION_BEFORE_END: "composition-before-end",
            COMPOSITION_END: "composition-end"
          }), _defineProperty(_Class, "sources", {
            API: "api",
            SILENT: "silent",
            USER: "user"
          }), _Class);
        },
        7356: function _(t, e) {
          "use strict";

          e.A = new WeakMap();
        },
        6078: function _(t, e) {
          "use strict";

          var n = ["error", "warn", "log", "info"];
          var r = "warn";
          function i(t) {
            if (r && n.indexOf(t) <= n.indexOf(r)) {
              var _console;
              for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) i[s - 1] = arguments[s];
              (_console = console)[t].apply(_console, i);
            }
          }
          function s(t) {
            return n.reduce(function (e, n) {
              return e[n] = i.bind(console, n, t), e;
            }, {});
          }
          s.level = function (t) {
            r = t;
          }, i.level = s.level, e.A = s;
        },
        4266: function _(t, e) {
          "use strict";

          var _Class2;
          e.A = (_Class2 = /*#__PURE__*/_createClass(function _Class2(t) {
            _classCallCheck(this, _Class2);
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            this.quill = t, this.options = e;
          }), _defineProperty(_Class2, "DEFAULTS", {}), _Class2);
        },
        6142: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Ay: function Ay() {
              return I;
            }
          });
          var r = n(8347),
            i = n(6003),
            s = n(5232),
            o = n.n(s),
            l = n(3707),
            a = n(5123),
            c = n(9698),
            u = n(3036),
            h = n(4541),
            d = n(5508),
            f = n(8298);
          var p = /^[ -~]*$/;
          function g(t, e, n) {
            if (0 === t.length) {
              var _y = y(n.pop()),
                _y2 = _slicedToArray(_y, 1),
                _t11 = _y2[0];
              return e <= 0 ? "</li></".concat(_t11, ">") : "</li></".concat(_t11, ">").concat(g([], e - 1, n));
            }
            var _t12 = _toArray(t),
              _t12$ = _t12[0],
              r = _t12$.child,
              i = _t12$.offset,
              s = _t12$.length,
              o = _t12$.indent,
              l = _t12$.type,
              a = _t12.slice(1),
              _y3 = y(l),
              _y4 = _slicedToArray(_y3, 2),
              c = _y4[0],
              u = _y4[1];
            if (o > e) return n.push(l), o === e + 1 ? "<".concat(c, "><li").concat(u, ">").concat(m(r, i, s)).concat(g(a, o, n)) : "<".concat(c, "><li>").concat(g(t, e + 1, n));
            var h = n[n.length - 1];
            if (o === e && l === h) return "</li><li".concat(u, ">").concat(m(r, i, s)).concat(g(a, o, n));
            var _y5 = y(n.pop()),
              _y6 = _slicedToArray(_y5, 1),
              d = _y6[0];
            return "</li></".concat(d, ">").concat(g(t, e - 1, n));
          }
          function m(t, e, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            if ("html" in t && "function" == typeof t.html) return t.html(e, n);
            if (t instanceof d.A) return (0, d.X)(t.value().slice(e, e + n));
            if (t instanceof i.ParentBlot) {
              if ("list-container" === t.statics.blotName) {
                var _r8 = [];
                return t.children.forEachAt(e, n, function (t, e, n) {
                  var i = "formats" in t && "function" == typeof t.formats ? t.formats() : {};
                  _r8.push({
                    child: t,
                    offset: e,
                    length: n,
                    indent: i.indent || 0,
                    type: i.list
                  });
                }), g(_r8, -1, []);
              }
              var _i4 = [];
              if (t.children.forEachAt(e, n, function (t, e, n) {
                _i4.push(m(t, e, n));
              }), r || "list" === t.statics.blotName) return _i4.join("");
              var _t$domNode = t.domNode,
                _s4 = _t$domNode.outerHTML,
                _o5 = _t$domNode.innerHTML,
                _s$split = _s4.split(">".concat(_o5, "<")),
                _s$split2 = _slicedToArray(_s$split, 2),
                _l3 = _s$split2[0],
                _a2 = _s$split2[1];
              return "<table" === _l3 ? "<table style=\"border: 1px solid #000;\">".concat(_i4.join(""), "<").concat(_a2) : "".concat(_l3, ">").concat(_i4.join(""), "<").concat(_a2);
            }
            return t.domNode instanceof Element ? t.domNode.outerHTML : "";
          }
          function b(t, e) {
            return Object.keys(e).reduce(function (n, r) {
              if (null == t[r]) return n;
              var i = e[r];
              return i === t[r] ? n[r] = i : Array.isArray(i) ? i.indexOf(t[r]) < 0 ? n[r] = i.concat([t[r]]) : n[r] = i : n[r] = [i, t[r]], n;
            }, {});
          }
          function y(t) {
            var e = "ordered" === t ? "ol" : "ul";
            switch (t) {
              case "checked":
                return [e, ' data-list="checked"'];
              case "unchecked":
                return [e, ' data-list="unchecked"'];
              default:
                return [e, ""];
            }
          }
          function v(t) {
            return t.reduce(function (t, e) {
              if ("string" == typeof e.insert) {
                var _n8 = e.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                return t.insert(_n8, e.attributes);
              }
              return t.push(e);
            }, new (o())());
          }
          function A(t, e) {
            var n = t.index,
              r = t.length;
            return new f.Q(n + e, r);
          }
          var x = /*#__PURE__*/function () {
              function x(t) {
                _classCallCheck(this, x);
                this.scroll = t, this.delta = this.getDelta();
              }
              return _createClass(x, [{
                key: "applyDelta",
                value: function applyDelta(t) {
                  var _this19 = this;
                  this.scroll.update();
                  var e = this.scroll.length();
                  this.scroll.batchStart();
                  var n = v(t),
                    l = new (o())();
                  return function (t) {
                    var e = [];
                    return t.forEach(function (t) {
                      "string" == typeof t.insert ? t.insert.split("\n").forEach(function (n, r) {
                        r && e.push({
                          insert: "\n",
                          attributes: t.attributes
                        }), n && e.push({
                          insert: n,
                          attributes: t.attributes
                        });
                      }) : e.push(t);
                    }), e;
                  }(n.ops.slice()).reduce(function (t, n) {
                    var o = s.Op.length(n);
                    var a = n.attributes || {},
                      u = !1,
                      h = !1;
                    if (null != n.insert) {
                      if (l.retain(o), "string" == typeof n.insert) {
                        var _o6 = n.insert;
                        h = !_o6.endsWith("\n") && (e <= t || !!_this19.scroll.descendant(c.zo, t)[0]), _this19.scroll.insertAt(t, _o6);
                        var _this19$scroll$line = _this19.scroll.line(t),
                          _this19$scroll$line2 = _slicedToArray(_this19$scroll$line, 2),
                          _l4 = _this19$scroll$line2[0],
                          _u = _this19$scroll$line2[1];
                        var _d = (0, r.A)({}, (0, c.Ji)(_l4));
                        if (_l4 instanceof c.Ay) {
                          var _l4$descendant = _l4.descendant(i.LeafBlot, _u),
                            _l4$descendant2 = _slicedToArray(_l4$descendant, 1),
                            _t13 = _l4$descendant2[0];
                          _t13 && (_d = (0, r.A)(_d, (0, c.Ji)(_t13)));
                        }
                        a = s.AttributeMap.diff(_d, a) || {};
                      } else if ("object" == _typeof(n.insert)) {
                        var _o7 = Object.keys(n.insert)[0];
                        if (null == _o7) return t;
                        var _l5 = null != _this19.scroll.query(_o7, i.Scope.INLINE);
                        if (_l5) (e <= t || _this19.scroll.descendant(c.zo, t)[0]) && (h = !0);else if (t > 0) {
                          var _this19$scroll$descen = _this19.scroll.descendant(i.LeafBlot, t - 1),
                            _this19$scroll$descen2 = _slicedToArray(_this19$scroll$descen, 2),
                            _e7 = _this19$scroll$descen2[0],
                            _n9 = _this19$scroll$descen2[1];
                          _e7 instanceof d.A ? "\n" !== _e7.value()[_n9] && (u = !0) : _e7 instanceof i.EmbedBlot && _e7.statics.scope === i.Scope.INLINE_BLOT && (u = !0);
                        }
                        if (_this19.scroll.insertAt(t, _o7, n.insert[_o7]), _l5) {
                          var _this19$scroll$descen3 = _this19.scroll.descendant(i.LeafBlot, t),
                            _this19$scroll$descen4 = _slicedToArray(_this19$scroll$descen3, 1),
                            _e8 = _this19$scroll$descen4[0];
                          if (_e8) {
                            var _t14 = (0, r.A)({}, (0, c.Ji)(_e8));
                            a = s.AttributeMap.diff(_t14, a) || {};
                          }
                        }
                      }
                      e += o;
                    } else if (l.push(n), null !== n.retain && "object" == _typeof(n.retain)) {
                      var _e9 = Object.keys(n.retain)[0];
                      if (null == _e9) return t;
                      _this19.scroll.updateEmbedAt(t, _e9, n.retain[_e9]);
                    }
                    Object.keys(a).forEach(function (e) {
                      _this19.scroll.formatAt(t, o, e, a[e]);
                    });
                    var f = u ? 1 : 0,
                      p = h ? 1 : 0;
                    return e += f + p, l.retain(f), l["delete"](p), t + o + f + p;
                  }, 0), l.reduce(function (t, e) {
                    return "number" == typeof e["delete"] ? (_this19.scroll.deleteAt(t, e["delete"]), t) : t + s.Op.length(e);
                  }, 0), this.scroll.batchEnd(), this.scroll.optimize(), this.update(n);
                }
              }, {
                key: "deleteText",
                value: function deleteText(t, e) {
                  return this.scroll.deleteAt(t, e), this.update(new (o())().retain(t)["delete"](e));
                }
              }, {
                key: "formatLine",
                value: function formatLine(t, e) {
                  var _this20 = this;
                  var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                  this.scroll.update(), Object.keys(n).forEach(function (r) {
                    _this20.scroll.lines(t, Math.max(e, 1)).forEach(function (t) {
                      t.format(r, n[r]);
                    });
                  }), this.scroll.optimize();
                  var r = new (o())().retain(t).retain(e, (0, l.A)(n));
                  return this.update(r);
                }
              }, {
                key: "formatText",
                value: function formatText(t, e) {
                  var _this21 = this;
                  var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                  Object.keys(n).forEach(function (r) {
                    _this21.scroll.formatAt(t, e, r, n[r]);
                  });
                  var r = new (o())().retain(t).retain(e, (0, l.A)(n));
                  return this.update(r);
                }
              }, {
                key: "getContents",
                value: function getContents(t, e) {
                  return this.delta.slice(t, t + e);
                }
              }, {
                key: "getDelta",
                value: function getDelta() {
                  return this.scroll.lines().reduce(function (t, e) {
                    return t.concat(e.delta());
                  }, new (o())());
                }
              }, {
                key: "getFormat",
                value: function getFormat(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = [],
                    r = [];
                  0 === e ? this.scroll.path(t).forEach(function (t) {
                    var _t15 = _slicedToArray(t, 1),
                      e = _t15[0];
                    e instanceof c.Ay ? n.push(e) : e instanceof i.LeafBlot && r.push(e);
                  }) : (n = this.scroll.lines(t, e), r = this.scroll.descendants(i.LeafBlot, t, e));
                  var _map = [n, r].map(function (t) {
                      var e = t.shift();
                      if (null == e) return {};
                      var n = (0, c.Ji)(e);
                      for (; Object.keys(n).length > 0;) {
                        var _e0 = t.shift();
                        if (null == _e0) return n;
                        n = b((0, c.Ji)(_e0), n);
                      }
                      return n;
                    }),
                    _map2 = _slicedToArray(_map, 2),
                    s = _map2[0],
                    o = _map2[1];
                  return _objectSpread(_objectSpread({}, s), o);
                }
              }, {
                key: "getHTML",
                value: function getHTML(t, e) {
                  var _this$scroll$line = this.scroll.line(t),
                    _this$scroll$line2 = _slicedToArray(_this$scroll$line, 2),
                    n = _this$scroll$line2[0],
                    r = _this$scroll$line2[1];
                  if (n) {
                    var _i5 = n.length();
                    return n.length() >= r + e && (0 !== r || e !== _i5) ? m(n, r, e, !0) : m(this.scroll, t, e, !0);
                  }
                  return "";
                }
              }, {
                key: "getText",
                value: function getText(t, e) {
                  return this.getContents(t, e).filter(function (t) {
                    return "string" == typeof t.insert;
                  }).map(function (t) {
                    return t.insert;
                  }).join("");
                }
              }, {
                key: "insertContents",
                value: function insertContents(t, e) {
                  var n = v(e),
                    r = new (o())().retain(t).concat(n);
                  return this.scroll.insertContents(t, n), this.update(r);
                }
              }, {
                key: "insertEmbed",
                value: function insertEmbed(t, e, n) {
                  return this.scroll.insertAt(t, e, n), this.update(new (o())().retain(t).insert(_defineProperty({}, e, n)));
                }
              }, {
                key: "insertText",
                value: function insertText(t, e) {
                  var _this22 = this;
                  var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                  return e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), this.scroll.insertAt(t, e), Object.keys(n).forEach(function (r) {
                    _this22.scroll.formatAt(t, e.length, r, n[r]);
                  }), this.update(new (o())().retain(t).insert(e, (0, l.A)(n)));
                }
              }, {
                key: "isBlank",
                value: function isBlank() {
                  if (0 === this.scroll.children.length) return !0;
                  if (this.scroll.children.length > 1) return !1;
                  var t = this.scroll.children.head;
                  if ((t === null || t === void 0 ? void 0 : t.statics.blotName) !== c.Ay.blotName) return !1;
                  var e = t;
                  return !(e.children.length > 1) && e.children.head instanceof u.A;
                }
              }, {
                key: "removeFormat",
                value: function removeFormat(t, e) {
                  var n = this.getText(t, e),
                    _this$scroll$line3 = this.scroll.line(t + e),
                    _this$scroll$line4 = _slicedToArray(_this$scroll$line3, 2),
                    r = _this$scroll$line4[0],
                    i = _this$scroll$line4[1];
                  var s = 0,
                    l = new (o())();
                  null != r && (s = r.length() - i, l = r.delta().slice(i, i + s - 1).insert("\n"));
                  var a = this.getContents(t, e + s).diff(new (o())().insert(n).concat(l)),
                    c = new (o())().retain(t).concat(a);
                  return this.applyDelta(c);
                }
              }, {
                key: "update",
                value: function update(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
                  var r = this.delta;
                  if (1 === e.length && "characterData" === e[0].type && e[0].target.data.match(p) && this.scroll.find(e[0].target)) {
                    var _i6 = this.scroll.find(e[0].target),
                      _s5 = (0, c.Ji)(_i6),
                      _l6 = _i6.offset(this.scroll),
                      _a3 = e[0].oldValue.replace(h.A.CONTENTS, ""),
                      _u2 = new (o())().insert(_a3),
                      _d2 = new (o())().insert(_i6.value()),
                      _f = n && {
                        oldRange: A(n.oldRange, -_l6),
                        newRange: A(n.newRange, -_l6)
                      };
                    t = new (o())().retain(_l6).concat(_u2.diff(_d2, _f)).reduce(function (t, e) {
                      return e.insert ? t.insert(e.insert, _s5) : t.push(e);
                    }, new (o())()), this.delta = r.compose(t);
                  } else this.delta = this.getDelta(), t && (0, a.A)(r.compose(t), this.delta) || (t = r.diff(this.delta, n));
                  return t;
                }
              }]);
            }(),
            N = n(5374),
            E = n(7356),
            w = n(6078),
            q = n(4266),
            k = n(746),
            _ = /*#__PURE__*/function () {
              function _(t, e) {
                _classCallCheck(this, _);
                _defineProperty(this, "isComposing", !1);
                this.scroll = t, this.emitter = e, this.setupListeners();
              }
              return _createClass(_, [{
                key: "setupListeners",
                value: function setupListeners() {
                  var _this23 = this;
                  this.scroll.domNode.addEventListener("compositionstart", function (t) {
                    _this23.isComposing || _this23.handleCompositionStart(t);
                  }), this.scroll.domNode.addEventListener("compositionend", function (t) {
                    _this23.isComposing && queueMicrotask(function () {
                      _this23.handleCompositionEnd(t);
                    });
                  });
                }
              }, {
                key: "handleCompositionStart",
                value: function handleCompositionStart(t) {
                  var e = t.target instanceof Node ? this.scroll.find(t.target, !0) : null;
                  !e || e instanceof k.A || (this.emitter.emit(N.A.events.COMPOSITION_BEFORE_START, t), this.scroll.batchStart(), this.emitter.emit(N.A.events.COMPOSITION_START, t), this.isComposing = !0);
                }
              }, {
                key: "handleCompositionEnd",
                value: function handleCompositionEnd(t) {
                  this.emitter.emit(N.A.events.COMPOSITION_BEFORE_END, t), this.scroll.batchEnd(), this.emitter.emit(N.A.events.COMPOSITION_END, t), this.isComposing = !1;
                }
              }]);
            }(),
            L = n(9609);
          var S = function S(t) {
              var e = t.getBoundingClientRect(),
                n = "offsetWidth" in t && Math.abs(e.width) / t.offsetWidth || 1,
                r = "offsetHeight" in t && Math.abs(e.height) / t.offsetHeight || 1;
              return {
                top: e.top,
                right: e.left + t.clientWidth * n,
                bottom: e.top + t.clientHeight * r,
                left: e.left
              };
            },
            O = function O(t) {
              var e = parseInt(t, 10);
              return Number.isNaN(e) ? 0 : e;
            },
            T = function T(t, e, n, r, i, s) {
              return t < n && e > r ? 0 : t < n ? -(n - t + i) : e > r ? e - t > r - n ? t + i - n : e - r + s : 0;
            };
          var j = ["block", "break", "cursor", "inline", "scroll", "text"];
          var C = (0, w.A)("quill"),
            R = new i.Registry();
          i.ParentBlot.uiClass = "ql-ui";
          var I = /*#__PURE__*/function () {
            function I(t) {
              var _this24 = this;
              _classCallCheck(this, I);
              var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              if (this.options = function (t, e) {
                var n = B(t);
                if (!n) throw new Error("Invalid Quill container");
                var s = !e.theme || e.theme === I.DEFAULTS.theme ? L.A : I["import"]("themes/".concat(e.theme));
                if (!s) throw new Error("Invalid theme ".concat(e.theme, ". Did you register it?"));
                var _I$DEFAULTS = I.DEFAULTS,
                  o = _I$DEFAULTS.modules,
                  l = _objectWithoutProperties(_I$DEFAULTS, _excluded),
                  _s$DEFAULTS = s.DEFAULTS,
                  a = _s$DEFAULTS.modules,
                  c = _objectWithoutProperties(_s$DEFAULTS, _excluded2),
                  u = (0, r.A)({}, M(o), M(a), M(e.modules));
                null != u && u.toolbar && u.toolbar.constructor !== Object && (u.toolbar = {
                  container: u.toolbar
                });
                var h = _objectSpread(_objectSpread(_objectSpread({}, l), U(c)), U(e));
                var d = e.registry;
                return d ? e.formats && C.warn('Ignoring "formats" option because "registry" is specified') : d = e.formats ? function (t, e, n) {
                  var r = new i.Registry();
                  return j.forEach(function (t) {
                    var n = e.query(t);
                    n && r.register(n);
                  }), t.forEach(function (t) {
                    var i = e.query(t);
                    i || n.error("Cannot register \"".concat(t, "\" specified in \"formats\" config. Are you sure it was registered?"));
                    var s = 0;
                    for (; i;) {
                      var _i$requiredContainer;
                      if (r.register(i), i = "blotName" in i ? (_i$requiredContainer = i.requiredContainer) !== null && _i$requiredContainer !== void 0 ? _i$requiredContainer : null : null, s += 1, s > 100) {
                        n.error("Cycle detected in registering blot requiredContainer: \"".concat(t, "\""));
                        break;
                      }
                    }
                  }), r;
                }(e.formats, h.registry, C) : h.registry, _objectSpread(_objectSpread({}, h), {}, {
                  registry: d,
                  container: n,
                  theme: s,
                  modules: Object.entries(u).reduce(function (t, e) {
                    var _e1 = _slicedToArray(e, 2),
                      n = _e1[0],
                      i = _e1[1];
                    if (!i) return t;
                    var s = I["import"]("modules/".concat(n));
                    return null == s ? (C.error("Cannot load ".concat(n, " module. Are you sure you registered it?")), t) : _objectSpread(_objectSpread({}, t), {}, _defineProperty({}, n, (0, r.A)({}, s.DEFAULTS || {}, i)));
                  }, {}),
                  bounds: B(h.bounds)
                });
              }(t, e), this.container = this.options.container, null == this.container) return void C.error("Invalid Quill container", t);
              this.options.debug && I.debug(this.options.debug);
              var n = this.container.innerHTML.trim();
              this.container.classList.add("ql-container"), this.container.innerHTML = "", E.A.set(this.container, this), this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.emitter = new N.A();
              var s = i.ScrollBlot.blotName,
                l = this.options.registry.query(s);
              if (!l || !("blotName" in l)) throw new Error("Cannot initialize Quill without \"".concat(s, "\" blot"));
              if (this.scroll = new l(this.options.registry, this.root, {
                emitter: this.emitter
              }), this.editor = new x(this.scroll), this.selection = new f.A(this.scroll, this.emitter), this.composition = new _(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.uploader = this.theme.addModule("uploader"), this.theme.addModule("input"), this.theme.addModule("uiNode"), this.theme.init(), this.emitter.on(N.A.events.EDITOR_CHANGE, function (t) {
                t === N.A.events.TEXT_CHANGE && _this24.root.classList.toggle("ql-blank", _this24.editor.isBlank());
              }), this.emitter.on(N.A.events.SCROLL_UPDATE, function (t, e) {
                var n = _this24.selection.lastRange,
                  _this24$selection$get = _this24.selection.getRange(),
                  _this24$selection$get2 = _slicedToArray(_this24$selection$get, 1),
                  r = _this24$selection$get2[0],
                  i = n && r ? {
                    oldRange: n,
                    newRange: r
                  } : void 0;
                D.call(_this24, function () {
                  return _this24.editor.update(null, e, i);
                }, t);
              }), this.emitter.on(N.A.events.SCROLL_EMBED_UPDATE, function (t, e) {
                var n = _this24.selection.lastRange,
                  _this24$selection$get3 = _this24.selection.getRange(),
                  _this24$selection$get4 = _slicedToArray(_this24$selection$get3, 1),
                  r = _this24$selection$get4[0],
                  i = n && r ? {
                    oldRange: n,
                    newRange: r
                  } : void 0;
                D.call(_this24, function () {
                  var n = new (o())().retain(t.offset(_this24)).retain(_defineProperty({}, t.statics.blotName, e));
                  return _this24.editor.update(n, [], i);
                }, I.sources.USER);
              }), n) {
                var _t16 = this.clipboard.convert({
                  html: "".concat(n, "<p><br></p>"),
                  text: "\n"
                });
                this.setContents(_t16);
              }
              this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable(), this.allowReadOnlyEdits = !1;
            }
            return _createClass(I, [{
              key: "addContainer",
              value: function addContainer(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if ("string" == typeof t) {
                  var _e10 = t;
                  (t = document.createElement("div")).classList.add(_e10);
                }
                return this.container.insertBefore(t, e), t;
              }
            }, {
              key: "blur",
              value: function blur() {
                this.selection.setRange(null);
              }
            }, {
              key: "deleteText",
              value: function deleteText(t, e, n) {
                var _P,
                  _P2,
                  _this25 = this;
                return _P = P(t, e, n), _P2 = _slicedToArray(_P, 4), t = _P2[0], e = _P2[1], n = _P2[3], D.call(this, function () {
                  return _this25.editor.deleteText(t, e);
                }, n, t, -1 * e);
              }
            }, {
              key: "disable",
              value: function disable() {
                this.enable(!1);
              }
            }, {
              key: "editReadOnly",
              value: function editReadOnly(t) {
                this.allowReadOnlyEdits = !0;
                var e = t();
                return this.allowReadOnlyEdits = !1, e;
              }
            }, {
              key: "enable",
              value: function enable() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.scroll.enable(t), this.container.classList.toggle("ql-disabled", !t);
              }
            }, {
              key: "focus",
              value: function focus() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.selection.focus(), t.preventScroll || this.scrollSelectionIntoView();
              }
            }, {
              key: "format",
              value: function format(t, e) {
                var _this26 = this;
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : N.A.sources.API;
                return D.call(this, function () {
                  var n = _this26.getSelection(!0);
                  var r = new (o())();
                  if (null == n) return r;
                  if (_this26.scroll.query(t, i.Scope.BLOCK)) r = _this26.editor.formatLine(n.index, n.length, _defineProperty({}, t, e));else {
                    if (0 === n.length) return _this26.selection.format(t, e), r;
                    r = _this26.editor.formatText(n.index, n.length, _defineProperty({}, t, e));
                  }
                  return _this26.setSelection(n, N.A.sources.SILENT), r;
                }, n);
              }
            }, {
              key: "formatLine",
              value: function formatLine(t, e, n, r, i) {
                var _P3,
                  _P4,
                  _this27 = this;
                var s;
                return _P3 = P(t, e, n, r, i), _P4 = _slicedToArray(_P3, 4), t = _P4[0], e = _P4[1], s = _P4[2], i = _P4[3], D.call(this, function () {
                  return _this27.editor.formatLine(t, e, s);
                }, i, t, 0);
              }
            }, {
              key: "formatText",
              value: function formatText(t, e, n, r, i) {
                var _P5,
                  _P6,
                  _this28 = this;
                var s;
                return _P5 = P(t, e, n, r, i), _P6 = _slicedToArray(_P5, 4), t = _P6[0], e = _P6[1], s = _P6[2], i = _P6[3], D.call(this, function () {
                  return _this28.editor.formatText(t, e, s);
                }, i, t, 0);
              }
            }, {
              key: "getBounds",
              value: function getBounds(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                  n = null;
                if (n = "number" == typeof t ? this.selection.getBounds(t, e) : this.selection.getBounds(t.index, t.length), !n) return null;
                var r = this.container.getBoundingClientRect();
                return {
                  bottom: n.bottom - r.top,
                  height: n.height,
                  left: n.left - r.left,
                  right: n.right - r.left,
                  top: n.top - r.top,
                  width: n.width
                };
              }
            }, {
              key: "getContents",
              value: function getContents() {
                var _P7, _P8;
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t;
                return _P7 = P(t, e), _P8 = _slicedToArray(_P7, 2), t = _P8[0], e = _P8[1], this.editor.getContents(t, e);
              }
            }, {
              key: "getFormat",
              value: function getFormat() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(!0),
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return "number" == typeof t ? this.editor.getFormat(t, e) : this.editor.getFormat(t.index, t.length);
              }
            }, {
              key: "getIndex",
              value: function getIndex(t) {
                return t.offset(this.scroll);
              }
            }, {
              key: "getLength",
              value: function getLength() {
                return this.scroll.length();
              }
            }, {
              key: "getLeaf",
              value: function getLeaf(t) {
                return this.scroll.leaf(t);
              }
            }, {
              key: "getLine",
              value: function getLine(t) {
                return this.scroll.line(t);
              }
            }, {
              key: "getLines",
              value: function getLines() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
                return "number" != typeof t ? this.scroll.lines(t.index, t.length) : this.scroll.lines(t, e);
              }
            }, {
              key: "getModule",
              value: function getModule(t) {
                return this.theme.modules[t];
              }
            }, {
              key: "getSelection",
              value: function getSelection() {
                return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];
              }
            }, {
              key: "getSemanticHTML",
              value: function getSemanticHTML() {
                var _P9, _P0;
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 ? arguments[1] : void 0;
                return "number" == typeof t && (e = e !== null && e !== void 0 ? e : this.getLength() - t), _P9 = P(t, e), _P0 = _slicedToArray(_P9, 2), t = _P0[0], e = _P0[1], this.editor.getHTML(t, e);
              }
            }, {
              key: "getText",
              value: function getText() {
                var _P1, _P10;
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                  e = arguments.length > 1 ? arguments[1] : void 0;
                return "number" == typeof t && (e = e !== null && e !== void 0 ? e : this.getLength() - t), _P1 = P(t, e), _P10 = _slicedToArray(_P1, 2), t = _P10[0], e = _P10[1], this.editor.getText(t, e);
              }
            }, {
              key: "hasFocus",
              value: function hasFocus() {
                return this.selection.hasFocus();
              }
            }, {
              key: "insertEmbed",
              value: function insertEmbed(t, e, n) {
                var _this29 = this;
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : I.sources.API;
                return D.call(this, function () {
                  return _this29.editor.insertEmbed(t, e, n);
                }, r, t);
              }
            }, {
              key: "insertText",
              value: function insertText(t, e, n, r, i) {
                var _P11,
                  _P12,
                  _this30 = this;
                var s;
                return _P11 = P(t, 0, n, r, i), _P12 = _slicedToArray(_P11, 4), t = _P12[0], s = _P12[2], i = _P12[3], D.call(this, function () {
                  return _this30.editor.insertText(t, e, s);
                }, i, t, e.length);
              }
            }, {
              key: "isEnabled",
              value: function isEnabled() {
                return this.scroll.isEnabled();
              }
            }, {
              key: "off",
              value: function off() {
                var _this$emitter;
                return (_this$emitter = this.emitter).off.apply(_this$emitter, arguments);
              }
            }, {
              key: "on",
              value: function on() {
                var _this$emitter2;
                return (_this$emitter2 = this.emitter).on.apply(_this$emitter2, arguments);
              }
            }, {
              key: "once",
              value: function once() {
                var _this$emitter3;
                return (_this$emitter3 = this.emitter).once.apply(_this$emitter3, arguments);
              }
            }, {
              key: "removeFormat",
              value: function removeFormat(t, e, n) {
                var _P13,
                  _P14,
                  _this31 = this;
                return _P13 = P(t, e, n), _P14 = _slicedToArray(_P13, 4), t = _P14[0], e = _P14[1], n = _P14[3], D.call(this, function () {
                  return _this31.editor.removeFormat(t, e);
                }, n, t);
              }
            }, {
              key: "scrollRectIntoView",
              value: function scrollRectIntoView(t) {
                (function (t, e) {
                  var n = t.ownerDocument;
                  var r = e,
                    i = t;
                  for (; i;) {
                    var _window$visualViewpor, _window$visualViewpor2, _window$visualViewpor3, _window$visualViewpor4, _n$defaultView;
                    var _t17 = i === n.body,
                      _e11 = _t17 ? {
                        top: 0,
                        right: (_window$visualViewpor = (_window$visualViewpor2 = window.visualViewport) === null || _window$visualViewpor2 === void 0 ? void 0 : _window$visualViewpor2.width) !== null && _window$visualViewpor !== void 0 ? _window$visualViewpor : n.documentElement.clientWidth,
                        bottom: (_window$visualViewpor3 = (_window$visualViewpor4 = window.visualViewport) === null || _window$visualViewpor4 === void 0 ? void 0 : _window$visualViewpor4.height) !== null && _window$visualViewpor3 !== void 0 ? _window$visualViewpor3 : n.documentElement.clientHeight,
                        left: 0
                      } : S(i),
                      _o8 = getComputedStyle(i),
                      _l7 = T(r.left, r.right, _e11.left, _e11.right, O(_o8.scrollPaddingLeft), O(_o8.scrollPaddingRight)),
                      _a4 = T(r.top, r.bottom, _e11.top, _e11.bottom, O(_o8.scrollPaddingTop), O(_o8.scrollPaddingBottom));
                    if (_l7 || _a4) if (_t17) (_n$defaultView = n.defaultView) === null || _n$defaultView === void 0 || _n$defaultView.scrollBy(_l7, _a4);else {
                      var _i7 = i,
                        _t18 = _i7.scrollLeft,
                        _e12 = _i7.scrollTop;
                      _a4 && (i.scrollTop += _a4), _l7 && (i.scrollLeft += _l7);
                      var _n0 = i.scrollLeft - _t18,
                        _s6 = i.scrollTop - _e12;
                      r = {
                        left: r.left - _n0,
                        top: r.top - _s6,
                        right: r.right - _n0,
                        bottom: r.bottom - _s6
                      };
                    }
                    i = _t17 || "fixed" === _o8.position ? null : (s = i).parentElement || s.getRootNode().host || null;
                  }
                  var s;
                })(this.root, t);
              }
            }, {
              key: "scrollIntoView",
              value: function scrollIntoView() {
                console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead."), this.scrollSelectionIntoView();
              }
            }, {
              key: "scrollSelectionIntoView",
              value: function scrollSelectionIntoView() {
                var t = this.selection.lastRange,
                  e = t && this.selection.getBounds(t.index, t.length);
                e && this.scrollRectIntoView(e);
              }
            }, {
              key: "setContents",
              value: function setContents(t) {
                var _this32 = this;
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : N.A.sources.API;
                return D.call(this, function () {
                  t = new (o())(t);
                  var e = _this32.getLength(),
                    n = _this32.editor.deleteText(0, e),
                    r = _this32.editor.insertContents(0, t),
                    i = _this32.editor.deleteText(_this32.getLength() - 1, 1);
                  return n.compose(r).compose(i);
                }, e);
              }
            }, {
              key: "setSelection",
              value: function setSelection(t, e, n) {
                var _P15, _P16;
                null == t ? this.selection.setRange(null, e || I.sources.API) : (_P15 = P(t, e, n), _P16 = _slicedToArray(_P15, 4), t = _P16[0], e = _P16[1], n = _P16[3], this.selection.setRange(new f.Q(Math.max(0, t), e), n), n !== N.A.sources.SILENT && this.scrollSelectionIntoView());
              }
            }, {
              key: "setText",
              value: function setText(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : N.A.sources.API;
                var n = new (o())().insert(t);
                return this.setContents(n, e);
              }
            }, {
              key: "update",
              value: function update() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N.A.sources.USER;
                var e = this.scroll.update(t);
                return this.selection.update(t), e;
              }
            }, {
              key: "updateContents",
              value: function updateContents(t) {
                var _this33 = this;
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : N.A.sources.API;
                return D.call(this, function () {
                  return t = new (o())(t), _this33.editor.applyDelta(t);
                }, e, !0);
              }
            }], [{
              key: "debug",
              value: function debug(t) {
                !0 === t && (t = "log"), w.A.level(t);
              }
            }, {
              key: "find",
              value: function find(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                return E.A.get(t) || R.find(t, e);
              }
            }, {
              key: "import",
              value: function _import(t) {
                return null == this.imports[t] && C.error("Cannot import ".concat(t, ". Are you sure it was registered?")), this.imports[t];
              }
            }, {
              key: "register",
              value: function register(t, e) {
                var _this34 = this;
                var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if ("string" != typeof t) {
                  var _n1 = "attrName" in t ? t.attrName : t.blotName;
                  "string" == typeof _n1 ? this.register("formats/".concat(_n1), t, e) : Object.keys(t).forEach(function (n) {
                    _this34.register(n, t[n], e);
                  });
                } else null == this.imports[t] || n || C.warn("Overwriting ".concat(t, " with"), e), this.imports[t] = e, (t.startsWith("blots/") || t.startsWith("formats/")) && e && "boolean" != typeof e && "abstract" !== e.blotName && R.register(e), "function" == typeof e.register && e.register(R);
              }
            }]);
          }();
          _defineProperty(I, "DEFAULTS", {
            bounds: null,
            modules: {
              clipboard: !0,
              keyboard: !0,
              history: !0,
              uploader: !0
            },
            placeholder: "",
            readOnly: !1,
            registry: R,
            theme: "default"
          });
          _defineProperty(I, "events", N.A.events);
          _defineProperty(I, "sources", N.A.sources);
          _defineProperty(I, "version", "2.0.0-rc.5");
          _defineProperty(I, "imports", {
            delta: o(),
            parchment: i,
            "core/module": q.A,
            "core/theme": L.A
          });
          function B(t) {
            return "string" == typeof t ? document.querySelector(t) : t;
          }
          function M(t) {
            return Object.entries(t !== null && t !== void 0 ? t : {}).reduce(function (t, e) {
              var _e13 = _slicedToArray(e, 2),
                n = _e13[0],
                r = _e13[1];
              return _objectSpread(_objectSpread({}, t), {}, _defineProperty({}, n, !0 === r ? {} : r));
            }, {});
          }
          function U(t) {
            return Object.fromEntries(Object.entries(t).filter(function (t) {
              return void 0 !== t[1];
            }));
          }
          function D(t, e, n, r) {
            if (!this.isEnabled() && e === N.A.sources.USER && !this.allowReadOnlyEdits) return new (o())();
            var i = null == n ? null : this.getSelection();
            var s = this.editor.delta,
              l = t();
            if (null != i && (!0 === n && (n = i.index), null == r ? i = z(i, l, e) : 0 !== r && (i = z(i, n, r, e)), this.setSelection(i, N.A.sources.SILENT)), l.length() > 0) {
              var _this$emitter4, _this$emitter5;
              var _t19 = [N.A.events.TEXT_CHANGE, l, s, e];
              (_this$emitter4 = this.emitter).emit.apply(_this$emitter4, [N.A.events.EDITOR_CHANGE].concat(_t19)), e !== N.A.sources.SILENT && (_this$emitter5 = this.emitter).emit.apply(_this$emitter5, _t19);
            }
            return l;
          }
          function P(t, e, n, r, i) {
            var s = {};
            return "number" == typeof t.index && "number" == typeof t.length ? "number" != typeof e ? (i = r, r = n, n = e, e = t.length, t = t.index) : (e = t.length, t = t.index) : "number" != typeof e && (i = r, r = n, n = e, e = 0), "object" == _typeof(n) ? (s = n, i = r) : "string" == typeof n && (null != r ? s[n] = r : i = n), [t, e, s, i = i || N.A.sources.API];
          }
          function z(t, e, n, r) {
            var _map3, _map4, _map5, _map6;
            var i = "number" == typeof n ? n : 0;
            if (null == t) return null;
            var s, o;
            return e && "function" == typeof e.transformPosition ? (_map3 = [t.index, t.index + t.length].map(function (t) {
              return e.transformPosition(t, r !== N.A.sources.USER);
            }), _map4 = _slicedToArray(_map3, 2), s = _map4[0], o = _map4[1], _map3) : (_map5 = [t.index, t.index + t.length].map(function (t) {
              return t < e || t === e && r === N.A.sources.USER ? t : i >= 0 ? t + i : Math.max(e, t + i);
            }), _map6 = _slicedToArray(_map5, 2), s = _map6[0], o = _map6[1], _map5), new f.Q(s, o - s);
          }
        },
        8298: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Q: function Q() {
              return a;
            }
          });
          var r = n(6003),
            i = n(5123),
            s = n(3707),
            o = n(5374);
          var l = (0, n(6078).A)("quill:selection");
          var a = /*#__PURE__*/_createClass(function a(t) {
            _classCallCheck(this, a);
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            this.index = t, this.length = e;
          });
          function c(t, e) {
            try {
              e.parentNode;
            } catch (t) {
              return !1;
            }
            return t.contains(e);
          }
          e.A = /*#__PURE__*/function () {
            function _class(t, e) {
              var _this35 = this;
              _classCallCheck(this, _class);
              this.emitter = e, this.scroll = t, this.composing = !1, this.mouseDown = !1, this.root = this.scroll.domNode, this.cursor = this.scroll.create("cursor", this), this.savedRange = new a(0, 0), this.lastRange = this.savedRange, this.lastNative = null, this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, function () {
                _this35.mouseDown || _this35.composing || setTimeout(_this35.update.bind(_this35, o.A.sources.USER), 1);
              }), this.emitter.on(o.A.events.SCROLL_BEFORE_UPDATE, function () {
                if (!_this35.hasFocus()) return;
                var t = _this35.getNativeRange();
                null != t && t.start.node !== _this35.cursor.textNode && _this35.emitter.once(o.A.events.SCROLL_UPDATE, function (e, n) {
                  try {
                    _this35.root.contains(t.start.node) && _this35.root.contains(t.end.node) && _this35.setNativeRange(t.start.node, t.start.offset, t.end.node, t.end.offset);
                    var _r9 = n.some(function (t) {
                      return "characterData" === t.type || "childList" === t.type || "attributes" === t.type && t.target === _this35.root;
                    });
                    _this35.update(_r9 ? o.A.sources.SILENT : e);
                  } catch (t) {}
                });
              }), this.emitter.on(o.A.events.SCROLL_OPTIMIZE, function (t, e) {
                if (e.range) {
                  var _e$range = e.range,
                    _t20 = _e$range.startNode,
                    _n10 = _e$range.startOffset,
                    _r0 = _e$range.endNode,
                    _i8 = _e$range.endOffset;
                  _this35.setNativeRange(_t20, _n10, _r0, _i8), _this35.update(o.A.sources.SILENT);
                }
              }), this.update(o.A.sources.SILENT);
            }
            return _createClass(_class, [{
              key: "handleComposition",
              value: function handleComposition() {
                var _this36 = this;
                this.emitter.on(o.A.events.COMPOSITION_BEFORE_START, function () {
                  _this36.composing = !0;
                }), this.emitter.on(o.A.events.COMPOSITION_END, function () {
                  if (_this36.composing = !1, _this36.cursor.parent) {
                    var _t21 = _this36.cursor.restore();
                    if (!_t21) return;
                    setTimeout(function () {
                      _this36.setNativeRange(_t21.startNode, _t21.startOffset, _t21.endNode, _t21.endOffset);
                    }, 1);
                  }
                });
              }
            }, {
              key: "handleDragging",
              value: function handleDragging() {
                var _this37 = this;
                this.emitter.listenDOM("mousedown", document.body, function () {
                  _this37.mouseDown = !0;
                }), this.emitter.listenDOM("mouseup", document.body, function () {
                  _this37.mouseDown = !1, _this37.update(o.A.sources.USER);
                });
              }
            }, {
              key: "focus",
              value: function focus() {
                this.hasFocus() || (this.root.focus({
                  preventScroll: !0
                }), this.setRange(this.savedRange));
              }
            }, {
              key: "format",
              value: function format(t, e) {
                this.scroll.update();
                var n = this.getNativeRange();
                if (null != n && n["native"].collapsed && !this.scroll.query(t, r.Scope.BLOCK)) {
                  if (n.start.node !== this.cursor.textNode) {
                    var _t22 = this.scroll.find(n.start.node, !1);
                    if (null == _t22) return;
                    if (_t22 instanceof r.LeafBlot) {
                      var _e14 = _t22.split(n.start.offset);
                      _t22.parent.insertBefore(this.cursor, _e14);
                    } else _t22.insertBefore(this.cursor, n.start.node);
                    this.cursor.attach();
                  }
                  this.cursor.format(t, e), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
                }
              }
            }, {
              key: "getBounds",
              value: function getBounds(t) {
                var _this$scroll$leaf5, _this$scroll$leaf6, _i$position3, _i$position4;
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                var n = this.scroll.length();
                var r;
                t = Math.min(t, n - 1), e = Math.min(t + e, n - 1) - t;
                var _this$scroll$leaf = this.scroll.leaf(t),
                  _this$scroll$leaf2 = _slicedToArray(_this$scroll$leaf, 2),
                  i = _this$scroll$leaf2[0],
                  s = _this$scroll$leaf2[1];
                if (null == i) return null;
                if (e > 0 && s === i.length()) {
                  var _this$scroll$leaf3 = this.scroll.leaf(t + 1),
                    _this$scroll$leaf4 = _slicedToArray(_this$scroll$leaf3, 1),
                    _e15 = _this$scroll$leaf4[0];
                  if (_e15) {
                    var _this$scroll$line5 = this.scroll.line(t),
                      _this$scroll$line6 = _slicedToArray(_this$scroll$line5, 1),
                      _n11 = _this$scroll$line6[0],
                      _this$scroll$line7 = this.scroll.line(t + 1),
                      _this$scroll$line8 = _slicedToArray(_this$scroll$line7, 1),
                      _r1 = _this$scroll$line8[0];
                    _n11 === _r1 && (i = _e15, s = 0);
                  }
                }
                var _i$position = i.position(s, !0);
                var _i$position2 = _slicedToArray(_i$position, 2);
                r = _i$position2[0];
                s = _i$position2[1];
                var o = document.createRange();
                if (e > 0) return o.setStart(r, s), _this$scroll$leaf5 = this.scroll.leaf(t + e), _this$scroll$leaf6 = _slicedToArray(_this$scroll$leaf5, 2), i = _this$scroll$leaf6[0], s = _this$scroll$leaf6[1], null == i ? null : (_i$position3 = i.position(s, !0), _i$position4 = _slicedToArray(_i$position3, 2), r = _i$position4[0], s = _i$position4[1], o.setEnd(r, s), o.getBoundingClientRect());
                var l,
                  a = "left";
                if (r instanceof Text) {
                  if (!r.data.length) return null;
                  s < r.data.length ? (o.setStart(r, s), o.setEnd(r, s + 1)) : (o.setStart(r, s - 1), o.setEnd(r, s), a = "right"), l = o.getBoundingClientRect();
                } else {
                  if (!(i.domNode instanceof Element)) return null;
                  l = i.domNode.getBoundingClientRect(), s > 0 && (a = "right");
                }
                return {
                  bottom: l.top + l.height,
                  height: l.height,
                  left: l[a],
                  right: l[a],
                  top: l.top,
                  width: 0
                };
              }
            }, {
              key: "getNativeRange",
              value: function getNativeRange() {
                var t = document.getSelection();
                if (null == t || t.rangeCount <= 0) return null;
                var e = t.getRangeAt(0);
                if (null == e) return null;
                var n = this.normalizeNative(e);
                return l.info("getNativeRange", n), n;
              }
            }, {
              key: "getRange",
              value: function getRange() {
                var t = this.scroll.domNode;
                if ("isConnected" in t && !t.isConnected) return [null, null];
                var e = this.getNativeRange();
                return null == e ? [null, null] : [this.normalizedToRange(e), e];
              }
            }, {
              key: "hasFocus",
              value: function hasFocus() {
                return document.activeElement === this.root || null != document.activeElement && c(this.root, document.activeElement);
              }
            }, {
              key: "normalizedToRange",
              value: function normalizedToRange(t) {
                var _this38 = this;
                var e = [[t.start.node, t.start.offset]];
                t["native"].collapsed || e.push([t.end.node, t.end.offset]);
                var n = e.map(function (t) {
                    var _t23 = _slicedToArray(t, 2),
                      e = _t23[0],
                      n = _t23[1],
                      i = _this38.scroll.find(e, !0),
                      s = i.offset(_this38.scroll);
                    return 0 === n ? s : i instanceof r.LeafBlot ? s + i.index(e, n) : s + i.length();
                  }),
                  i = Math.min(Math.max.apply(Math, _toConsumableArray(n)), this.scroll.length() - 1),
                  s = Math.min.apply(Math, [i].concat(_toConsumableArray(n)));
                return new a(s, i - s);
              }
            }, {
              key: "normalizeNative",
              value: function normalizeNative(t) {
                if (!c(this.root, t.startContainer) || !t.collapsed && !c(this.root, t.endContainer)) return null;
                var e = {
                  start: {
                    node: t.startContainer,
                    offset: t.startOffset
                  },
                  end: {
                    node: t.endContainer,
                    offset: t.endOffset
                  },
                  "native": t
                };
                return [e.start, e.end].forEach(function (t) {
                  var e = t.node,
                    n = t.offset;
                  for (; !(e instanceof Text) && e.childNodes.length > 0;) if (e.childNodes.length > n) e = e.childNodes[n], n = 0;else {
                    if (e.childNodes.length !== n) break;
                    e = e.lastChild, n = e instanceof Text ? e.data.length : e.childNodes.length > 0 ? e.childNodes.length : e.childNodes.length + 1;
                  }
                  t.node = e, t.offset = n;
                }), e;
              }
            }, {
              key: "rangeToNative",
              value: function rangeToNative(t) {
                var _this39 = this;
                var e = this.scroll.length(),
                  n = function n(t, _n12) {
                    t = Math.min(e - 1, t);
                    var _this39$scroll$leaf = _this39.scroll.leaf(t),
                      _this39$scroll$leaf2 = _slicedToArray(_this39$scroll$leaf, 2),
                      r = _this39$scroll$leaf2[0],
                      i = _this39$scroll$leaf2[1];
                    return r ? r.position(i, _n12) : [null, -1];
                  };
                return [].concat(_toConsumableArray(n(t.index, !1)), _toConsumableArray(n(t.index + t.length, !0)));
              }
            }, {
              key: "setNativeRange",
              value: function setNativeRange(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,
                  r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e,
                  i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                if (l.info("setNativeRange", t, e, n, r), null != t && (null == this.root.parentNode || null == t.parentNode || null == n.parentNode)) return;
                var s = document.getSelection();
                if (null != s) if (null != t) {
                  this.hasFocus() || this.root.focus({
                    preventScroll: !0
                  });
                  var _ref = this.getNativeRange() || {},
                    _o9 = _ref["native"];
                  if (null == _o9 || i || t !== _o9.startContainer || e !== _o9.startOffset || n !== _o9.endContainer || r !== _o9.endOffset) {
                    t instanceof Element && "BR" === t.tagName && (e = Array.from(t.parentNode.childNodes).indexOf(t), t = t.parentNode), n instanceof Element && "BR" === n.tagName && (r = Array.from(n.parentNode.childNodes).indexOf(n), n = n.parentNode);
                    var _i9 = document.createRange();
                    _i9.setStart(t, e), _i9.setEnd(n, r), s.removeAllRanges(), s.addRange(_i9);
                  }
                } else s.removeAllRanges(), this.root.blur();
              }
            }, {
              key: "setRange",
              value: function setRange(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                  n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o.A.sources.API;
                if ("string" == typeof e && (n = e, e = !1), l.info("setRange", t), null != t) {
                  var _n13 = this.rangeToNative(t);
                  this.setNativeRange.apply(this, _toConsumableArray(_n13).concat([e]));
                } else this.setNativeRange(null);
                this.update(n);
              }
            }, {
              key: "update",
              value: function update() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o.A.sources.USER;
                var e = this.lastRange,
                  _this$getRange = this.getRange(),
                  _this$getRange2 = _slicedToArray(_this$getRange, 2),
                  n = _this$getRange2[0],
                  r = _this$getRange2[1];
                if (this.lastRange = n, this.lastNative = r, null != this.lastRange && (this.savedRange = this.lastRange), !(0, i.A)(e, this.lastRange)) {
                  var _this$emitter6, _this$emitter7;
                  if (!this.composing && null != r && r["native"].collapsed && r.start.node !== this.cursor.textNode) {
                    var _t24 = this.cursor.restore();
                    _t24 && this.setNativeRange(_t24.startNode, _t24.startOffset, _t24.endNode, _t24.endOffset);
                  }
                  var _n14 = [o.A.events.SELECTION_CHANGE, (0, s.A)(this.lastRange), (0, s.A)(e), t];
                  (_this$emitter6 = this.emitter).emit.apply(_this$emitter6, [o.A.events.EDITOR_CHANGE].concat(_n14)), t !== o.A.sources.SILENT && (_this$emitter7 = this.emitter).emit.apply(_this$emitter7, _n14);
                }
              }
            }]);
          }();
        },
        9609: function _(t, e) {
          "use strict";

          var _n15;
          var n = /*#__PURE__*/function () {
            function n(t, e) {
              _classCallCheck(this, n);
              _defineProperty(this, "modules", {});
              this.quill = t, this.options = e;
            }
            return _createClass(n, [{
              key: "init",
              value: function init() {
                var _this40 = this;
                Object.keys(this.options.modules).forEach(function (t) {
                  null == _this40.modules[t] && _this40.addModule(t);
                });
              }
            }, {
              key: "addModule",
              value: function addModule(t) {
                var e = this.quill.constructor["import"]("modules/".concat(t));
                return this.modules[t] = new e(this.quill, this.options.modules[t] || {}), this.modules[t];
              }
            }]);
          }();
          _n15 = n;
          _defineProperty(n, "DEFAULTS", {
            modules: {}
          });
          _defineProperty(n, "themes", {
            "default": _n15
          });
          e.A = n;
        },
        8276: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Hu: function Hu() {
              return l;
            },
            gS: function gS() {
              return s;
            },
            qh: function qh() {
              return o;
            }
          });
          var r = n(6003);
          var i = {
              scope: r.Scope.BLOCK,
              whitelist: ["right", "center", "justify"]
            },
            s = new r.Attributor("align", "align", i),
            o = new r.ClassAttributor("align", "ql-align", i),
            l = new r.StyleAttributor("align", "text-align", i);
        },
        9541: function _(t, e, n) {
          "use strict";

          n.d(e, {
            l: function l() {
              return s;
            },
            s: function s() {
              return o;
            }
          });
          var r = n(6003),
            i = n(8638);
          var s = new r.ClassAttributor("background", "ql-bg", {
              scope: r.Scope.INLINE
            }),
            o = new i.a2("background", "background-color", {
              scope: r.Scope.INLINE
            });
        },
        9404: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Ay: function Ay() {
              return h;
            },
            Cy: function Cy() {
              return d;
            },
            EJ: function EJ() {
              return u;
            }
          });
          var r = n(9698),
            i = n(3036),
            s = n(4541),
            o = n(4850),
            l = n(5508),
            a = n(580),
            c = n(6142);
          var u = /*#__PURE__*/function (_a$A) {
            function u() {
              _classCallCheck(this, u);
              return _callSuper(this, u, arguments);
            }
            _inherits(u, _a$A);
            return _createClass(u, [{
              key: "code",
              value: function code(t, e) {
                return this.children.map(function (t) {
                  return t.length() <= 1 ? "" : t.domNode.innerText;
                }).join("\n").slice(t, t + e);
              }
            }, {
              key: "html",
              value: function html(t, e) {
                return "<pre>\n".concat((0, l.X)(this.code(t, e)), "\n</pre>");
              }
            }], [{
              key: "create",
              value: function create(t) {
                var e = _superPropGet(u, "create", this, 2)([t]);
                return e.setAttribute("spellcheck", "false"), e;
              }
            }]);
          }(a.A);
          var h = /*#__PURE__*/function (_r$Ay) {
            function h() {
              _classCallCheck(this, h);
              return _callSuper(this, h, arguments);
            }
            _inherits(h, _r$Ay);
            return _createClass(h, null, [{
              key: "register",
              value: function register() {
                c.Ay.register(u);
              }
            }]);
          }(r.Ay);
          _defineProperty(h, "TAB", "  ");
          var d = /*#__PURE__*/function (_o$A) {
            function d() {
              _classCallCheck(this, d);
              return _callSuper(this, d, arguments);
            }
            _inherits(d, _o$A);
            return _createClass(d);
          }(o.A);
          d.blotName = "code", d.tagName = "CODE", h.blotName = "code-block", h.className = "ql-code-block", h.tagName = "DIV", u.blotName = "code-block-container", u.className = "ql-code-block-container", u.tagName = "DIV", u.allowedChildren = [h], h.allowedChildren = [l.A, i.A, s.A], h.requiredContainer = u;
        },
        8638: function _(t, e, n) {
          "use strict";

          n.d(e, {
            JM: function JM() {
              return o;
            },
            a2: function a2() {
              return i;
            },
            g3: function g3() {
              return s;
            }
          });
          var r = n(6003);
          var i = /*#__PURE__*/function (_r$StyleAttributor) {
            function i() {
              _classCallCheck(this, i);
              return _callSuper(this, i, arguments);
            }
            _inherits(i, _r$StyleAttributor);
            return _createClass(i, [{
              key: "value",
              value: function value(t) {
                var e = _superPropGet(i, "value", this, 3)([t]);
                return e.startsWith("rgb(") ? (e = e.replace(/^[^\d]+/, "").replace(/[^\d]+$/, ""), "#".concat(e.split(",").map(function (t) {
                  return "00".concat(parseInt(t, 10).toString(16)).slice(-2);
                }).join(""))) : e;
              }
            }]);
          }(r.StyleAttributor);
          var s = new r.ClassAttributor("color", "ql-color", {
              scope: r.Scope.INLINE
            }),
            o = new i("color", "color", {
              scope: r.Scope.INLINE
            });
        },
        7912: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Mc: function Mc() {
              return s;
            },
            VL: function VL() {
              return l;
            },
            sY: function sY() {
              return o;
            }
          });
          var r = n(6003);
          var i = {
              scope: r.Scope.BLOCK,
              whitelist: ["rtl"]
            },
            s = new r.Attributor("direction", "dir", i),
            o = new r.ClassAttributor("direction", "ql-direction", i),
            l = new r.StyleAttributor("direction", "direction", i);
        },
        6772: function _(t, e, n) {
          "use strict";

          n.d(e, {
            q: function q() {
              return s;
            },
            z: function z() {
              return l;
            }
          });
          var r = n(6003);
          var i = {
              scope: r.Scope.INLINE,
              whitelist: ["serif", "monospace"]
            },
            s = new r.ClassAttributor("font", "ql-font", i);
          var o = /*#__PURE__*/function (_r$StyleAttributor2) {
            function o() {
              _classCallCheck(this, o);
              return _callSuper(this, o, arguments);
            }
            _inherits(o, _r$StyleAttributor2);
            return _createClass(o, [{
              key: "value",
              value: function value(t) {
                return _superPropGet(o, "value", this, 3)([t]).replace(/["']/g, "");
              }
            }]);
          }(r.StyleAttributor);
          var l = new o("font", "font-family", i);
        },
        664: function _(t, e, n) {
          "use strict";

          n.d(e, {
            U: function U() {
              return i;
            },
            r: function r() {
              return s;
            }
          });
          var r = n(6003);
          var i = new r.ClassAttributor("size", "ql-size", {
              scope: r.Scope.INLINE,
              whitelist: ["small", "large", "huge"]
            }),
            s = new r.StyleAttributor("size", "font-size", {
              scope: r.Scope.INLINE,
              whitelist: ["10px", "18px", "32px"]
            });
        },
        584: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Ay: function Ay() {
              return S;
            },
            hV: function hV() {
              return I;
            }
          });
          var r = n(6003),
            i = n(5232),
            s = n.n(i),
            o = n(9698),
            l = n(6078),
            a = n(4266),
            c = n(6142),
            u = n(8276),
            h = n(9541),
            d = n(9404),
            f = n(8638),
            p = n(7912),
            g = n(6772),
            m = n(664),
            b = n(8123);
          var y = /font-weight:\s*normal/,
            v = ["P", "OL", "UL"],
            A = function A(t) {
              return t && v.includes(t.tagName);
            },
            x = /\bmso-list:[^;]*ignore/i,
            N = /\bmso-list:[^;]*\bl(\d+)/i,
            E = /\bmso-list:[^;]*\blevel(\d+)/i,
            w = [function (t) {
              "urn:schemas-microsoft-com:office:word" === t.documentElement.getAttribute("xmlns:w") && function (t) {
                var e = Array.from(t.querySelectorAll("[style*=mso-list]")),
                  n = [],
                  r = [];
                e.forEach(function (t) {
                  (t.getAttribute("style") || "").match(x) ? n.push(t) : r.push(t);
                }), n.forEach(function (t) {
                  var _t$parentNode;
                  return (_t$parentNode = t.parentNode) === null || _t$parentNode === void 0 ? void 0 : _t$parentNode.removeChild(t);
                });
                var i = t.documentElement.innerHTML,
                  s = r.map(function (t) {
                    return function (t, e) {
                      var n = t.getAttribute("style"),
                        r = n === null || n === void 0 ? void 0 : n.match(N);
                      if (!r) return null;
                      var i = Number(r[1]),
                        s = n === null || n === void 0 ? void 0 : n.match(E),
                        o = s ? Number(s[1]) : 1,
                        l = new RegExp("@list l".concat(i, ":level").concat(o, "\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)"), "i"),
                        a = e.match(l);
                      return {
                        id: i,
                        indent: o,
                        type: a && "bullet" === a[1] ? "bullet" : "ordered",
                        element: t
                      };
                    }(t, i);
                  }).filter(function (t) {
                    return t;
                  });
                var _loop = function _loop() {
                  var _t$;
                  var t = [];
                  var e = s.shift();
                  for (; e;) {
                    var _s$;
                    t.push(e), e = s.length && ((_s$ = s[0]) === null || _s$ === void 0 ? void 0 : _s$.element) === e.element.nextElementSibling && s[0].id === e.id ? s.shift() : null;
                  }
                  var n = document.createElement("ul");
                  t.forEach(function (t) {
                    var e = document.createElement("li");
                    e.setAttribute("data-list", t.type), t.indent > 1 && e.setAttribute("class", "ql-indent-" + (t.indent - 1)), e.innerHTML = t.element.innerHTML, n.appendChild(e);
                  });
                  var r = (_t$ = t[0]) === null || _t$ === void 0 ? void 0 : _t$.element,
                    _ref2 = r !== null && r !== void 0 ? r : {},
                    i = _ref2.parentNode;
                  r && i !== null && i !== void 0 && i.replaceChild(n, r), t.slice(1).forEach(function (t) {
                    var e = t.element;
                    i === null || i === void 0 || i.removeChild(e);
                  });
                };
                for (; s.length;) {
                  _loop();
                }
              }(t);
            }, function (t) {
              t.querySelector('[id^="docs-internal-guid-"]') && (function (t) {
                Array.from(t.querySelectorAll('b[style*="font-weight"]')).filter(function (t) {
                  var _t$getAttribute;
                  return (_t$getAttribute = t.getAttribute("style")) === null || _t$getAttribute === void 0 ? void 0 : _t$getAttribute.match(y);
                }).forEach(function (e) {
                  var _e$parentNode;
                  var n = t.createDocumentFragment();
                  n.append.apply(n, _toConsumableArray(e.childNodes)), (_e$parentNode = e.parentNode) === null || _e$parentNode === void 0 ? void 0 : _e$parentNode.replaceChild(n, e);
                });
              }(t), function (t) {
                Array.from(t.querySelectorAll("br")).filter(function (t) {
                  return A(t.previousElementSibling) && A(t.nextElementSibling);
                }).forEach(function (t) {
                  var _t$parentNode2;
                  (_t$parentNode2 = t.parentNode) === null || _t$parentNode2 === void 0 || _t$parentNode2.removeChild(t);
                });
              }(t));
            }];
          var q = (0, l.A)("quill:clipboard"),
            k = [[Node.TEXT_NODE, function (t, e, n) {
              var _t$parentElement;
              var r = t.data;
              if ("O:P" === ((_t$parentElement = t.parentElement) === null || _t$parentElement === void 0 ? void 0 : _t$parentElement.tagName)) return e.insert(r.trim());
              if (!R(t)) {
                if (0 === r.trim().length && r.includes("\n") && !function (t, e) {
                  return t.previousElementSibling && t.nextElementSibling && !j(t.previousElementSibling, e) && !j(t.nextElementSibling, e);
                }(t, n)) return e;
                var _i0 = function _i0(t, e) {
                  var n = e.replace(/[^\u00a0]/g, "");
                  return n.length < 1 && t ? " " : n;
                };
                r = r.replace(/\r\n/g, " ").replace(/\n/g, " "), r = r.replace(/\s\s+/g, _i0.bind(_i0, !0)), (null == t.previousSibling && null != t.parentElement && j(t.parentElement, n) || t.previousSibling instanceof Element && j(t.previousSibling, n)) && (r = r.replace(/^\s+/, _i0.bind(_i0, !1))), (null == t.nextSibling && null != t.parentElement && j(t.parentElement, n) || t.nextSibling instanceof Element && j(t.nextSibling, n)) && (r = r.replace(/\s+$/, _i0.bind(_i0, !1)));
              }
              return e.insert(r);
            }], [Node.TEXT_NODE, M], ["br", function (t, e) {
              return T(e, "\n") || e.insert("\n"), e;
            }], [Node.ELEMENT_NODE, M], [Node.ELEMENT_NODE, function (t, e, n) {
              var i = n.query(t);
              if (null == i) return e;
              if (i.prototype instanceof r.EmbedBlot) {
                var _e16 = {},
                  _r10 = i.value(t);
                if (null != _r10) return _e16[i.blotName] = _r10, new (s())().insert(_e16, i.formats(t, n));
              } else if (i.prototype instanceof r.BlockBlot && !T(e, "\n") && e.insert("\n"), "blotName" in i && "formats" in i && "function" == typeof i.formats) return O(e, i.blotName, i.formats(t, n), n);
              return e;
            }], [Node.ELEMENT_NODE, function (t, e, n) {
              var i = r.Attributor.keys(t),
                s = r.ClassAttributor.keys(t),
                o = r.StyleAttributor.keys(t),
                l = {};
              return i.concat(s).concat(o).forEach(function (e) {
                var i = n.query(e, r.Scope.ATTRIBUTE);
                null != i && (l[i.attrName] = i.value(t), l[i.attrName]) || (i = _[e], null == i || i.attrName !== e && i.keyName !== e || (l[i.attrName] = i.value(t) || void 0), i = L[e], null == i || i.attrName !== e && i.keyName !== e || (i = L[e], l[i.attrName] = i.value(t) || void 0));
              }), Object.entries(l).reduce(function (t, e) {
                var _e17 = _slicedToArray(e, 2),
                  r = _e17[0],
                  i = _e17[1];
                return O(t, r, i, n);
              }, e);
            }], [Node.ELEMENT_NODE, function (t, e, n) {
              var _i$fontWeight;
              var r = {},
                i = t.style || {};
              return "italic" === i.fontStyle && (r.italic = !0), "underline" === i.textDecoration && (r.underline = !0), "line-through" === i.textDecoration && (r.strike = !0), ((_i$fontWeight = i.fontWeight) !== null && _i$fontWeight !== void 0 && _i$fontWeight.startsWith("bold") || parseInt(i.fontWeight, 10) >= 700) && (r.bold = !0), e = Object.entries(r).reduce(function (t, e) {
                var _e18 = _slicedToArray(e, 2),
                  r = _e18[0],
                  i = _e18[1];
                return O(t, r, i, n);
              }, e), parseFloat(i.textIndent || 0) > 0 ? new (s())().insert("\t").concat(e) : e;
            }], ["li", function (t, e, n) {
              var r = n.query(t);
              if (null == r || "list" !== r.blotName || !T(e, "\n")) return e;
              var i = -1,
                o = t.parentNode;
              for (; null != o;) ["OL", "UL"].includes(o.tagName) && (i += 1), o = o.parentNode;
              return i <= 0 ? e : e.reduce(function (t, e) {
                return e.insert ? e.attributes && "number" == typeof e.attributes.indent ? t.push(e) : t.insert(e.insert, _objectSpread({
                  indent: i
                }, e.attributes || {})) : t;
              }, new (s())());
            }], ["ol, ul", function (t, e, n) {
              var r = t;
              var i = "OL" === r.tagName ? "ordered" : "bullet";
              var s = r.getAttribute("data-checked");
              return s && (i = "true" === s ? "checked" : "unchecked"), O(e, "list", i, n);
            }], ["pre", function (t, e, n) {
              var r = n.query("code-block");
              return O(e, "code-block", !r || !("formats" in r) || "function" != typeof r.formats || r.formats(t, n), n);
            }], ["tr", function (t, e, n) {
              var _t$parentElement2, _t$parentElement3;
              var r = "TABLE" === ((_t$parentElement2 = t.parentElement) === null || _t$parentElement2 === void 0 ? void 0 : _t$parentElement2.tagName) ? t.parentElement : (_t$parentElement3 = t.parentElement) === null || _t$parentElement3 === void 0 ? void 0 : _t$parentElement3.parentElement;
              return null != r ? O(e, "table", Array.from(r.querySelectorAll("tr")).indexOf(t) + 1, n) : e;
            }], ["b", B("bold")], ["i", B("italic")], ["strike", B("strike")], ["style", function () {
              return new (s())();
            }]],
            _ = [u.gS, p.Mc].reduce(function (t, e) {
              return t[e.keyName] = e, t;
            }, {}),
            L = [u.Hu, h.s, f.JM, p.VL, g.z, m.r].reduce(function (t, e) {
              return t[e.keyName] = e, t;
            }, {});
          var S = /*#__PURE__*/function (_a$A2) {
            function S(t, e) {
              var _this41$options$match;
              var _this41;
              _classCallCheck(this, S);
              _this41 = _callSuper(this, S, [t, e]), _this41.quill.root.addEventListener("copy", function (t) {
                return _this41.onCaptureCopy(t, !1);
              }), _this41.quill.root.addEventListener("cut", function (t) {
                return _this41.onCaptureCopy(t, !0);
              }), _this41.quill.root.addEventListener("paste", _this41.onCapturePaste.bind(_assertThisInitialized(_this41))), _this41.matchers = [], k.concat((_this41$options$match = _this41.options.matchers) !== null && _this41$options$match !== void 0 ? _this41$options$match : []).forEach(function (t) {
                var _t25 = _slicedToArray(t, 2),
                  e = _t25[0],
                  n = _t25[1];
                _this41.addMatcher(e, n);
              });
              return _this41;
            }
            _inherits(S, _a$A2);
            return _createClass(S, [{
              key: "addMatcher",
              value: function addMatcher(t, e) {
                this.matchers.push([t, e]);
              }
            }, {
              key: "convert",
              value: function convert(t) {
                var e = t.html,
                  n = t.text,
                  r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (r[d.Ay.blotName]) return new (s())().insert(n || "", _defineProperty({}, d.Ay.blotName, r[d.Ay.blotName]));
                if (!e) return new (s())().insert(n || "", r);
                var i = this.convertHTML(e);
                return T(i, "\n") && (null == i.ops[i.ops.length - 1].attributes || r.table) ? i.compose(new (s())().retain(i.length() - 1)["delete"](1)) : i;
              }
            }, {
              key: "normalizeHTML",
              value: function normalizeHTML(t) {
                (function (t) {
                  t.documentElement && w.forEach(function (e) {
                    e(t);
                  });
                })(t);
              }
            }, {
              key: "convertHTML",
              value: function convertHTML(t) {
                var e = new DOMParser().parseFromString(t, "text/html");
                this.normalizeHTML(e);
                var n = e.body,
                  r = new WeakMap(),
                  _this$prepareMatching = this.prepareMatching(n, r),
                  _this$prepareMatching2 = _slicedToArray(_this$prepareMatching, 2),
                  i = _this$prepareMatching2[0],
                  s = _this$prepareMatching2[1];
                return I(this.quill.scroll, n, i, s, r);
              }
            }, {
              key: "dangerouslyPasteHTML",
              value: function dangerouslyPasteHTML(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : c.Ay.sources.API;
                if ("string" == typeof t) {
                  var _n16 = this.convert({
                    html: t,
                    text: ""
                  });
                  this.quill.setContents(_n16, e), this.quill.setSelection(0, c.Ay.sources.SILENT);
                } else {
                  var _r11 = this.convert({
                    html: e,
                    text: ""
                  });
                  this.quill.updateContents(new (s())().retain(t).concat(_r11), n), this.quill.setSelection(t + _r11.length(), c.Ay.sources.SILENT);
                }
              }
            }, {
              key: "onCaptureCopy",
              value: function onCaptureCopy(t) {
                var _t$clipboardData, _t$clipboardData2;
                var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (t.defaultPrevented) return;
                t.preventDefault();
                var _this$quill$selection = this.quill.selection.getRange(),
                  _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
                  n = _this$quill$selection2[0];
                if (null == n) return;
                var _this$onCopy = this.onCopy(n, e),
                  r = _this$onCopy.html,
                  i = _this$onCopy.text;
                (_t$clipboardData = t.clipboardData) !== null && _t$clipboardData !== void 0 && _t$clipboardData.setData("text/plain", i), (_t$clipboardData2 = t.clipboardData) !== null && _t$clipboardData2 !== void 0 && _t$clipboardData2.setData("text/html", r), e && (0, b.Xo)({
                  range: n,
                  quill: this.quill
                });
              }
            }, {
              key: "normalizeURIList",
              value: function normalizeURIList(t) {
                return t.split(/\r?\n/).filter(function (t) {
                  return "#" !== t[0];
                }).join("\n");
              }
            }, {
              key: "onCapturePaste",
              value: function onCapturePaste(t) {
                var _t$clipboardData3, _t$clipboardData4, _t$clipboardData6;
                if (t.defaultPrevented || !this.quill.isEnabled()) return;
                t.preventDefault();
                var e = this.quill.getSelection(!0);
                if (null == e) return;
                var n = (_t$clipboardData3 = t.clipboardData) === null || _t$clipboardData3 === void 0 ? void 0 : _t$clipboardData3.getData("text/html");
                var r = (_t$clipboardData4 = t.clipboardData) === null || _t$clipboardData4 === void 0 ? void 0 : _t$clipboardData4.getData("text/plain");
                if (!n && !r) {
                  var _t$clipboardData5;
                  var _e19 = (_t$clipboardData5 = t.clipboardData) === null || _t$clipboardData5 === void 0 ? void 0 : _t$clipboardData5.getData("text/uri-list");
                  _e19 && (r = this.normalizeURIList(_e19));
                }
                var i = Array.from(((_t$clipboardData6 = t.clipboardData) === null || _t$clipboardData6 === void 0 ? void 0 : _t$clipboardData6.files) || []);
                if (!n && i.length > 0) this.quill.uploader.upload(e, i);else {
                  if (n && i.length > 0) {
                    var _t26$body$firstElemen;
                    var _t26 = new DOMParser().parseFromString(n, "text/html");
                    if (1 === _t26.body.childElementCount && "IMG" === ((_t26$body$firstElemen = _t26.body.firstElementChild) === null || _t26$body$firstElemen === void 0 ? void 0 : _t26$body$firstElemen.tagName)) return void this.quill.uploader.upload(e, i);
                  }
                  this.onPaste(e, {
                    html: n,
                    text: r
                  });
                }
              }
            }, {
              key: "onCopy",
              value: function onCopy(t) {
                var e = this.quill.getText(t);
                return {
                  html: this.quill.getSemanticHTML(t),
                  text: e
                };
              }
            }, {
              key: "onPaste",
              value: function onPaste(t, e) {
                var n = e.text,
                  r = e.html;
                var i = this.quill.getFormat(t.index),
                  o = this.convert({
                    text: n,
                    html: r
                  }, i);
                q.log("onPaste", o, {
                  text: n,
                  html: r
                });
                var l = new (s())().retain(t.index)["delete"](t.length).concat(o);
                this.quill.updateContents(l, c.Ay.sources.USER), this.quill.setSelection(l.length() - t.length, c.Ay.sources.SILENT), this.quill.scrollSelectionIntoView();
              }
            }, {
              key: "prepareMatching",
              value: function prepareMatching(t, e) {
                var n = [],
                  r = [];
                return this.matchers.forEach(function (i) {
                  var _i1 = _slicedToArray(i, 2),
                    s = _i1[0],
                    o = _i1[1];
                  switch (s) {
                    case Node.TEXT_NODE:
                      r.push(o);
                      break;
                    case Node.ELEMENT_NODE:
                      n.push(o);
                      break;
                    default:
                      Array.from(t.querySelectorAll(s)).forEach(function (t) {
                        if (e.has(t)) {
                          var _n17 = e.get(t);
                          _n17 === null || _n17 === void 0 || _n17.push(o);
                        } else e.set(t, [o]);
                      });
                  }
                }), [n, r];
              }
            }]);
          }(a.A);
          _defineProperty(S, "DEFAULTS", {
            matchers: []
          });
          function O(t, e, n, r) {
            return r.query(e) ? t.reduce(function (t, r) {
              if (!r.insert) return t;
              if (r.attributes && r.attributes[e]) return t.push(r);
              var i = n ? _defineProperty({}, e, n) : {};
              return t.insert(r.insert, _objectSpread(_objectSpread({}, i), r.attributes));
            }, new (s())()) : t;
          }
          function T(t, e) {
            var n = "";
            for (var _r12 = t.ops.length - 1; _r12 >= 0 && n.length < e.length; --_r12) {
              var _e20 = t.ops[_r12];
              if ("string" != typeof _e20.insert) break;
              n = _e20.insert + n;
            }
            return n.slice(-1 * e.length) === e;
          }
          function j(t, e) {
            if (!(t instanceof Element)) return !1;
            var n = e.query(t);
            return !(n && n.prototype instanceof r.EmbedBlot) && ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(t.tagName.toLowerCase());
          }
          var C = new WeakMap();
          function R(t) {
            return null != t && (C.has(t) || ("PRE" === t.tagName ? C.set(t, !0) : C.set(t, R(t.parentNode))), C.get(t));
          }
          function I(t, e, n, r, i) {
            return e.nodeType === e.TEXT_NODE ? r.reduce(function (n, r) {
              return r(e, n, t);
            }, new (s())()) : e.nodeType === e.ELEMENT_NODE ? Array.from(e.childNodes || []).reduce(function (s, o) {
              var l = I(t, o, n, r, i);
              return o.nodeType === e.ELEMENT_NODE && (l = n.reduce(function (e, n) {
                return n(o, e, t);
              }, l), l = (i.get(o) || []).reduce(function (e, n) {
                return n(o, e, t);
              }, l)), s.concat(l);
            }, new (s())()) : new (s())();
          }
          function B(t) {
            return function (e, n, r) {
              return O(n, t, !0, r);
            };
          }
          function M(t, e, n) {
            if (!T(e, "\n")) {
              if (j(t, n) && (t.childNodes.length > 0 || t instanceof HTMLParagraphElement)) return e.insert("\n");
              if (e.length() > 0 && t.nextSibling) {
                var _r13 = t.nextSibling;
                for (; null != _r13;) {
                  if (j(_r13, n)) return e.insert("\n");
                  var _t27 = n.query(_r13);
                  if (_t27 && _t27.prototype instanceof o.zo) return e.insert("\n");
                  _r13 = _r13.firstChild;
                }
              }
            }
            return e;
          }
        },
        8123: function _(t, e, n) {
          "use strict";

          n.d(e, {
            Ay: function Ay() {
              return f;
            },
            Xo: function Xo() {
              return v;
            }
          });
          var r = n(5123),
            i = n(3707),
            s = n(5232),
            o = n.n(s),
            l = n(6003),
            a = n(6142),
            c = n(6078),
            u = n(4266);
          var h = (0, c.A)("quill:keyboard"),
            d = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
          var f = /*#__PURE__*/function (_u$A) {
            function f(t, e) {
              var _this42;
              _classCallCheck(this, f);
              _this42 = _callSuper(this, f, [t, e]), _this42.bindings = {}, Object.keys(_this42.options.bindings).forEach(function (t) {
                _this42.options.bindings[t] && _this42.addBinding(_this42.options.bindings[t]);
              }), _this42.addBinding({
                key: "Enter",
                shiftKey: null
              }, _this42.handleEnter), _this42.addBinding({
                key: "Enter",
                metaKey: null,
                ctrlKey: null,
                altKey: null
              }, function () {}), /Firefox/i.test(navigator.userAgent) ? (_this42.addBinding({
                key: "Backspace"
              }, {
                collapsed: !0
              }, _this42.handleBackspace), _this42.addBinding({
                key: "Delete"
              }, {
                collapsed: !0
              }, _this42.handleDelete)) : (_this42.addBinding({
                key: "Backspace"
              }, {
                collapsed: !0,
                prefix: /^.?$/
              }, _this42.handleBackspace), _this42.addBinding({
                key: "Delete"
              }, {
                collapsed: !0,
                suffix: /^.?$/
              }, _this42.handleDelete)), _this42.addBinding({
                key: "Backspace"
              }, {
                collapsed: !1
              }, _this42.handleDeleteRange), _this42.addBinding({
                key: "Delete"
              }, {
                collapsed: !1
              }, _this42.handleDeleteRange), _this42.addBinding({
                key: "Backspace",
                altKey: null,
                ctrlKey: null,
                metaKey: null,
                shiftKey: null
              }, {
                collapsed: !0,
                offset: 0
              }, _this42.handleBackspace), _this42.listen();
              return _this42;
            }
            _inherits(f, _u$A);
            return _createClass(f, [{
              key: "addBinding",
              value: function addBinding(t) {
                var _this43 = this;
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                  n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                var r = function (t) {
                  if ("string" == typeof t || "number" == typeof t) t = {
                    key: t
                  };else {
                    if ("object" != _typeof(t)) return null;
                    t = (0, i.A)(t);
                  }
                  return t.shortKey && (t[d] = t.shortKey, delete t.shortKey), t;
                }(t);
                null != r ? ("function" == typeof e && (e = {
                  handler: e
                }), "function" == typeof n && (n = {
                  handler: n
                }), (Array.isArray(r.key) ? r.key : [r.key]).forEach(function (t) {
                  var i = _objectSpread(_objectSpread(_objectSpread({}, r), {}, {
                    key: t
                  }, e), n);
                  _this43.bindings[i.key] = _this43.bindings[i.key] || [], _this43.bindings[i.key].push(i);
                })) : h.warn("Attempted to add invalid keyboard binding", r);
              }
            }, {
              key: "listen",
              value: function listen() {
                var _this44 = this;
                this.quill.root.addEventListener("keydown", function (t) {
                  if (t.defaultPrevented || t.isComposing) return;
                  var e = (_this44.bindings[t.key] || []).concat(_this44.bindings[t.which] || []).filter(function (e) {
                    return f.match(t, e);
                  });
                  if (0 === e.length) return;
                  var n = a.Ay.find(t.target, !0);
                  if (n && n.scroll !== _this44.quill.scroll) return;
                  var i = _this44.quill.getSelection();
                  if (null == i || !_this44.quill.hasFocus()) return;
                  var _this44$quill$getLine = _this44.quill.getLine(i.index),
                    _this44$quill$getLine2 = _slicedToArray(_this44$quill$getLine, 2),
                    s = _this44$quill$getLine2[0],
                    o = _this44$quill$getLine2[1],
                    _this44$quill$getLeaf = _this44.quill.getLeaf(i.index),
                    _this44$quill$getLeaf2 = _slicedToArray(_this44$quill$getLeaf, 2),
                    c = _this44$quill$getLeaf2[0],
                    u = _this44$quill$getLeaf2[1],
                    _ref4 = 0 === i.length ? [c, u] : _this44.quill.getLeaf(i.index + i.length),
                    _ref5 = _slicedToArray(_ref4, 2),
                    h = _ref5[0],
                    d = _ref5[1],
                    p = c instanceof l.TextBlot ? c.value().slice(0, u) : "",
                    g = h instanceof l.TextBlot ? h.value().slice(d) : "",
                    m = {
                      collapsed: 0 === i.length,
                      empty: 0 === i.length && s.length() <= 1,
                      format: _this44.quill.getFormat(i),
                      line: s,
                      offset: o,
                      prefix: p,
                      suffix: g,
                      event: t
                    };
                  e.some(function (t) {
                    if (null != t.collapsed && t.collapsed !== m.collapsed) return !1;
                    if (null != t.empty && t.empty !== m.empty) return !1;
                    if (null != t.offset && t.offset !== m.offset) return !1;
                    if (Array.isArray(t.format)) {
                      if (t.format.every(function (t) {
                        return null == m.format[t];
                      })) return !1;
                    } else if ("object" == _typeof(t.format) && !Object.keys(t.format).every(function (e) {
                      return !0 === t.format[e] ? null != m.format[e] : !1 === t.format[e] ? null == m.format[e] : (0, r.A)(t.format[e], m.format[e]);
                    })) return !1;
                    return !(null != t.prefix && !t.prefix.test(m.prefix) || null != t.suffix && !t.suffix.test(m.suffix) || !0 === t.handler.call(_this44, i, m, t));
                  }) && t.preventDefault();
                });
              }
            }, {
              key: "handleBackspace",
              value: function handleBackspace(t, e) {
                var n = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e.prefix) ? 2 : 1;
                if (0 === t.index || this.quill.getLength() <= 1) return;
                var r = {};
                var _this$quill$getLine = this.quill.getLine(t.index),
                  _this$quill$getLine2 = _slicedToArray(_this$quill$getLine, 1),
                  i = _this$quill$getLine2[0];
                var l = new (o())().retain(t.index - n)["delete"](n);
                if (0 === e.offset) {
                  var _this$quill$getLine3 = this.quill.getLine(t.index - 1),
                    _this$quill$getLine4 = _slicedToArray(_this$quill$getLine3, 1),
                    _e21 = _this$quill$getLine4[0];
                  if (_e21 && !("block" === _e21.statics.blotName && _e21.length() <= 1)) {
                    var _e22 = i.formats(),
                      _n18 = this.quill.getFormat(t.index - 1, 1);
                    if (r = s.AttributeMap.diff(_e22, _n18) || {}, Object.keys(r).length > 0) {
                      var _e23 = new (o())().retain(t.index + i.length() - 2).retain(1, r);
                      l = l.compose(_e23);
                    }
                  }
                }
                this.quill.updateContents(l, a.Ay.sources.USER), this.quill.focus();
              }
            }, {
              key: "handleDelete",
              value: function handleDelete(t, e) {
                var n = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e.suffix) ? 2 : 1;
                if (t.index >= this.quill.getLength() - n) return;
                var r = {};
                var _this$quill$getLine5 = this.quill.getLine(t.index),
                  _this$quill$getLine6 = _slicedToArray(_this$quill$getLine5, 1),
                  i = _this$quill$getLine6[0];
                var l = new (o())().retain(t.index)["delete"](n);
                if (e.offset >= i.length() - 1) {
                  var _this$quill$getLine7 = this.quill.getLine(t.index + 1),
                    _this$quill$getLine8 = _slicedToArray(_this$quill$getLine7, 1),
                    _e24 = _this$quill$getLine8[0];
                  if (_e24) {
                    var _n19 = i.formats(),
                      _o0 = this.quill.getFormat(t.index, 1);
                    r = s.AttributeMap.diff(_n19, _o0) || {}, Object.keys(r).length > 0 && (l = l.retain(_e24.length() - 1).retain(1, r));
                  }
                }
                this.quill.updateContents(l, a.Ay.sources.USER), this.quill.focus();
              }
            }, {
              key: "handleDeleteRange",
              value: function handleDeleteRange(t) {
                v({
                  range: t,
                  quill: this.quill
                }), this.quill.focus();
              }
            }, {
              key: "handleEnter",
              value: function handleEnter(t, e) {
                var _this45 = this;
                var n = Object.keys(e.format).reduce(function (t, n) {
                    return _this45.quill.scroll.query(n, l.Scope.BLOCK) && !Array.isArray(e.format[n]) && (t[n] = e.format[n]), t;
                  }, {}),
                  r = new (o())().retain(t.index)["delete"](t.length).insert("\n", n);
                this.quill.updateContents(r, a.Ay.sources.USER), this.quill.setSelection(t.index + 1, a.Ay.sources.SILENT), this.quill.focus();
              }
            }], [{
              key: "match",
              value: function match(t, e) {
                return !["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function (n) {
                  return !!e[n] !== t[n] && null !== e[n];
                }) && (e.key === t.key || e.key === t.which);
              }
            }]);
          }(u.A);
          var p = {
            bindings: {
              bold: b("bold"),
              italic: b("italic"),
              underline: b("underline"),
              indent: {
                key: "Tab",
                format: ["blockquote", "indent", "list"],
                handler: function handler(t, e) {
                  return !(!e.collapsed || 0 === e.offset) || (this.quill.format("indent", "+1", a.Ay.sources.USER), !1);
                }
              },
              outdent: {
                key: "Tab",
                shiftKey: !0,
                format: ["blockquote", "indent", "list"],
                handler: function handler(t, e) {
                  return !(!e.collapsed || 0 === e.offset) || (this.quill.format("indent", "-1", a.Ay.sources.USER), !1);
                }
              },
              "outdent backspace": {
                key: "Backspace",
                collapsed: !0,
                shiftKey: null,
                metaKey: null,
                ctrlKey: null,
                altKey: null,
                format: ["indent", "list"],
                offset: 0,
                handler: function handler(t, e) {
                  null != e.format.indent ? this.quill.format("indent", "-1", a.Ay.sources.USER) : null != e.format.list && this.quill.format("list", !1, a.Ay.sources.USER);
                }
              },
              "indent code-block": g(!0),
              "outdent code-block": g(!1),
              "remove tab": {
                key: "Tab",
                shiftKey: !0,
                collapsed: !0,
                prefix: /\t$/,
                handler: function handler(t) {
                  this.quill.deleteText(t.index - 1, 1, a.Ay.sources.USER);
                }
              },
              tab: {
                key: "Tab",
                handler: function handler(t, e) {
                  if (e.format.table) return !0;
                  this.quill.history.cutoff();
                  var n = new (o())().retain(t.index)["delete"](t.length).insert("\t");
                  return this.quill.updateContents(n, a.Ay.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index + 1, a.Ay.sources.SILENT), !1;
                }
              },
              "blockquote empty enter": {
                key: "Enter",
                collapsed: !0,
                format: ["blockquote"],
                empty: !0,
                handler: function handler() {
                  this.quill.format("blockquote", !1, a.Ay.sources.USER);
                }
              },
              "list empty enter": {
                key: "Enter",
                collapsed: !0,
                format: ["list"],
                empty: !0,
                handler: function handler(t, e) {
                  var n = {
                    list: !1
                  };
                  e.format.indent && (n.indent = !1), this.quill.formatLine(t.index, t.length, n, a.Ay.sources.USER);
                }
              },
              "checklist enter": {
                key: "Enter",
                collapsed: !0,
                format: {
                  list: "checked"
                },
                handler: function handler(t) {
                  var _this$quill$getLine9 = this.quill.getLine(t.index),
                    _this$quill$getLine0 = _slicedToArray(_this$quill$getLine9, 2),
                    e = _this$quill$getLine0[0],
                    n = _this$quill$getLine0[1],
                    r = _objectSpread(_objectSpread({}, e.formats()), {}, {
                      list: "checked"
                    }),
                    i = new (o())().retain(t.index).insert("\n", r).retain(e.length() - n - 1).retain(1, {
                      list: "unchecked"
                    });
                  this.quill.updateContents(i, a.Ay.sources.USER), this.quill.setSelection(t.index + 1, a.Ay.sources.SILENT), this.quill.scrollSelectionIntoView();
                }
              },
              "header enter": {
                key: "Enter",
                collapsed: !0,
                format: ["header"],
                suffix: /^$/,
                handler: function handler(t, e) {
                  var _this$quill$getLine1 = this.quill.getLine(t.index),
                    _this$quill$getLine10 = _slicedToArray(_this$quill$getLine1, 2),
                    n = _this$quill$getLine10[0],
                    r = _this$quill$getLine10[1],
                    i = new (o())().retain(t.index).insert("\n", e.format).retain(n.length() - r - 1).retain(1, {
                      header: null
                    });
                  this.quill.updateContents(i, a.Ay.sources.USER), this.quill.setSelection(t.index + 1, a.Ay.sources.SILENT), this.quill.scrollSelectionIntoView();
                }
              },
              "table backspace": {
                key: "Backspace",
                format: ["table"],
                collapsed: !0,
                offset: 0,
                handler: function handler() {}
              },
              "table delete": {
                key: "Delete",
                format: ["table"],
                collapsed: !0,
                suffix: /^$/,
                handler: function handler() {}
              },
              "table enter": {
                key: "Enter",
                shiftKey: null,
                format: ["table"],
                handler: function handler(t) {
                  var e = this.quill.getModule("table");
                  if (e) {
                    var _e$getTable = e.getTable(t),
                      _e$getTable2 = _slicedToArray(_e$getTable, 4),
                      _n20 = _e$getTable2[0],
                      _r14 = _e$getTable2[1],
                      _i10 = _e$getTable2[2],
                      _s7 = _e$getTable2[3],
                      _l8 = function (t, e, n, r) {
                        return null == e.prev && null == e.next ? null == n.prev && null == n.next ? 0 === r ? -1 : 1 : null == n.prev ? -1 : 1 : null == e.prev ? -1 : null == e.next ? 1 : null;
                      }(0, _r14, _i10, _s7);
                    if (null == _l8) return;
                    var _c2 = _n20.offset();
                    if (_l8 < 0) {
                      var _e25 = new (o())().retain(_c2).insert("\n");
                      this.quill.updateContents(_e25, a.Ay.sources.USER), this.quill.setSelection(t.index + 1, t.length, a.Ay.sources.SILENT);
                    } else if (_l8 > 0) {
                      _c2 += _n20.length();
                      var _t28 = new (o())().retain(_c2).insert("\n");
                      this.quill.updateContents(_t28, a.Ay.sources.USER), this.quill.setSelection(_c2, a.Ay.sources.USER);
                    }
                  }
                }
              },
              "table tab": {
                key: "Tab",
                shiftKey: null,
                format: ["table"],
                handler: function handler(t, e) {
                  var n = e.event,
                    r = e.line,
                    i = r.offset(this.quill.scroll);
                  n.shiftKey ? this.quill.setSelection(i - 1, a.Ay.sources.USER) : this.quill.setSelection(i + r.length(), a.Ay.sources.USER);
                }
              },
              "list autofill": {
                key: " ",
                shiftKey: null,
                collapsed: !0,
                format: {
                  "code-block": !1,
                  blockquote: !1,
                  table: !1
                },
                prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                handler: function handler(t, e) {
                  if (null == this.quill.scroll.query("list")) return !0;
                  var n = e.prefix.length,
                    _this$quill$getLine11 = this.quill.getLine(t.index),
                    _this$quill$getLine12 = _slicedToArray(_this$quill$getLine11, 2),
                    r = _this$quill$getLine12[0],
                    i = _this$quill$getLine12[1];
                  if (i > n) return !0;
                  var s;
                  switch (e.prefix.trim()) {
                    case "[]":
                    case "[ ]":
                      s = "unchecked";
                      break;
                    case "[x]":
                      s = "checked";
                      break;
                    case "-":
                    case "*":
                      s = "bullet";
                      break;
                    default:
                      s = "ordered";
                  }
                  this.quill.insertText(t.index, " ", a.Ay.sources.USER), this.quill.history.cutoff();
                  var l = new (o())().retain(t.index - i)["delete"](n + 1).retain(r.length() - 2 - i).retain(1, {
                    list: s
                  });
                  return this.quill.updateContents(l, a.Ay.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index - n, a.Ay.sources.SILENT), !1;
                }
              },
              "code exit": {
                key: "Enter",
                collapsed: !0,
                format: ["code-block"],
                prefix: /^$/,
                suffix: /^\s*$/,
                handler: function handler(t) {
                  var _this$quill$getLine13 = this.quill.getLine(t.index),
                    _this$quill$getLine14 = _slicedToArray(_this$quill$getLine13, 2),
                    e = _this$quill$getLine14[0],
                    n = _this$quill$getLine14[1];
                  var r = 2,
                    i = e;
                  for (; null != i && i.length() <= 1 && i.formats()["code-block"];) if (i = i.prev, r -= 1, r <= 0) {
                    var _r15 = new (o())().retain(t.index + e.length() - n - 2).retain(1, {
                      "code-block": null
                    })["delete"](1);
                    return this.quill.updateContents(_r15, a.Ay.sources.USER), this.quill.setSelection(t.index - 1, a.Ay.sources.SILENT), !1;
                  }
                  return !0;
                }
              },
              "embed left": m("ArrowLeft", !1),
              "embed left shift": m("ArrowLeft", !0),
              "embed right": m("ArrowRight", !1),
              "embed right shift": m("ArrowRight", !0),
              "table down": y(!1),
              "table up": y(!0)
            }
          };
          function g(t) {
            return {
              key: "Tab",
              shiftKey: !t,
              format: {
                "code-block": !0
              },
              handler: function handler(e, n) {
                var r = n.event;
                var i = this.quill.scroll.query("code-block"),
                  s = i.TAB;
                if (0 === e.length && !r.shiftKey) return this.quill.insertText(e.index, s, a.Ay.sources.USER), void this.quill.setSelection(e.index + s.length, a.Ay.sources.SILENT);
                var o = 0 === e.length ? this.quill.getLines(e.index, 1) : this.quill.getLines(e);
                var l = e.index,
                  c = e.length;
                o.forEach(function (e, n) {
                  t ? (e.insertAt(0, s), 0 === n ? l += s.length : c += s.length) : e.domNode.textContent.startsWith(s) && (e.deleteAt(0, s.length), 0 === n ? l -= s.length : c -= s.length);
                }), this.quill.update(a.Ay.sources.USER), this.quill.setSelection(l, c, a.Ay.sources.SILENT);
              }
            };
          }
          function m(t, e) {
            return _defineProperty(_defineProperty({
              key: t,
              shiftKey: e,
              altKey: null
            }, "ArrowLeft" === t ? "prefix" : "suffix", /^$/), "handler", function handler(n) {
              var r = n.index;
              "ArrowRight" === t && (r += n.length + 1);
              var _this$quill$getLeaf = this.quill.getLeaf(r),
                _this$quill$getLeaf2 = _slicedToArray(_this$quill$getLeaf, 1),
                i = _this$quill$getLeaf2[0];
              return !(i instanceof l.EmbedBlot && ("ArrowLeft" === t ? e ? this.quill.setSelection(n.index - 1, n.length + 1, a.Ay.sources.USER) : this.quill.setSelection(n.index - 1, a.Ay.sources.USER) : e ? this.quill.setSelection(n.index, n.length + 1, a.Ay.sources.USER) : this.quill.setSelection(n.index + n.length + 1, a.Ay.sources.USER), 1));
            });
          }
          function b(t) {
            return {
              key: t[0],
              shortKey: !0,
              handler: function handler(e, n) {
                this.quill.format(t, !n.format[t], a.Ay.sources.USER);
              }
            };
          }
          function y(t) {
            return {
              key: t ? "ArrowUp" : "ArrowDown",
              collapsed: !0,
              format: ["table"],
              handler: function handler(e, n) {
                var r = t ? "prev" : "next",
                  i = n.line,
                  s = i.parent[r];
                if (null != s) {
                  if ("table-row" === s.statics.blotName) {
                    var _t29 = s.children.head,
                      _e26 = i;
                    for (; null != _e26.prev;) _e26 = _e26.prev, _t29 = _t29.next;
                    var _r16 = _t29.offset(this.quill.scroll) + Math.min(n.offset, _t29.length() - 1);
                    this.quill.setSelection(_r16, 0, a.Ay.sources.USER);
                  }
                } else {
                  var _e27 = i.table()[r];
                  null != _e27 && (t ? this.quill.setSelection(_e27.offset(this.quill.scroll) + _e27.length() - 1, 0, a.Ay.sources.USER) : this.quill.setSelection(_e27.offset(this.quill.scroll), 0, a.Ay.sources.USER));
                }
                return !1;
              }
            };
          }
          function v(t) {
            var e = t.quill,
              n = t.range;
            var r = e.getLines(n);
            var i = {};
            if (r.length > 1) {
              var _t30 = r[0].formats(),
                _e28 = r[r.length - 1].formats();
              i = s.AttributeMap.diff(_e28, _t30) || {};
            }
            e.deleteText(n, a.Ay.sources.USER), Object.keys(i).length > 0 && e.formatLine(n.index, 1, i, a.Ay.sources.USER), e.setSelection(n.index, a.Ay.sources.SILENT);
          }
          f.DEFAULTS = p;
        },
        8920: function _(t) {
          "use strict";

          var e = Object.prototype.hasOwnProperty,
            n = "~";
          function r() {}
          function i(t, e, n) {
            this.fn = t, this.context = e, this.once = n || !1;
          }
          function s(t, e, r, s, o) {
            if ("function" != typeof r) throw new TypeError("The listener must be a function");
            var l = new i(r, s || t, o),
              a = n ? n + e : e;
            return t._events[a] ? t._events[a].fn ? t._events[a] = [t._events[a], l] : t._events[a].push(l) : (t._events[a] = l, t._eventsCount++), t;
          }
          function o(t, e) {
            0 == --t._eventsCount ? t._events = new r() : delete t._events[e];
          }
          function l() {
            this._events = new r(), this._eventsCount = 0;
          }
          Object.create && (r.prototype = Object.create(null), new r().__proto__ || (n = !1)), l.prototype.eventNames = function () {
            var t,
              r,
              i = [];
            if (0 === this._eventsCount) return i;
            for (r in t = this._events) e.call(t, r) && i.push(n ? r.slice(1) : r);
            return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i;
          }, l.prototype.listeners = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            if (!r) return [];
            if (r.fn) return [r.fn];
            for (var i = 0, s = r.length, o = new Array(s); i < s; i++) o[i] = r[i].fn;
            return o;
          }, l.prototype.listenerCount = function (t) {
            var e = n ? n + t : t,
              r = this._events[e];
            return r ? r.fn ? 1 : r.length : 0;
          }, l.prototype.emit = function (t, e, r, i, s, o) {
            var l = n ? n + t : t;
            if (!this._events[l]) return !1;
            var a,
              c,
              u = this._events[l],
              h = arguments.length;
            if (u.fn) {
              switch (u.once && this.removeListener(t, u.fn, void 0, !0), h) {
                case 1:
                  return u.fn.call(u.context), !0;
                case 2:
                  return u.fn.call(u.context, e), !0;
                case 3:
                  return u.fn.call(u.context, e, r), !0;
                case 4:
                  return u.fn.call(u.context, e, r, i), !0;
                case 5:
                  return u.fn.call(u.context, e, r, i, s), !0;
                case 6:
                  return u.fn.call(u.context, e, r, i, s, o), !0;
              }
              for (c = 1, a = new Array(h - 1); c < h; c++) a[c - 1] = arguments[c];
              u.fn.apply(u.context, a);
            } else {
              var d,
                f = u.length;
              for (c = 0; c < f; c++) switch (u[c].once && this.removeListener(t, u[c].fn, void 0, !0), h) {
                case 1:
                  u[c].fn.call(u[c].context);
                  break;
                case 2:
                  u[c].fn.call(u[c].context, e);
                  break;
                case 3:
                  u[c].fn.call(u[c].context, e, r);
                  break;
                case 4:
                  u[c].fn.call(u[c].context, e, r, i);
                  break;
                default:
                  if (!a) for (d = 1, a = new Array(h - 1); d < h; d++) a[d - 1] = arguments[d];
                  u[c].fn.apply(u[c].context, a);
              }
            }
            return !0;
          }, l.prototype.on = function (t, e, n) {
            return s(this, t, e, n, !1);
          }, l.prototype.once = function (t, e, n) {
            return s(this, t, e, n, !0);
          }, l.prototype.removeListener = function (t, e, r, i) {
            var s = n ? n + t : t;
            if (!this._events[s]) return this;
            if (!e) return o(this, s), this;
            var l = this._events[s];
            if (l.fn) l.fn !== e || i && !l.once || r && l.context !== r || o(this, s);else {
              for (var a = 0, c = [], u = l.length; a < u; a++) (l[a].fn !== e || i && !l[a].once || r && l[a].context !== r) && c.push(l[a]);
              c.length ? this._events[s] = 1 === c.length ? c[0] : c : o(this, s);
            }
            return this;
          }, l.prototype.removeAllListeners = function (t) {
            var e;
            return t ? (e = n ? n + t : t, this._events[e] && o(this, e)) : (this._events = new r(), this._eventsCount = 0), this;
          }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = n, l.EventEmitter = l, t.exports = l;
        },
        5090: function _(t) {
          var e = -1,
            n = 1,
            r = 0;
          function i(t, g, m, b, y) {
            if (t === g) return t ? [[r, t]] : [];
            if (null != m) {
              var A = function (t, e, n) {
                var r = "number" == typeof n ? {
                    index: n,
                    length: 0
                  } : n.oldRange,
                  i = "number" == typeof n ? null : n.newRange,
                  s = t.length,
                  o = e.length;
                if (0 === r.length && (null === i || 0 === i.length)) {
                  var l = r.index,
                    a = t.slice(0, l),
                    c = t.slice(l),
                    u = i ? i.index : null,
                    h = l + o - s;
                  if ((null === u || u === h) && !(h < 0 || h > o)) {
                    var d = e.slice(0, h);
                    if ((g = e.slice(h)) === c) {
                      var f = Math.min(l, h);
                      if ((b = a.slice(0, f)) === (A = d.slice(0, f))) return v(b, a.slice(f), d.slice(f), c);
                    }
                  }
                  if (null === u || u === l) {
                    var p = l,
                      g = (d = e.slice(0, p), e.slice(p));
                    if (d === a) {
                      var m = Math.min(s - p, o - p);
                      if ((y = c.slice(c.length - m)) === (x = g.slice(g.length - m))) return v(a, c.slice(0, c.length - m), g.slice(0, g.length - m), y);
                    }
                  }
                }
                if (r.length > 0 && i && 0 === i.length) {
                  var b = t.slice(0, r.index),
                    y = t.slice(r.index + r.length);
                  if (!(o < (f = b.length) + (m = y.length))) {
                    var A = e.slice(0, f),
                      x = e.slice(o - m);
                    if (b === A && y === x) return v(b, t.slice(f, s - m), e.slice(f, o - m), y);
                  }
                }
                return null;
              }(t, g, m);
              if (A) return A;
            }
            var x = o(t, g),
              N = t.substring(0, x);
            x = a(t = t.substring(x), g = g.substring(x));
            var E = t.substring(t.length - x),
              w = function (t, l) {
                var c;
                if (!t) return [[n, l]];
                if (!l) return [[e, t]];
                var u = t.length > l.length ? t : l,
                  h = t.length > l.length ? l : t,
                  d = u.indexOf(h);
                if (-1 !== d) return c = [[n, u.substring(0, d)], [r, h], [n, u.substring(d + h.length)]], t.length > l.length && (c[0][0] = c[2][0] = e), c;
                if (1 === h.length) return [[e, t], [n, l]];
                var f = function (t, e) {
                  var n = t.length > e.length ? t : e,
                    r = t.length > e.length ? e : t;
                  if (n.length < 4 || 2 * r.length < n.length) return null;
                  function i(t, e, n) {
                    for (var r, i, s, l, c = t.substring(n, n + Math.floor(t.length / 4)), u = -1, h = ""; -1 !== (u = e.indexOf(c, u + 1));) {
                      var d = o(t.substring(n), e.substring(u)),
                        f = a(t.substring(0, n), e.substring(0, u));
                      h.length < f + d && (h = e.substring(u - f, u) + e.substring(u, u + d), r = t.substring(0, n - f), i = t.substring(n + d), s = e.substring(0, u - f), l = e.substring(u + d));
                    }
                    return 2 * h.length >= t.length ? [r, i, s, l, h] : null;
                  }
                  var s,
                    l,
                    c,
                    u,
                    h,
                    d = i(n, r, Math.ceil(n.length / 4)),
                    f = i(n, r, Math.ceil(n.length / 2));
                  return d || f ? (s = f ? d && d[4].length > f[4].length ? d : f : d, t.length > e.length ? (l = s[0], c = s[1], u = s[2], h = s[3]) : (u = s[0], h = s[1], l = s[2], c = s[3]), [l, c, u, h, s[4]]) : null;
                }(t, l);
                if (f) {
                  var p = f[0],
                    g = f[1],
                    m = f[2],
                    b = f[3],
                    y = f[4],
                    v = i(p, m),
                    A = i(g, b);
                  return v.concat([[r, y]], A);
                }
                return function (t, r) {
                  for (var i = t.length, o = r.length, l = Math.ceil((i + o) / 2), a = l, c = 2 * l, u = new Array(c), h = new Array(c), d = 0; d < c; d++) u[d] = -1, h[d] = -1;
                  u[a + 1] = 0, h[a + 1] = 0;
                  for (var f = i - o, p = f % 2 != 0, g = 0, m = 0, b = 0, y = 0, v = 0; v < l; v++) {
                    for (var A = -v + g; A <= v - m; A += 2) {
                      for (var x = a + A, N = (_ = A === -v || A !== v && u[x - 1] < u[x + 1] ? u[x + 1] : u[x - 1] + 1) - A; _ < i && N < o && t.charAt(_) === r.charAt(N);) _++, N++;
                      if (u[x] = _, _ > i) m += 2;else if (N > o) g += 2;else if (p && (q = a + f - A) >= 0 && q < c && -1 !== h[q] && _ >= (w = i - h[q])) return s(t, r, _, N);
                    }
                    for (var E = -v + b; E <= v - y; E += 2) {
                      for (var w, q = a + E, k = (w = E === -v || E !== v && h[q - 1] < h[q + 1] ? h[q + 1] : h[q - 1] + 1) - E; w < i && k < o && t.charAt(i - w - 1) === r.charAt(o - k - 1);) w++, k++;
                      if (h[q] = w, w > i) y += 2;else if (k > o) b += 2;else if (!p) {
                        var _;
                        if ((x = a + f - E) >= 0 && x < c && -1 !== u[x]) if (N = a + (_ = u[x]) - x, _ >= (w = i - w)) return s(t, r, _, N);
                      }
                    }
                  }
                  return [[e, t], [n, r]];
                }(t, l);
              }(t = t.substring(0, t.length - x), g = g.substring(0, g.length - x));
            return N && w.unshift([r, N]), E && w.push([r, E]), p(w, y), b && function (t) {
              for (var i = !1, s = [], o = 0, g = null, m = 0, b = 0, y = 0, v = 0, A = 0; m < t.length;) t[m][0] == r ? (s[o++] = m, b = v, y = A, v = 0, A = 0, g = t[m][1]) : (t[m][0] == n ? v += t[m][1].length : A += t[m][1].length, g && g.length <= Math.max(b, y) && g.length <= Math.max(v, A) && (t.splice(s[o - 1], 0, [e, g]), t[s[o - 1] + 1][0] = n, o--, m = --o > 0 ? s[o - 1] : -1, b = 0, y = 0, v = 0, A = 0, g = null, i = !0)), m++;
              for (i && p(t), function (t) {
                function e(t, e) {
                  if (!t || !e) return 6;
                  var n = t.charAt(t.length - 1),
                    r = e.charAt(0),
                    i = n.match(c),
                    s = r.match(c),
                    o = i && n.match(u),
                    l = s && r.match(u),
                    a = o && n.match(h),
                    p = l && r.match(h),
                    g = a && t.match(d),
                    m = p && e.match(f);
                  return g || m ? 5 : a || p ? 4 : i && !o && l ? 3 : o || l ? 2 : i || s ? 1 : 0;
                }
                for (var n = 1; n < t.length - 1;) {
                  if (t[n - 1][0] == r && t[n + 1][0] == r) {
                    var i = t[n - 1][1],
                      s = t[n][1],
                      o = t[n + 1][1],
                      l = a(i, s);
                    if (l) {
                      var p = s.substring(s.length - l);
                      i = i.substring(0, i.length - l), s = p + s.substring(0, s.length - l), o = p + o;
                    }
                    for (var g = i, m = s, b = o, y = e(i, s) + e(s, o); s.charAt(0) === o.charAt(0);) {
                      i += s.charAt(0), s = s.substring(1) + o.charAt(0), o = o.substring(1);
                      var v = e(i, s) + e(s, o);
                      v >= y && (y = v, g = i, m = s, b = o);
                    }
                    t[n - 1][1] != g && (g ? t[n - 1][1] = g : (t.splice(n - 1, 1), n--), t[n][1] = m, b ? t[n + 1][1] = b : (t.splice(n + 1, 1), n--));
                  }
                  n++;
                }
              }(t), m = 1; m < t.length;) {
                if (t[m - 1][0] == e && t[m][0] == n) {
                  var x = t[m - 1][1],
                    N = t[m][1],
                    E = l(x, N),
                    w = l(N, x);
                  E >= w ? (E >= x.length / 2 || E >= N.length / 2) && (t.splice(m, 0, [r, N.substring(0, E)]), t[m - 1][1] = x.substring(0, x.length - E), t[m + 1][1] = N.substring(E), m++) : (w >= x.length / 2 || w >= N.length / 2) && (t.splice(m, 0, [r, x.substring(0, w)]), t[m - 1][0] = n, t[m - 1][1] = N.substring(0, N.length - w), t[m + 1][0] = e, t[m + 1][1] = x.substring(w), m++), m++;
                }
                m++;
              }
            }(w), w;
          }
          function s(t, e, n, r) {
            var s = t.substring(0, n),
              o = e.substring(0, r),
              l = t.substring(n),
              a = e.substring(r),
              c = i(s, o),
              u = i(l, a);
            return c.concat(u);
          }
          function o(t, e) {
            if (!t || !e || t.charAt(0) !== e.charAt(0)) return 0;
            for (var n = 0, r = Math.min(t.length, e.length), i = r, s = 0; n < i;) t.substring(s, i) == e.substring(s, i) ? s = n = i : r = i, i = Math.floor((r - n) / 2 + n);
            return g(t.charCodeAt(i - 1)) && i--, i;
          }
          function l(t, e) {
            var n = t.length,
              r = e.length;
            if (0 == n || 0 == r) return 0;
            n > r ? t = t.substring(n - r) : n < r && (e = e.substring(0, n));
            var i = Math.min(n, r);
            if (t == e) return i;
            for (var s = 0, o = 1;;) {
              var l = t.substring(i - o),
                a = e.indexOf(l);
              if (-1 == a) return s;
              o += a, 0 != a && t.substring(i - o) != e.substring(0, o) || (s = o, o++);
            }
          }
          function a(t, e) {
            if (!t || !e || t.slice(-1) !== e.slice(-1)) return 0;
            for (var n = 0, r = Math.min(t.length, e.length), i = r, s = 0; n < i;) t.substring(t.length - i, t.length - s) == e.substring(e.length - i, e.length - s) ? s = n = i : r = i, i = Math.floor((r - n) / 2 + n);
            return m(t.charCodeAt(t.length - i)) && i--, i;
          }
          var c = /[^a-zA-Z0-9]/,
            u = /\s/,
            h = /[\r\n]/,
            d = /\n\r?\n$/,
            f = /^\r?\n\r?\n/;
          function p(t, i) {
            t.push([r, ""]);
            for (var s, l = 0, c = 0, u = 0, h = "", d = ""; l < t.length;) if (l < t.length - 1 && !t[l][1]) t.splice(l, 1);else switch (t[l][0]) {
              case n:
                u++, d += t[l][1], l++;
                break;
              case e:
                c++, h += t[l][1], l++;
                break;
              case r:
                var f = l - u - c - 1;
                if (i) {
                  if (f >= 0 && y(t[f][1])) {
                    var g = t[f][1].slice(-1);
                    if (t[f][1] = t[f][1].slice(0, -1), h = g + h, d = g + d, !t[f][1]) {
                      t.splice(f, 1), l--;
                      var m = f - 1;
                      t[m] && t[m][0] === n && (u++, d = t[m][1] + d, m--), t[m] && t[m][0] === e && (c++, h = t[m][1] + h, m--), f = m;
                    }
                  }
                  b(t[l][1]) && (g = t[l][1].charAt(0), t[l][1] = t[l][1].slice(1), h += g, d += g);
                }
                if (l < t.length - 1 && !t[l][1]) {
                  t.splice(l, 1);
                  break;
                }
                if (h.length > 0 || d.length > 0) {
                  h.length > 0 && d.length > 0 && (0 !== (s = o(d, h)) && (f >= 0 ? t[f][1] += d.substring(0, s) : (t.splice(0, 0, [r, d.substring(0, s)]), l++), d = d.substring(s), h = h.substring(s)), 0 !== (s = a(d, h)) && (t[l][1] = d.substring(d.length - s) + t[l][1], d = d.substring(0, d.length - s), h = h.substring(0, h.length - s)));
                  var v = u + c;
                  0 === h.length && 0 === d.length ? (t.splice(l - v, v), l -= v) : 0 === h.length ? (t.splice(l - v, v, [n, d]), l = l - v + 1) : 0 === d.length ? (t.splice(l - v, v, [e, h]), l = l - v + 1) : (t.splice(l - v, v, [e, h], [n, d]), l = l - v + 2);
                }
                0 !== l && t[l - 1][0] === r ? (t[l - 1][1] += t[l][1], t.splice(l, 1)) : l++, u = 0, c = 0, h = "", d = "";
            }
            "" === t[t.length - 1][1] && t.pop();
            var A = !1;
            for (l = 1; l < t.length - 1;) t[l - 1][0] === r && t[l + 1][0] === r && (t[l][1].substring(t[l][1].length - t[l - 1][1].length) === t[l - 1][1] ? (t[l][1] = t[l - 1][1] + t[l][1].substring(0, t[l][1].length - t[l - 1][1].length), t[l + 1][1] = t[l - 1][1] + t[l + 1][1], t.splice(l - 1, 1), A = !0) : t[l][1].substring(0, t[l + 1][1].length) == t[l + 1][1] && (t[l - 1][1] += t[l + 1][1], t[l][1] = t[l][1].substring(t[l + 1][1].length) + t[l + 1][1], t.splice(l + 1, 1), A = !0)), l++;
            A && p(t, i);
          }
          function g(t) {
            return t >= 55296 && t <= 56319;
          }
          function m(t) {
            return t >= 56320 && t <= 57343;
          }
          function b(t) {
            return m(t.charCodeAt(0));
          }
          function y(t) {
            return g(t.charCodeAt(t.length - 1));
          }
          function v(t, i, s, o) {
            return y(t) || b(o) ? null : function (t) {
              for (var e = [], n = 0; n < t.length; n++) t[n][1].length > 0 && e.push(t[n]);
              return e;
            }([[r, t], [e, i], [n, s], [r, o]]);
          }
          function A(t, e, n, r) {
            return i(t, e, n, r, !0);
          }
          A.INSERT = n, A.DELETE = e, A.EQUAL = r, t.exports = A;
        },
        9629: function _(t, e, n) {
          t = n.nmd(t);
          var r = "__lodash_hash_undefined__",
            i = 9007199254740991,
            s = "[object Arguments]",
            o = "[object Boolean]",
            l = "[object Date]",
            a = "[object Function]",
            c = "[object GeneratorFunction]",
            u = "[object Map]",
            h = "[object Number]",
            d = "[object Object]",
            f = "[object Promise]",
            p = "[object RegExp]",
            g = "[object Set]",
            m = "[object String]",
            b = "[object Symbol]",
            y = "[object WeakMap]",
            v = "[object ArrayBuffer]",
            A = "[object DataView]",
            x = "[object Float32Array]",
            N = "[object Float64Array]",
            E = "[object Int8Array]",
            w = "[object Int16Array]",
            q = "[object Int32Array]",
            k = "[object Uint8Array]",
            _ = "[object Uint8ClampedArray]",
            L = "[object Uint16Array]",
            S = "[object Uint32Array]",
            O = /\w*$/,
            T = /^\[object .+?Constructor\]$/,
            j = /^(?:0|[1-9]\d*)$/,
            C = {};
          C[s] = C["[object Array]"] = C[v] = C[A] = C[o] = C[l] = C[x] = C[N] = C[E] = C[w] = C[q] = C[u] = C[h] = C[d] = C[p] = C[g] = C[m] = C[b] = C[k] = C[_] = C[L] = C[S] = !0, C["[object Error]"] = C[a] = C[y] = !1;
          var R = "object" == _typeof(n.g) && n.g && n.g.Object === Object && n.g,
            I = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self && self.Object === Object && self,
            B = R || I || Function("return this")(),
            M = e && !e.nodeType && e,
            U = M && t && !t.nodeType && t,
            D = U && U.exports === M;
          function P(t, e) {
            return t.set(e[0], e[1]), t;
          }
          function z(t, e) {
            return t.add(e), t;
          }
          function F(t, e, n, r) {
            var i = -1,
              s = t ? t.length : 0;
            for (r && s && (n = t[++i]); ++i < s;) n = e(n, t[i], i, t);
            return n;
          }
          function $(t) {
            var e = !1;
            if (null != t && "function" != typeof t.toString) try {
              e = !!(t + "");
            } catch (t) {}
            return e;
          }
          function H(t) {
            var e = -1,
              n = Array(t.size);
            return t.forEach(function (t, r) {
              n[++e] = [r, t];
            }), n;
          }
          function V(t, e) {
            return function (n) {
              return t(e(n));
            };
          }
          function K(t) {
            var e = -1,
              n = Array(t.size);
            return t.forEach(function (t) {
              n[++e] = t;
            }), n;
          }
          var W,
            Z = Array.prototype,
            G = Function.prototype,
            X = Object.prototype,
            Q = B["__core-js_shared__"],
            J = (W = /[^.]+$/.exec(Q && Q.keys && Q.keys.IE_PROTO || "")) ? "Symbol(src)_1." + W : "",
            Y = G.toString,
            tt = X.hasOwnProperty,
            et = X.toString,
            nt = RegExp("^" + Y.call(tt).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
            rt = D ? B.Buffer : void 0,
            it = B.Symbol,
            st = B.Uint8Array,
            ot = V(Object.getPrototypeOf, Object),
            lt = Object.create,
            at = X.propertyIsEnumerable,
            ct = Z.splice,
            ut = Object.getOwnPropertySymbols,
            ht = rt ? rt.isBuffer : void 0,
            dt = V(Object.keys, Object),
            ft = Bt(B, "DataView"),
            pt = Bt(B, "Map"),
            gt = Bt(B, "Promise"),
            mt = Bt(B, "Set"),
            bt = Bt(B, "WeakMap"),
            yt = Bt(Object, "create"),
            vt = zt(ft),
            At = zt(pt),
            xt = zt(gt),
            Nt = zt(mt),
            Et = zt(bt),
            wt = it ? it.prototype : void 0,
            qt = wt ? wt.valueOf : void 0;
          function kt(t) {
            var e = -1,
              n = t ? t.length : 0;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          function _t(t) {
            var e = -1,
              n = t ? t.length : 0;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          function Lt(t) {
            var e = -1,
              n = t ? t.length : 0;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          function St(t) {
            this.__data__ = new _t(t);
          }
          function Ot(t, e, n) {
            var r = t[e];
            tt.call(t, e) && Ft(r, n) && (void 0 !== n || e in t) || (t[e] = n);
          }
          function Tt(t, e) {
            for (var n = t.length; n--;) if (Ft(t[n][0], e)) return n;
            return -1;
          }
          function jt(t, e, n, r, i, f, y) {
            var T;
            if (r && (T = f ? r(t, i, f, y) : r(t)), void 0 !== T) return T;
            if (!Wt(t)) return t;
            var j = $t(t);
            if (j) {
              if (T = function (t) {
                var e = t.length,
                  n = t.constructor(e);
                return e && "string" == typeof t[0] && tt.call(t, "index") && (n.index = t.index, n.input = t.input), n;
              }(t), !e) return function (t, e) {
                var n = -1,
                  r = t.length;
                for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
                return e;
              }(t, T);
            } else {
              var R = Ut(t),
                I = R == a || R == c;
              if (Vt(t)) return function (t, e) {
                if (e) return t.slice();
                var n = new t.constructor(t.length);
                return t.copy(n), n;
              }(t, e);
              if (R == d || R == s || I && !f) {
                if ($(t)) return f ? t : {};
                if (T = function (t) {
                  return "function" != typeof t.constructor || Pt(t) ? {} : Wt(e = ot(t)) ? lt(e) : {};
                  var e;
                }(I ? {} : t), !e) return function (t, e) {
                  return Rt(t, Mt(t), e);
                }(t, function (t, e) {
                  return t && Rt(e, Zt(e), t);
                }(T, t));
              } else {
                if (!C[R]) return f ? t : {};
                T = function (t, e, n, r) {
                  var i,
                    s = t.constructor;
                  switch (e) {
                    case v:
                      return Ct(t);
                    case o:
                    case l:
                      return new s(+t);
                    case A:
                      return function (t, e) {
                        var n = e ? Ct(t.buffer) : t.buffer;
                        return new t.constructor(n, t.byteOffset, t.byteLength);
                      }(t, r);
                    case x:
                    case N:
                    case E:
                    case w:
                    case q:
                    case k:
                    case _:
                    case L:
                    case S:
                      return function (t, e) {
                        var n = e ? Ct(t.buffer) : t.buffer;
                        return new t.constructor(n, t.byteOffset, t.length);
                      }(t, r);
                    case u:
                      return function (t, e, n) {
                        return F(e ? n(H(t), !0) : H(t), P, new t.constructor());
                      }(t, r, n);
                    case h:
                    case m:
                      return new s(t);
                    case p:
                      return function (t) {
                        var e = new t.constructor(t.source, O.exec(t));
                        return e.lastIndex = t.lastIndex, e;
                      }(t);
                    case g:
                      return function (t, e, n) {
                        return F(e ? n(K(t), !0) : K(t), z, new t.constructor());
                      }(t, r, n);
                    case b:
                      return i = t, qt ? Object(qt.call(i)) : {};
                  }
                }(t, R, jt, e);
              }
            }
            y || (y = new St());
            var B = y.get(t);
            if (B) return B;
            if (y.set(t, T), !j) var M = n ? function (t) {
              return function (t, e, n) {
                var r = e(t);
                return $t(t) ? r : function (t, e) {
                  for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
                  return t;
                }(r, n(t));
              }(t, Zt, Mt);
            }(t) : Zt(t);
            return function (t, e) {
              for (var n = -1, r = t ? t.length : 0; ++n < r && !1 !== e(t[n], n););
            }(M || t, function (i, s) {
              M && (i = t[s = i]), Ot(T, s, jt(i, e, n, r, s, t, y));
            }), T;
          }
          function Ct(t) {
            var e = new t.constructor(t.byteLength);
            return new st(e).set(new st(t)), e;
          }
          function Rt(t, e, n, r) {
            n || (n = {});
            for (var i = -1, s = e.length; ++i < s;) {
              var o = e[i],
                l = r ? r(n[o], t[o], o, n, t) : void 0;
              Ot(n, o, void 0 === l ? t[o] : l);
            }
            return n;
          }
          function It(t, e) {
            var n,
              r,
              i = t.__data__;
            return ("string" == (r = _typeof(n = e)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map;
          }
          function Bt(t, e) {
            var n = function (t, e) {
              return null == t ? void 0 : t[e];
            }(t, e);
            return function (t) {
              return !(!Wt(t) || (e = t, J && J in e)) && (Kt(t) || $(t) ? nt : T).test(zt(t));
              var e;
            }(n) ? n : void 0;
          }
          kt.prototype.clear = function () {
            this.__data__ = yt ? yt(null) : {};
          }, kt.prototype["delete"] = function (t) {
            return this.has(t) && delete this.__data__[t];
          }, kt.prototype.get = function (t) {
            var e = this.__data__;
            if (yt) {
              var n = e[t];
              return n === r ? void 0 : n;
            }
            return tt.call(e, t) ? e[t] : void 0;
          }, kt.prototype.has = function (t) {
            var e = this.__data__;
            return yt ? void 0 !== e[t] : tt.call(e, t);
          }, kt.prototype.set = function (t, e) {
            return this.__data__[t] = yt && void 0 === e ? r : e, this;
          }, _t.prototype.clear = function () {
            this.__data__ = [];
          }, _t.prototype["delete"] = function (t) {
            var e = this.__data__,
              n = Tt(e, t);
            return !(n < 0 || (n == e.length - 1 ? e.pop() : ct.call(e, n, 1), 0));
          }, _t.prototype.get = function (t) {
            var e = this.__data__,
              n = Tt(e, t);
            return n < 0 ? void 0 : e[n][1];
          }, _t.prototype.has = function (t) {
            return Tt(this.__data__, t) > -1;
          }, _t.prototype.set = function (t, e) {
            var n = this.__data__,
              r = Tt(n, t);
            return r < 0 ? n.push([t, e]) : n[r][1] = e, this;
          }, Lt.prototype.clear = function () {
            this.__data__ = {
              hash: new kt(),
              map: new (pt || _t)(),
              string: new kt()
            };
          }, Lt.prototype["delete"] = function (t) {
            return It(this, t)["delete"](t);
          }, Lt.prototype.get = function (t) {
            return It(this, t).get(t);
          }, Lt.prototype.has = function (t) {
            return It(this, t).has(t);
          }, Lt.prototype.set = function (t, e) {
            return It(this, t).set(t, e), this;
          }, St.prototype.clear = function () {
            this.__data__ = new _t();
          }, St.prototype["delete"] = function (t) {
            return this.__data__["delete"](t);
          }, St.prototype.get = function (t) {
            return this.__data__.get(t);
          }, St.prototype.has = function (t) {
            return this.__data__.has(t);
          }, St.prototype.set = function (t, e) {
            var n = this.__data__;
            if (n instanceof _t) {
              var r = n.__data__;
              if (!pt || r.length < 199) return r.push([t, e]), this;
              n = this.__data__ = new Lt(r);
            }
            return n.set(t, e), this;
          };
          var Mt = ut ? V(ut, Object) : function () {
              return [];
            },
            Ut = function Ut(t) {
              return et.call(t);
            };
          function Dt(t, e) {
            return !!(e = null == e ? i : e) && ("number" == typeof t || j.test(t)) && t > -1 && t % 1 == 0 && t < e;
          }
          function Pt(t) {
            var e = t && t.constructor;
            return t === ("function" == typeof e && e.prototype || X);
          }
          function zt(t) {
            if (null != t) {
              try {
                return Y.call(t);
              } catch (t) {}
              try {
                return t + "";
              } catch (t) {}
            }
            return "";
          }
          function Ft(t, e) {
            return t === e || t != t && e != e;
          }
          (ft && Ut(new ft(new ArrayBuffer(1))) != A || pt && Ut(new pt()) != u || gt && Ut(gt.resolve()) != f || mt && Ut(new mt()) != g || bt && Ut(new bt()) != y) && (Ut = function Ut(t) {
            var e = et.call(t),
              n = e == d ? t.constructor : void 0,
              r = n ? zt(n) : void 0;
            if (r) switch (r) {
              case vt:
                return A;
              case At:
                return u;
              case xt:
                return f;
              case Nt:
                return g;
              case Et:
                return y;
            }
            return e;
          });
          var $t = Array.isArray;
          function Ht(t) {
            return null != t && function (t) {
              return "number" == typeof t && t > -1 && t % 1 == 0 && t <= i;
            }(t.length) && !Kt(t);
          }
          var Vt = ht || function () {
            return !1;
          };
          function Kt(t) {
            var e = Wt(t) ? et.call(t) : "";
            return e == a || e == c;
          }
          function Wt(t) {
            var e = _typeof(t);
            return !!t && ("object" == e || "function" == e);
          }
          function Zt(t) {
            return Ht(t) ? function (t, e) {
              var n = $t(t) || function (t) {
                  return function (t) {
                    return function (t) {
                      return !!t && "object" == _typeof(t);
                    }(t) && Ht(t);
                  }(t) && tt.call(t, "callee") && (!at.call(t, "callee") || et.call(t) == s);
                }(t) ? function (t, e) {
                  for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
                  return r;
                }(t.length, String) : [],
                r = n.length,
                i = !!r;
              for (var o in t) !e && !tt.call(t, o) || i && ("length" == o || Dt(o, r)) || n.push(o);
              return n;
            }(t) : function (t) {
              if (!Pt(t)) return dt(t);
              var e = [];
              for (var n in Object(t)) tt.call(t, n) && "constructor" != n && e.push(n);
              return e;
            }(t);
          }
          t.exports = function (t) {
            return jt(t, !0, !0);
          };
        },
        4162: function _(t, e, n) {
          t = n.nmd(t);
          var r = "__lodash_hash_undefined__",
            i = 1,
            s = 2,
            o = 9007199254740991,
            l = "[object Arguments]",
            a = "[object Array]",
            c = "[object AsyncFunction]",
            u = "[object Boolean]",
            h = "[object Date]",
            d = "[object Error]",
            f = "[object Function]",
            p = "[object GeneratorFunction]",
            g = "[object Map]",
            m = "[object Number]",
            b = "[object Null]",
            y = "[object Object]",
            v = "[object Promise]",
            A = "[object Proxy]",
            x = "[object RegExp]",
            N = "[object Set]",
            E = "[object String]",
            w = "[object Undefined]",
            q = "[object WeakMap]",
            k = "[object ArrayBuffer]",
            _ = "[object DataView]",
            L = /^\[object .+?Constructor\]$/,
            S = /^(?:0|[1-9]\d*)$/,
            O = {};
          O["[object Float32Array]"] = O["[object Float64Array]"] = O["[object Int8Array]"] = O["[object Int16Array]"] = O["[object Int32Array]"] = O["[object Uint8Array]"] = O["[object Uint8ClampedArray]"] = O["[object Uint16Array]"] = O["[object Uint32Array]"] = !0, O[l] = O[a] = O[k] = O[u] = O[_] = O[h] = O[d] = O[f] = O[g] = O[m] = O[y] = O[x] = O[N] = O[E] = O[q] = !1;
          var T = "object" == _typeof(n.g) && n.g && n.g.Object === Object && n.g,
            j = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self && self.Object === Object && self,
            C = T || j || Function("return this")(),
            R = e && !e.nodeType && e,
            I = R && t && !t.nodeType && t,
            B = I && I.exports === R,
            M = B && T.process,
            U = function () {
              try {
                return M && M.binding && M.binding("util");
              } catch (t) {}
            }(),
            D = U && U.isTypedArray;
          function P(t, e) {
            for (var n = -1, r = null == t ? 0 : t.length; ++n < r;) if (e(t[n], n, t)) return !0;
            return !1;
          }
          function z(t) {
            var e = -1,
              n = Array(t.size);
            return t.forEach(function (t, r) {
              n[++e] = [r, t];
            }), n;
          }
          function F(t) {
            var e = -1,
              n = Array(t.size);
            return t.forEach(function (t) {
              n[++e] = t;
            }), n;
          }
          var $,
            H,
            V,
            K = Array.prototype,
            W = Function.prototype,
            Z = Object.prototype,
            G = C["__core-js_shared__"],
            X = W.toString,
            Q = Z.hasOwnProperty,
            J = ($ = /[^.]+$/.exec(G && G.keys && G.keys.IE_PROTO || "")) ? "Symbol(src)_1." + $ : "",
            Y = Z.toString,
            tt = RegExp("^" + X.call(Q).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
            et = B ? C.Buffer : void 0,
            nt = C.Symbol,
            rt = C.Uint8Array,
            it = Z.propertyIsEnumerable,
            st = K.splice,
            ot = nt ? nt.toStringTag : void 0,
            lt = Object.getOwnPropertySymbols,
            at = et ? et.isBuffer : void 0,
            ct = (H = Object.keys, V = Object, function (t) {
              return H(V(t));
            }),
            ut = It(C, "DataView"),
            ht = It(C, "Map"),
            dt = It(C, "Promise"),
            ft = It(C, "Set"),
            pt = It(C, "WeakMap"),
            gt = It(Object, "create"),
            mt = Dt(ut),
            bt = Dt(ht),
            yt = Dt(dt),
            vt = Dt(ft),
            At = Dt(pt),
            xt = nt ? nt.prototype : void 0,
            Nt = xt ? xt.valueOf : void 0;
          function Et(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          function wt(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          function qt(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          function kt(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.__data__ = new qt(); ++e < n;) this.add(t[e]);
          }
          function _t(t) {
            var e = this.__data__ = new wt(t);
            this.size = e.size;
          }
          function Lt(t, e) {
            for (var n = t.length; n--;) if (Pt(t[n][0], e)) return n;
            return -1;
          }
          function St(t) {
            return null == t ? void 0 === t ? w : b : ot && ot in Object(t) ? function (t) {
              var e = Q.call(t, ot),
                n = t[ot];
              try {
                t[ot] = void 0;
                var r = !0;
              } catch (t) {}
              var i = Y.call(t);
              return r && (e ? t[ot] = n : delete t[ot]), i;
            }(t) : function (t) {
              return Y.call(t);
            }(t);
          }
          function Ot(t) {
            return Wt(t) && St(t) == l;
          }
          function Tt(t, e, n, r, o) {
            return t === e || (null == t || null == e || !Wt(t) && !Wt(e) ? t != t && e != e : function (t, e, n, r, o, c) {
              var f = Ft(t),
                p = Ft(e),
                b = f ? a : Mt(t),
                v = p ? a : Mt(e),
                A = (b = b == l ? y : b) == y,
                w = (v = v == l ? y : v) == y,
                q = b == v;
              if (q && $t(t)) {
                if (!$t(e)) return !1;
                f = !0, A = !1;
              }
              if (q && !A) return c || (c = new _t()), f || Zt(t) ? jt(t, e, n, r, o, c) : function (t, e, n, r, o, l, a) {
                switch (n) {
                  case _:
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                    t = t.buffer, e = e.buffer;
                  case k:
                    return !(t.byteLength != e.byteLength || !l(new rt(t), new rt(e)));
                  case u:
                  case h:
                  case m:
                    return Pt(+t, +e);
                  case d:
                    return t.name == e.name && t.message == e.message;
                  case x:
                  case E:
                    return t == e + "";
                  case g:
                    var c = z;
                  case N:
                    var f = r & i;
                    if (c || (c = F), t.size != e.size && !f) return !1;
                    var p = a.get(t);
                    if (p) return p == e;
                    r |= s, a.set(t, e);
                    var b = jt(c(t), c(e), r, o, l, a);
                    return a["delete"](t), b;
                  case "[object Symbol]":
                    if (Nt) return Nt.call(t) == Nt.call(e);
                }
                return !1;
              }(t, e, b, n, r, o, c);
              if (!(n & i)) {
                var L = A && Q.call(t, "__wrapped__"),
                  S = w && Q.call(e, "__wrapped__");
                if (L || S) {
                  var O = L ? t.value() : t,
                    T = S ? e.value() : e;
                  return c || (c = new _t()), o(O, T, n, r, c);
                }
              }
              return !!q && (c || (c = new _t()), function (t, e, n, r, s, o) {
                var l = n & i,
                  a = Ct(t),
                  c = a.length;
                if (c != Ct(e).length && !l) return !1;
                for (var u = c; u--;) {
                  var h = a[u];
                  if (!(l ? h in e : Q.call(e, h))) return !1;
                }
                var d = o.get(t);
                if (d && o.get(e)) return d == e;
                var f = !0;
                o.set(t, e), o.set(e, t);
                for (var p = l; ++u < c;) {
                  var g = t[h = a[u]],
                    m = e[h];
                  if (r) var b = l ? r(m, g, h, e, t, o) : r(g, m, h, t, e, o);
                  if (!(void 0 === b ? g === m || s(g, m, n, r, o) : b)) {
                    f = !1;
                    break;
                  }
                  p || (p = "constructor" == h);
                }
                if (f && !p) {
                  var y = t.constructor,
                    v = e.constructor;
                  y == v || !("constructor" in t) || !("constructor" in e) || "function" == typeof y && y instanceof y && "function" == typeof v && v instanceof v || (f = !1);
                }
                return o["delete"](t), o["delete"](e), f;
              }(t, e, n, r, o, c));
            }(t, e, n, r, Tt, o));
          }
          function jt(t, e, n, r, o, l) {
            var a = n & i,
              c = t.length,
              u = e.length;
            if (c != u && !(a && u > c)) return !1;
            var h = l.get(t);
            if (h && l.get(e)) return h == e;
            var d = -1,
              f = !0,
              p = n & s ? new kt() : void 0;
            for (l.set(t, e), l.set(e, t); ++d < c;) {
              var g = t[d],
                m = e[d];
              if (r) var b = a ? r(m, g, d, e, t, l) : r(g, m, d, t, e, l);
              if (void 0 !== b) {
                if (b) continue;
                f = !1;
                break;
              }
              if (p) {
                if (!P(e, function (t, e) {
                  if (i = e, !p.has(i) && (g === t || o(g, t, n, r, l))) return p.push(e);
                  var i;
                })) {
                  f = !1;
                  break;
                }
              } else if (g !== m && !o(g, m, n, r, l)) {
                f = !1;
                break;
              }
            }
            return l["delete"](t), l["delete"](e), f;
          }
          function Ct(t) {
            return function (t, e, n) {
              var r = e(t);
              return Ft(t) ? r : function (t, e) {
                for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
                return t;
              }(r, n(t));
            }(t, Gt, Bt);
          }
          function Rt(t, e) {
            var n,
              r,
              i = t.__data__;
            return ("string" == (r = _typeof(n = e)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map;
          }
          function It(t, e) {
            var n = function (t, e) {
              return null == t ? void 0 : t[e];
            }(t, e);
            return function (t) {
              return !(!Kt(t) || function (t) {
                return !!J && J in t;
              }(t)) && (Ht(t) ? tt : L).test(Dt(t));
            }(n) ? n : void 0;
          }
          Et.prototype.clear = function () {
            this.__data__ = gt ? gt(null) : {}, this.size = 0;
          }, Et.prototype["delete"] = function (t) {
            var e = this.has(t) && delete this.__data__[t];
            return this.size -= e ? 1 : 0, e;
          }, Et.prototype.get = function (t) {
            var e = this.__data__;
            if (gt) {
              var n = e[t];
              return n === r ? void 0 : n;
            }
            return Q.call(e, t) ? e[t] : void 0;
          }, Et.prototype.has = function (t) {
            var e = this.__data__;
            return gt ? void 0 !== e[t] : Q.call(e, t);
          }, Et.prototype.set = function (t, e) {
            var n = this.__data__;
            return this.size += this.has(t) ? 0 : 1, n[t] = gt && void 0 === e ? r : e, this;
          }, wt.prototype.clear = function () {
            this.__data__ = [], this.size = 0;
          }, wt.prototype["delete"] = function (t) {
            var e = this.__data__,
              n = Lt(e, t);
            return !(n < 0 || (n == e.length - 1 ? e.pop() : st.call(e, n, 1), --this.size, 0));
          }, wt.prototype.get = function (t) {
            var e = this.__data__,
              n = Lt(e, t);
            return n < 0 ? void 0 : e[n][1];
          }, wt.prototype.has = function (t) {
            return Lt(this.__data__, t) > -1;
          }, wt.prototype.set = function (t, e) {
            var n = this.__data__,
              r = Lt(n, t);
            return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
          }, qt.prototype.clear = function () {
            this.size = 0, this.__data__ = {
              hash: new Et(),
              map: new (ht || wt)(),
              string: new Et()
            };
          }, qt.prototype["delete"] = function (t) {
            var e = Rt(this, t)["delete"](t);
            return this.size -= e ? 1 : 0, e;
          }, qt.prototype.get = function (t) {
            return Rt(this, t).get(t);
          }, qt.prototype.has = function (t) {
            return Rt(this, t).has(t);
          }, qt.prototype.set = function (t, e) {
            var n = Rt(this, t),
              r = n.size;
            return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
          }, kt.prototype.add = kt.prototype.push = function (t) {
            return this.__data__.set(t, r), this;
          }, kt.prototype.has = function (t) {
            return this.__data__.has(t);
          }, _t.prototype.clear = function () {
            this.__data__ = new wt(), this.size = 0;
          }, _t.prototype["delete"] = function (t) {
            var e = this.__data__,
              n = e["delete"](t);
            return this.size = e.size, n;
          }, _t.prototype.get = function (t) {
            return this.__data__.get(t);
          }, _t.prototype.has = function (t) {
            return this.__data__.has(t);
          }, _t.prototype.set = function (t, e) {
            var n = this.__data__;
            if (n instanceof wt) {
              var r = n.__data__;
              if (!ht || r.length < 199) return r.push([t, e]), this.size = ++n.size, this;
              n = this.__data__ = new qt(r);
            }
            return n.set(t, e), this.size = n.size, this;
          };
          var Bt = lt ? function (t) {
              return null == t ? [] : (t = Object(t), function (e, n) {
                for (var r = -1, i = null == e ? 0 : e.length, s = 0, o = []; ++r < i;) {
                  var l = e[r];
                  a = l, it.call(t, a) && (o[s++] = l);
                }
                var a;
                return o;
              }(lt(t)));
            } : function () {
              return [];
            },
            Mt = St;
          function Ut(t, e) {
            return !!(e = null == e ? o : e) && ("number" == typeof t || S.test(t)) && t > -1 && t % 1 == 0 && t < e;
          }
          function Dt(t) {
            if (null != t) {
              try {
                return X.call(t);
              } catch (t) {}
              try {
                return t + "";
              } catch (t) {}
            }
            return "";
          }
          function Pt(t, e) {
            return t === e || t != t && e != e;
          }
          (ut && Mt(new ut(new ArrayBuffer(1))) != _ || ht && Mt(new ht()) != g || dt && Mt(dt.resolve()) != v || ft && Mt(new ft()) != N || pt && Mt(new pt()) != q) && (Mt = function Mt(t) {
            var e = St(t),
              n = e == y ? t.constructor : void 0,
              r = n ? Dt(n) : "";
            if (r) switch (r) {
              case mt:
                return _;
              case bt:
                return g;
              case yt:
                return v;
              case vt:
                return N;
              case At:
                return q;
            }
            return e;
          });
          var zt = Ot(function () {
              return arguments;
            }()) ? Ot : function (t) {
              return Wt(t) && Q.call(t, "callee") && !it.call(t, "callee");
            },
            Ft = Array.isArray,
            $t = at || function () {
              return !1;
            };
          function Ht(t) {
            if (!Kt(t)) return !1;
            var e = St(t);
            return e == f || e == p || e == c || e == A;
          }
          function Vt(t) {
            return "number" == typeof t && t > -1 && t % 1 == 0 && t <= o;
          }
          function Kt(t) {
            var e = _typeof(t);
            return null != t && ("object" == e || "function" == e);
          }
          function Wt(t) {
            return null != t && "object" == _typeof(t);
          }
          var Zt = D ? function (t) {
            return function (e) {
              return t(e);
            };
          }(D) : function (t) {
            return Wt(t) && Vt(t.length) && !!O[St(t)];
          };
          function Gt(t) {
            return null != (e = t) && Vt(e.length) && !Ht(e) ? function (t, e) {
              var n = Ft(t),
                r = !n && zt(t),
                i = !n && !r && $t(t),
                s = !n && !r && !i && Zt(t),
                o = n || r || i || s,
                l = o ? function (t, e) {
                  for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
                  return r;
                }(t.length, String) : [],
                a = l.length;
              for (var c in t) !e && !Q.call(t, c) || o && ("length" == c || i && ("offset" == c || "parent" == c) || s && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || Ut(c, a)) || l.push(c);
              return l;
            }(t) : function (t) {
              if (n = (e = t) && e.constructor, e !== ("function" == typeof n && n.prototype || Z)) return ct(t);
              var e,
                n,
                r = [];
              for (var i in Object(t)) Q.call(t, i) && "constructor" != i && r.push(i);
              return r;
            }(t);
            var e;
          }
          t.exports = function (t, e) {
            return Tt(t, e);
          };
        },
        1270: function _(t, e, n) {
          "use strict";

          Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var r = n(9629),
            i = n(4162);
          var s;
          !function (t) {
            t.compose = function () {
              var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
              "object" != _typeof(t) && (t = {}), "object" != _typeof(e) && (e = {});
              var i = r(e);
              n || (i = Object.keys(i).reduce(function (t, e) {
                return null != i[e] && (t[e] = i[e]), t;
              }, {}));
              for (var _n21 in t) void 0 !== t[_n21] && void 0 === e[_n21] && (i[_n21] = t[_n21]);
              return Object.keys(i).length > 0 ? i : void 0;
            }, t.diff = function () {
              var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              "object" != _typeof(t) && (t = {}), "object" != _typeof(e) && (e = {});
              var n = Object.keys(t).concat(Object.keys(e)).reduce(function (n, r) {
                return i(t[r], e[r]) || (n[r] = void 0 === e[r] ? null : e[r]), n;
              }, {});
              return Object.keys(n).length > 0 ? n : void 0;
            }, t.invert = function () {
              var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              t = t || {};
              var n = Object.keys(e).reduce(function (n, r) {
                return e[r] !== t[r] && void 0 !== t[r] && (n[r] = e[r]), n;
              }, {});
              return Object.keys(t).reduce(function (n, r) {
                return t[r] !== e[r] && void 0 === e[r] && (n[r] = null), n;
              }, n);
            }, t.transform = function (t, e) {
              var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
              if ("object" != _typeof(t)) return e;
              if ("object" != _typeof(e)) return;
              if (!n) return e;
              var r = Object.keys(e).reduce(function (n, r) {
                return void 0 === t[r] && (n[r] = e[r]), n;
              }, {});
              return Object.keys(r).length > 0 ? r : void 0;
            };
          }(s || (s = {})), e["default"] = s;
        },
        5232: function _(t, e, n) {
          "use strict";

          Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.AttributeMap = e.OpIterator = e.Op = void 0;
          var r = n(5090),
            i = n(9629),
            s = n(4162),
            o = n(1270);
          e.AttributeMap = o["default"];
          var l = n(4123);
          e.Op = l["default"];
          var a = n(7033);
          e.OpIterator = a["default"];
          var c = String.fromCharCode(0),
            u = function u(t, e) {
              if ("object" != _typeof(t) || null === t) throw new Error("cannot retain a " + _typeof(t));
              if ("object" != _typeof(e) || null === e) throw new Error("cannot retain a " + _typeof(e));
              var n = Object.keys(t)[0];
              if (!n || n !== Object.keys(e)[0]) throw new Error("embed types not matched: ".concat(n, " != ").concat(Object.keys(e)[0]));
              return [n, t[n], e[n]];
            };
          var h = /*#__PURE__*/function () {
            function h(t) {
              _classCallCheck(this, h);
              Array.isArray(t) ? this.ops = t : null != t && Array.isArray(t.ops) ? this.ops = t.ops : this.ops = [];
            }
            return _createClass(h, [{
              key: "insert",
              value: function insert(t, e) {
                var n = {};
                return "string" == typeof t && 0 === t.length ? this : (n.insert = t, null != e && "object" == _typeof(e) && Object.keys(e).length > 0 && (n.attributes = e), this.push(n));
              }
            }, {
              key: "delete",
              value: function _delete(t) {
                return t <= 0 ? this : this.push({
                  "delete": t
                });
              }
            }, {
              key: "retain",
              value: function retain(t, e) {
                if ("number" == typeof t && t <= 0) return this;
                var n = {
                  retain: t
                };
                return null != e && "object" == _typeof(e) && Object.keys(e).length > 0 && (n.attributes = e), this.push(n);
              }
            }, {
              key: "push",
              value: function push(t) {
                var e = this.ops.length,
                  n = this.ops[e - 1];
                if (t = i(t), "object" == _typeof(n)) {
                  if ("number" == typeof t["delete"] && "number" == typeof n["delete"]) return this.ops[e - 1] = {
                    "delete": n["delete"] + t["delete"]
                  }, this;
                  if ("number" == typeof n["delete"] && null != t.insert && (e -= 1, n = this.ops[e - 1], "object" != _typeof(n))) return this.ops.unshift(t), this;
                  if (s(t.attributes, n.attributes)) {
                    if ("string" == typeof t.insert && "string" == typeof n.insert) return this.ops[e - 1] = {
                      insert: n.insert + t.insert
                    }, "object" == _typeof(t.attributes) && (this.ops[e - 1].attributes = t.attributes), this;
                    if ("number" == typeof t.retain && "number" == typeof n.retain) return this.ops[e - 1] = {
                      retain: n.retain + t.retain
                    }, "object" == _typeof(t.attributes) && (this.ops[e - 1].attributes = t.attributes), this;
                  }
                }
                return e === this.ops.length ? this.ops.push(t) : this.ops.splice(e, 0, t), this;
              }
            }, {
              key: "chop",
              value: function chop() {
                var t = this.ops[this.ops.length - 1];
                return t && "number" == typeof t.retain && !t.attributes && this.ops.pop(), this;
              }
            }, {
              key: "filter",
              value: function filter(t) {
                return this.ops.filter(t);
              }
            }, {
              key: "forEach",
              value: function forEach(t) {
                this.ops.forEach(t);
              }
            }, {
              key: "map",
              value: function map(t) {
                return this.ops.map(t);
              }
            }, {
              key: "partition",
              value: function partition(t) {
                var e = [],
                  n = [];
                return this.forEach(function (r) {
                  (t(r) ? e : n).push(r);
                }), [e, n];
              }
            }, {
              key: "reduce",
              value: function reduce(t, e) {
                return this.ops.reduce(t, e);
              }
            }, {
              key: "changeLength",
              value: function changeLength() {
                return this.reduce(function (t, e) {
                  return e.insert ? t + l["default"].length(e) : e["delete"] ? t - e["delete"] : t;
                }, 0);
              }
            }, {
              key: "length",
              value: function length() {
                return this.reduce(function (t, e) {
                  return t + l["default"].length(e);
                }, 0);
              }
            }, {
              key: "slice",
              value: function slice() {
                var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1 / 0;
                var n = [],
                  r = new a["default"](this.ops);
                var i = 0;
                for (; i < e && r.hasNext();) {
                  var _s8 = void 0;
                  i < t ? _s8 = r.next(t - i) : (_s8 = r.next(e - i), n.push(_s8)), i += l["default"].length(_s8);
                }
                return new h(n);
              }
            }, {
              key: "compose",
              value: function compose(t) {
                var e = new a["default"](this.ops),
                  n = new a["default"](t.ops),
                  r = [],
                  i = n.peek();
                if (null != i && "number" == typeof i.retain && null == i.attributes) {
                  var _t31 = i.retain;
                  for (; "insert" === e.peekType() && e.peekLength() <= _t31;) _t31 -= e.peekLength(), r.push(e.next());
                  i.retain - _t31 > 0 && n.next(i.retain - _t31);
                }
                var l = new h(r);
                for (; e.hasNext() || n.hasNext();) if ("insert" === n.peekType()) l.push(n.next());else if ("delete" === e.peekType()) l.push(e.next());else {
                  var _t32 = Math.min(e.peekLength(), n.peekLength()),
                    _r17 = e.next(_t32),
                    _i11 = n.next(_t32);
                  if (_i11.retain) {
                    var _a5 = {};
                    if ("number" == typeof _r17.retain) _a5.retain = "number" == typeof _i11.retain ? _t32 : _i11.retain;else if ("number" == typeof _i11.retain) null == _r17.retain ? _a5.insert = _r17.insert : _a5.retain = _r17.retain;else {
                      var _t33 = null == _r17.retain ? "insert" : "retain",
                        _u3 = u(_r17[_t33], _i11.retain),
                        _u4 = _slicedToArray(_u3, 3),
                        _e29 = _u4[0],
                        _n22 = _u4[1],
                        _s9 = _u4[2],
                        _o1 = h.getHandler(_e29);
                      _a5[_t33] = _defineProperty({}, _e29, _o1.compose(_n22, _s9, "retain" === _t33));
                    }
                    var _c3 = o["default"].compose(_r17.attributes, _i11.attributes, "number" == typeof _r17.retain);
                    if (_c3 && (_a5.attributes = _c3), l.push(_a5), !n.hasNext() && s(l.ops[l.ops.length - 1], _a5)) {
                      var _t34 = new h(e.rest());
                      return l.concat(_t34).chop();
                    }
                  } else "number" == typeof _i11["delete"] && ("number" == typeof _r17.retain || "object" == _typeof(_r17.retain) && null !== _r17.retain) && l.push(_i11);
                }
                return l.chop();
              }
            }, {
              key: "concat",
              value: function concat(t) {
                var e = new h(this.ops.slice());
                return t.ops.length > 0 && (e.push(t.ops[0]), e.ops = e.ops.concat(t.ops.slice(1))), e;
              }
            }, {
              key: "diff",
              value: function diff(t, e) {
                if (this.ops === t.ops) return new h();
                var n = [this, t].map(function (e) {
                    return e.map(function (n) {
                      if (null != n.insert) return "string" == typeof n.insert ? n.insert : c;
                      throw new Error("diff() called " + (e === t ? "on" : "with") + " non-document");
                    }).join("");
                  }),
                  i = new h(),
                  l = r(n[0], n[1], e, !0),
                  u = new a["default"](this.ops),
                  d = new a["default"](t.ops);
                return l.forEach(function (t) {
                  var e = t[1].length;
                  for (; e > 0;) {
                    var _n23 = 0;
                    switch (t[0]) {
                      case r.INSERT:
                        _n23 = Math.min(d.peekLength(), e), i.push(d.next(_n23));
                        break;
                      case r.DELETE:
                        _n23 = Math.min(e, u.peekLength()), u.next(_n23), i["delete"](_n23);
                        break;
                      case r.EQUAL:
                        _n23 = Math.min(u.peekLength(), d.peekLength(), e);
                        var _t35 = u.next(_n23),
                          _l9 = d.next(_n23);
                        s(_t35.insert, _l9.insert) ? i.retain(_n23, o["default"].diff(_t35.attributes, _l9.attributes)) : i.push(_l9)["delete"](_n23);
                    }
                    e -= _n23;
                  }
                }), i.chop();
              }
            }, {
              key: "eachLine",
              value: function eachLine(t) {
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "\n";
                var n = new a["default"](this.ops);
                var r = new h(),
                  i = 0;
                for (; n.hasNext();) {
                  if ("insert" !== n.peekType()) return;
                  var _s0 = n.peek(),
                    _o10 = l["default"].length(_s0) - n.peekLength(),
                    _a6 = "string" == typeof _s0.insert ? _s0.insert.indexOf(e, _o10) - _o10 : -1;
                  if (_a6 < 0) r.push(n.next());else if (_a6 > 0) r.push(n.next(_a6));else {
                    if (!1 === t(r, n.next(1).attributes || {}, i)) return;
                    i += 1, r = new h();
                  }
                }
                r.length() > 0 && t(r, {}, i);
              }
            }, {
              key: "invert",
              value: function invert(t) {
                var e = new h();
                return this.reduce(function (n, r) {
                  if (r.insert) e["delete"](l["default"].length(r));else {
                    if ("number" == typeof r.retain && null == r.attributes) return e.retain(r.retain), n + r.retain;
                    if (r["delete"] || "number" == typeof r.retain) {
                      var _i12 = r["delete"] || r.retain;
                      return t.slice(n, n + _i12).forEach(function (t) {
                        r["delete"] ? e.push(t) : r.retain && r.attributes && e.retain(l["default"].length(t), o["default"].invert(r.attributes, t.attributes));
                      }), n + _i12;
                    }
                    if ("object" == _typeof(r.retain) && null !== r.retain) {
                      var _i13 = t.slice(n, n + 1),
                        _s1 = new a["default"](_i13.ops).next(),
                        _u5 = u(r.retain, _s1.insert),
                        _u6 = _slicedToArray(_u5, 3),
                        _l0 = _u6[0],
                        _c4 = _u6[1],
                        d = _u6[2],
                        f = h.getHandler(_l0);
                      return e.retain(_defineProperty({}, _l0, f.invert(_c4, d)), o["default"].invert(r.attributes, _s1.attributes)), n + 1;
                    }
                  }
                  return n;
                }, 0), e.chop();
              }
            }, {
              key: "transform",
              value: function transform(t) {
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                if (e = !!e, "number" == typeof t) return this.transformPosition(t, e);
                var n = t,
                  r = new a["default"](this.ops),
                  i = new a["default"](n.ops),
                  s = new h();
                for (; r.hasNext() || i.hasNext();) if ("insert" !== r.peekType() || !e && "insert" === i.peekType()) {
                  if ("insert" === i.peekType()) s.push(i.next());else {
                    var _t36 = Math.min(r.peekLength(), i.peekLength()),
                      _n24 = r.next(_t36),
                      _l1 = i.next(_t36);
                    if (_n24["delete"]) continue;
                    if (_l1["delete"]) s.push(_l1);else {
                      var _r18 = _n24.retain,
                        _i14 = _l1.retain;
                      var _a7 = "object" == _typeof(_i14) && null !== _i14 ? _i14 : _t36;
                      if ("object" == _typeof(_r18) && null !== _r18 && "object" == _typeof(_i14) && null !== _i14) {
                        var _t37 = Object.keys(_r18)[0];
                        if (_t37 === Object.keys(_i14)[0]) {
                          var _n25 = h.getHandler(_t37);
                          _n25 && (_a7 = _defineProperty({}, _t37, _n25.transform(_r18[_t37], _i14[_t37], e)));
                        }
                      }
                      s.retain(_a7, o["default"].transform(_n24.attributes, _l1.attributes, e));
                    }
                  }
                } else s.retain(l["default"].length(r.next()));
                return s.chop();
              }
            }, {
              key: "transformPosition",
              value: function transformPosition(t) {
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                e = !!e;
                var n = new a["default"](this.ops);
                var r = 0;
                for (; n.hasNext() && r <= t;) {
                  var _i15 = n.peekLength(),
                    _s10 = n.peekType();
                  n.next(), "delete" !== _s10 ? ("insert" === _s10 && (r < t || !e) && (t += _i15), r += _i15) : t -= Math.min(_i15, t - r);
                }
                return t;
              }
            }], [{
              key: "registerEmbed",
              value: function registerEmbed(t, e) {
                this.handlers[t] = e;
              }
            }, {
              key: "unregisterEmbed",
              value: function unregisterEmbed(t) {
                delete this.handlers[t];
              }
            }, {
              key: "getHandler",
              value: function getHandler(t) {
                var e = this.handlers[t];
                if (!e) throw new Error("no handlers for embed type \"".concat(t, "\""));
                return e;
              }
            }]);
          }();
          h.Op = l["default"], h.OpIterator = a["default"], h.AttributeMap = o["default"], h.handlers = {}, e["default"] = h, t.exports = h, t.exports["default"] = h;
        },
        4123: function _(t, e) {
          "use strict";

          var n;
          Object.defineProperty(e, "__esModule", {
            value: !0
          }), function (t) {
            t.length = function (t) {
              return "number" == typeof t["delete"] ? t["delete"] : "number" == typeof t.retain ? t.retain : "object" == _typeof(t.retain) && null !== t.retain ? 1 : "string" == typeof t.insert ? t.insert.length : 1;
            };
          }(n || (n = {})), e["default"] = n;
        },
        7033: function _(t, e, n) {
          "use strict";

          Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var r = n(4123);
          e["default"] = /*#__PURE__*/function () {
            function _class2(t) {
              _classCallCheck(this, _class2);
              this.ops = t, this.index = 0, this.offset = 0;
            }
            return _createClass(_class2, [{
              key: "hasNext",
              value: function hasNext() {
                return this.peekLength() < 1 / 0;
              }
            }, {
              key: "next",
              value: function next(t) {
                t || (t = 1 / 0);
                var e = this.ops[this.index];
                if (e) {
                  var _n26 = this.offset,
                    i = r["default"].length(e);
                  if (t >= i - _n26 ? (t = i - _n26, this.index += 1, this.offset = 0) : this.offset += t, "number" == typeof e["delete"]) return {
                    "delete": t
                  };
                  {
                    var _r19 = {};
                    return e.attributes && (_r19.attributes = e.attributes), "number" == typeof e.retain ? _r19.retain = t : "object" == _typeof(e.retain) && null !== e.retain ? _r19.retain = e.retain : "string" == typeof e.insert ? _r19.insert = e.insert.substr(_n26, t) : _r19.insert = e.insert, _r19;
                  }
                }
                return {
                  retain: 1 / 0
                };
              }
            }, {
              key: "peek",
              value: function peek() {
                return this.ops[this.index];
              }
            }, {
              key: "peekLength",
              value: function peekLength() {
                return this.ops[this.index] ? r["default"].length(this.ops[this.index]) - this.offset : 1 / 0;
              }
            }, {
              key: "peekType",
              value: function peekType() {
                var t = this.ops[this.index];
                return t ? "number" == typeof t["delete"] ? "delete" : "number" == typeof t.retain || "object" == _typeof(t.retain) && null !== t.retain ? "retain" : "insert" : "retain";
              }
            }, {
              key: "rest",
              value: function rest() {
                if (this.hasNext()) {
                  if (0 === this.offset) return this.ops.slice(this.index);
                  {
                    var _t38 = this.offset,
                      _e30 = this.index,
                      _n27 = this.next(),
                      _r20 = this.ops.slice(this.index);
                    return this.offset = _t38, this.index = _e30, [_n27].concat(_r20);
                  }
                }
                return [];
              }
            }]);
          }();
        },
        8820: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return l;
            }
          });
          var r = n(8138),
            i = function i(t, e) {
              for (var n = t.length; n--;) if ((0, r.A)(t[n][0], e)) return n;
              return -1;
            },
            s = Array.prototype.splice;
          function o(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          o.prototype.clear = function () {
            this.__data__ = [], this.size = 0;
          }, o.prototype["delete"] = function (t) {
            var e = this.__data__,
              n = i(e, t);
            return !(n < 0 || (n == e.length - 1 ? e.pop() : s.call(e, n, 1), --this.size, 0));
          }, o.prototype.get = function (t) {
            var e = this.__data__,
              n = i(e, t);
            return n < 0 ? void 0 : e[n][1];
          }, o.prototype.has = function (t) {
            return i(this.__data__, t) > -1;
          }, o.prototype.set = function (t, e) {
            var n = this.__data__,
              r = i(n, t);
            return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
          };
          var l = o;
        },
        2461: function _(t, e, n) {
          "use strict";

          var r = n(2281),
            i = n(5507),
            s = (0, r.A)(i.A, "Map");
          e.A = s;
        },
        3558: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return d;
            }
          });
          var r = (0, n(2281).A)(Object, "create"),
            i = Object.prototype.hasOwnProperty,
            s = Object.prototype.hasOwnProperty;
          function o(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          o.prototype.clear = function () {
            this.__data__ = r ? r(null) : {}, this.size = 0;
          }, o.prototype["delete"] = function (t) {
            var e = this.has(t) && delete this.__data__[t];
            return this.size -= e ? 1 : 0, e;
          }, o.prototype.get = function (t) {
            var e = this.__data__;
            if (r) {
              var n = e[t];
              return "__lodash_hash_undefined__" === n ? void 0 : n;
            }
            return i.call(e, t) ? e[t] : void 0;
          }, o.prototype.has = function (t) {
            var e = this.__data__;
            return r ? void 0 !== e[t] : s.call(e, t);
          }, o.prototype.set = function (t, e) {
            var n = this.__data__;
            return this.size += this.has(t) ? 0 : 1, n[t] = r && void 0 === e ? "__lodash_hash_undefined__" : e, this;
          };
          var l = o,
            a = n(8820),
            c = n(2461),
            u = function u(t, e) {
              var n,
                r,
                i = t.__data__;
              return ("string" == (r = _typeof(n = e)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map;
            };
          function h(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n;) {
              var r = t[e];
              this.set(r[0], r[1]);
            }
          }
          h.prototype.clear = function () {
            this.size = 0, this.__data__ = {
              hash: new l(),
              map: new (c.A || a.A)(),
              string: new l()
            };
          }, h.prototype["delete"] = function (t) {
            var e = u(this, t)["delete"](t);
            return this.size -= e ? 1 : 0, e;
          }, h.prototype.get = function (t) {
            return u(this, t).get(t);
          }, h.prototype.has = function (t) {
            return u(this, t).has(t);
          }, h.prototype.set = function (t, e) {
            var n = u(this, t),
              r = n.size;
            return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
          };
          var d = h;
        },
        2673: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return l;
            }
          });
          var r = n(8820),
            i = n(2461),
            s = n(3558);
          function o(t) {
            var e = this.__data__ = new r.A(t);
            this.size = e.size;
          }
          o.prototype.clear = function () {
            this.__data__ = new r.A(), this.size = 0;
          }, o.prototype["delete"] = function (t) {
            var e = this.__data__,
              n = e["delete"](t);
            return this.size = e.size, n;
          }, o.prototype.get = function (t) {
            return this.__data__.get(t);
          }, o.prototype.has = function (t) {
            return this.__data__.has(t);
          }, o.prototype.set = function (t, e) {
            var n = this.__data__;
            if (n instanceof r.A) {
              var o = n.__data__;
              if (!i.A || o.length < 199) return o.push([t, e]), this.size = ++n.size, this;
              n = this.__data__ = new s.A(o);
            }
            return n.set(t, e), this.size = n.size, this;
          };
          var l = o;
        },
        439: function _(t, e, n) {
          "use strict";

          var r = n(5507).A.Symbol;
          e.A = r;
        },
        7218: function _(t, e, n) {
          "use strict";

          var r = n(5507).A.Uint8Array;
          e.A = r;
        },
        6753: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return c;
            }
          });
          var r = n(8412),
            i = n(723),
            s = n(776),
            o = n(3767),
            l = n(5755),
            a = Object.prototype.hasOwnProperty,
            c = function c(t, e) {
              var n = (0, i.A)(t),
                c = !n && (0, r.A)(t),
                u = !n && !c && (0, s.A)(t),
                h = !n && !c && !u && (0, l.A)(t),
                d = n || c || u || h,
                f = d ? function (t, e) {
                  for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
                  return r;
                }(t.length, String) : [],
                p = f.length;
              for (var g in t) !e && !a.call(t, g) || d && ("length" == g || u && ("offset" == g || "parent" == g) || h && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || (0, o.A)(g, p)) || f.push(g);
              return f;
            };
        },
        802: function _(t, e) {
          "use strict";

          e.A = function (t, e) {
            for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
            return t;
          };
        },
        6437: function _(t, e, n) {
          "use strict";

          var r = n(6770),
            i = n(8138),
            s = Object.prototype.hasOwnProperty;
          e.A = function (t, e, n) {
            var o = t[e];
            s.call(t, e) && (0, i.A)(o, n) && (void 0 !== n || e in t) || (0, r.A)(t, e, n);
          };
        },
        6770: function _(t, e, n) {
          "use strict";

          var r = n(7889);
          e.A = function (t, e, n) {
            "__proto__" == e && r.A ? (0, r.A)(t, e, {
              configurable: !0,
              enumerable: !0,
              value: n,
              writable: !0
            }) : t[e] = n;
          };
        },
        1381: function _(t, e, n) {
          "use strict";

          var r = n(802),
            i = n(723);
          e.A = function (t, e, n) {
            var s = e(t);
            return (0, i.A)(t) ? s : (0, r.A)(s, n(t));
          };
        },
        2159: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return u;
            }
          });
          var r = n(439),
            i = Object.prototype,
            s = i.hasOwnProperty,
            o = i.toString,
            l = r.A ? r.A.toStringTag : void 0,
            a = Object.prototype.toString,
            c = r.A ? r.A.toStringTag : void 0,
            u = function u(t) {
              return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : c && c in Object(t) ? function (t) {
                var e = s.call(t, l),
                  n = t[l];
                try {
                  t[l] = void 0;
                  var r = !0;
                } catch (t) {}
                var i = o.call(t);
                return r && (e ? t[l] = n : delete t[l]), i;
              }(t) : function (t) {
                return a.call(t);
              }(t);
            };
        },
        5771: function _(t, e) {
          "use strict";

          e.A = function (t) {
            return function (e) {
              return t(e);
            };
          };
        },
        2899: function _(t, e, n) {
          "use strict";

          var r = n(7218);
          e.A = function (t) {
            var e = new t.constructor(t.byteLength);
            return new r.A(e).set(new r.A(t)), e;
          };
        },
        3812: function _(t, e, n) {
          "use strict";

          var r = n(5507),
            i = "object" == ( false ? 0 : _typeof(exports)) && exports && !exports.nodeType && exports,
            s = i && "object" == ( false ? 0 : _typeof(module)) && module && !module.nodeType && module,
            o = s && s.exports === i ? r.A.Buffer : void 0,
            l = o ? o.allocUnsafe : void 0;
          e.A = function (t, e) {
            if (e) return t.slice();
            var n = t.length,
              r = l ? l(n) : new t.constructor(n);
            return t.copy(r), r;
          };
        },
        1827: function _(t, e, n) {
          "use strict";

          var r = n(2899);
          e.A = function (t, e) {
            var n = e ? (0, r.A)(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.length);
          };
        },
        4405: function _(t, e) {
          "use strict";

          e.A = function (t, e) {
            var n = -1,
              r = t.length;
            for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
            return e;
          };
        },
        9601: function _(t, e, n) {
          "use strict";

          var r = n(6437),
            i = n(6770);
          e.A = function (t, e, n, s) {
            var o = !n;
            n || (n = {});
            for (var l = -1, a = e.length; ++l < a;) {
              var c = e[l],
                u = s ? s(n[c], t[c], c, n, t) : void 0;
              void 0 === u && (u = t[c]), o ? (0, i.A)(n, c, u) : (0, r.A)(n, c, u);
            }
            return n;
          };
        },
        7889: function _(t, e, n) {
          "use strict";

          var r = n(2281),
            i = function () {
              try {
                var t = (0, r.A)(Object, "defineProperty");
                return t({}, "", {}), t;
              } catch (t) {}
            }();
          e.A = i;
        },
        9646: function _(t, e) {
          "use strict";

          var n = "object" == (typeof __webpack_require__.g === "undefined" ? "undefined" : _typeof(__webpack_require__.g)) && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
          e.A = n;
        },
        2816: function _(t, e, n) {
          "use strict";

          var r = n(1381),
            i = n(9844),
            s = n(3169);
          e.A = function (t) {
            return (0, r.A)(t, s.A, i.A);
          };
        },
        2281: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return m;
            }
          });
          var r,
            i = n(7572),
            s = n(5507).A["__core-js_shared__"],
            o = (r = /[^.]+$/.exec(s && s.keys && s.keys.IE_PROTO || "")) ? "Symbol(src)_1." + r : "",
            l = n(659),
            a = n(1543),
            c = /^\[object .+?Constructor\]$/,
            u = Function.prototype,
            h = Object.prototype,
            d = u.toString,
            f = h.hasOwnProperty,
            p = RegExp("^" + d.call(f).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
            g = function g(t) {
              return !(!(0, l.A)(t) || (e = t, o && o in e)) && ((0, i.A)(t) ? p : c).test((0, a.A)(t));
              var e;
            },
            m = function m(t, e) {
              var n = function (t, e) {
                return null == t ? void 0 : t[e];
              }(t, e);
              return g(n) ? n : void 0;
            };
        },
        8769: function _(t, e, n) {
          "use strict";

          var r = (0, n(2217).A)(Object.getPrototypeOf, Object);
          e.A = r;
        },
        9844: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return o;
            }
          });
          var r = n(6935),
            i = Object.prototype.propertyIsEnumerable,
            s = Object.getOwnPropertySymbols,
            o = s ? function (t) {
              return null == t ? [] : (t = Object(t), function (t, e) {
                for (var n = -1, r = null == t ? 0 : t.length, i = 0, s = []; ++n < r;) {
                  var o = t[n];
                  e(o, n, t) && (s[i++] = o);
                }
                return s;
              }(s(t), function (e) {
                return i.call(t, e);
              }));
            } : r.A;
        },
        7995: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return E;
            }
          });
          var r = n(2281),
            i = n(5507),
            s = (0, r.A)(i.A, "DataView"),
            o = n(2461),
            l = (0, r.A)(i.A, "Promise"),
            a = (0, r.A)(i.A, "Set"),
            c = (0, r.A)(i.A, "WeakMap"),
            u = n(2159),
            h = n(1543),
            d = "[object Map]",
            f = "[object Promise]",
            p = "[object Set]",
            g = "[object WeakMap]",
            m = "[object DataView]",
            b = (0, h.A)(s),
            y = (0, h.A)(o.A),
            v = (0, h.A)(l),
            A = (0, h.A)(a),
            x = (0, h.A)(c),
            N = u.A;
          (s && N(new s(new ArrayBuffer(1))) != m || o.A && N(new o.A()) != d || l && N(l.resolve()) != f || a && N(new a()) != p || c && N(new c()) != g) && (N = function N(t) {
            var e = (0, u.A)(t),
              n = "[object Object]" == e ? t.constructor : void 0,
              r = n ? (0, h.A)(n) : "";
            if (r) switch (r) {
              case b:
                return m;
              case y:
                return d;
              case v:
                return f;
              case A:
                return p;
              case x:
                return g;
            }
            return e;
          });
          var E = N;
        },
        1683: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return a;
            }
          });
          var r = n(659),
            i = Object.create,
            s = function () {
              function t() {}
              return function (e) {
                if (!(0, r.A)(e)) return {};
                if (i) return i(e);
                t.prototype = e;
                var n = new t();
                return t.prototype = void 0, n;
              };
            }(),
            o = n(8769),
            l = n(501),
            a = function a(t) {
              return "function" != typeof t.constructor || (0, l.A)(t) ? {} : s((0, o.A)(t));
            };
        },
        3767: function _(t, e) {
          "use strict";

          var n = /^(?:0|[1-9]\d*)$/;
          e.A = function (t, e) {
            var r = _typeof(t);
            return !!(e = null == e ? 9007199254740991 : e) && ("number" == r || "symbol" != r && n.test(t)) && t > -1 && t % 1 == 0 && t < e;
          };
        },
        501: function _(t, e) {
          "use strict";

          var n = Object.prototype;
          e.A = function (t) {
            var e = t && t.constructor;
            return t === ("function" == typeof e && e.prototype || n);
          };
        },
        8795: function _(t, e, n) {
          "use strict";

          var r = n(9646),
            i = "object" == ( false ? 0 : _typeof(exports)) && exports && !exports.nodeType && exports,
            s = i && "object" == ( false ? 0 : _typeof(module)) && module && !module.nodeType && module,
            o = s && s.exports === i && r.A.process,
            l = function () {
              try {
                return s && s.require && s.require("util").types || o && o.binding && o.binding("util");
              } catch (t) {}
            }();
          e.A = l;
        },
        2217: function _(t, e) {
          "use strict";

          e.A = function (t, e) {
            return function (n) {
              return t(e(n));
            };
          };
        },
        5507: function _(t, e, n) {
          "use strict";

          var r = n(9646),
            i = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self && self.Object === Object && self,
            s = r.A || i || Function("return this")();
          e.A = s;
        },
        1543: function _(t, e) {
          "use strict";

          var n = Function.prototype.toString;
          e.A = function (t) {
            if (null != t) {
              try {
                return n.call(t);
              } catch (t) {}
              try {
                return t + "";
              } catch (t) {}
            }
            return "";
          };
        },
        3707: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return $;
            }
          });
          var r = n(2673),
            i = n(6437),
            s = n(9601),
            o = n(3169),
            l = n(2624),
            a = n(3812),
            c = n(4405),
            u = n(9844),
            h = n(802),
            d = n(8769),
            f = n(6935),
            p = Object.getOwnPropertySymbols ? function (t) {
              for (var e = []; t;) (0, h.A)(e, (0, u.A)(t)), t = (0, d.A)(t);
              return e;
            } : f.A,
            g = n(2816),
            m = n(1381),
            b = function b(t) {
              return (0, m.A)(t, l.A, p);
            },
            y = n(7995),
            v = Object.prototype.hasOwnProperty,
            A = n(2899),
            x = /\w*$/,
            N = n(439),
            E = N.A ? N.A.prototype : void 0,
            w = E ? E.valueOf : void 0,
            q = n(1827),
            k = function k(t, e, n) {
              var r,
                i,
                s,
                o = t.constructor;
              switch (e) {
                case "[object ArrayBuffer]":
                  return (0, A.A)(t);
                case "[object Boolean]":
                case "[object Date]":
                  return new o(+t);
                case "[object DataView]":
                  return function (t, e) {
                    var n = e ? (0, A.A)(t.buffer) : t.buffer;
                    return new t.constructor(n, t.byteOffset, t.byteLength);
                  }(t, n);
                case "[object Float32Array]":
                case "[object Float64Array]":
                case "[object Int8Array]":
                case "[object Int16Array]":
                case "[object Int32Array]":
                case "[object Uint8Array]":
                case "[object Uint8ClampedArray]":
                case "[object Uint16Array]":
                case "[object Uint32Array]":
                  return (0, q.A)(t, n);
                case "[object Map]":
                case "[object Set]":
                  return new o();
                case "[object Number]":
                case "[object String]":
                  return new o(t);
                case "[object RegExp]":
                  return (s = new (i = t).constructor(i.source, x.exec(i))).lastIndex = i.lastIndex, s;
                case "[object Symbol]":
                  return r = t, w ? Object(w.call(r)) : {};
              }
            },
            _ = n(1683),
            L = n(723),
            S = n(776),
            O = n(7948),
            T = n(5771),
            j = n(8795),
            C = j.A && j.A.isMap,
            R = C ? (0, T.A)(C) : function (t) {
              return (0, O.A)(t) && "[object Map]" == (0, y.A)(t);
            },
            I = n(659),
            B = j.A && j.A.isSet,
            M = B ? (0, T.A)(B) : function (t) {
              return (0, O.A)(t) && "[object Set]" == (0, y.A)(t);
            },
            U = "[object Arguments]",
            D = "[object Function]",
            P = "[object Object]",
            z = {};
          z[U] = z["[object Array]"] = z["[object ArrayBuffer]"] = z["[object DataView]"] = z["[object Boolean]"] = z["[object Date]"] = z["[object Float32Array]"] = z["[object Float64Array]"] = z["[object Int8Array]"] = z["[object Int16Array]"] = z["[object Int32Array]"] = z["[object Map]"] = z["[object Number]"] = z[P] = z["[object RegExp]"] = z["[object Set]"] = z["[object String]"] = z["[object Symbol]"] = z["[object Uint8Array]"] = z["[object Uint8ClampedArray]"] = z["[object Uint16Array]"] = z["[object Uint32Array]"] = !0, z["[object Error]"] = z[D] = z["[object WeakMap]"] = !1;
          var F = function t(e, n, h, d, f, m) {
              var A,
                x = 1 & n,
                N = 2 & n,
                E = 4 & n;
              if (h && (A = f ? h(e, d, f, m) : h(e)), void 0 !== A) return A;
              if (!(0, I.A)(e)) return e;
              var w = (0, L.A)(e);
              if (w) {
                if (A = function (t) {
                  var e = t.length,
                    n = new t.constructor(e);
                  return e && "string" == typeof t[0] && v.call(t, "index") && (n.index = t.index, n.input = t.input), n;
                }(e), !x) return (0, c.A)(e, A);
              } else {
                var q = (0, y.A)(e),
                  O = q == D || "[object GeneratorFunction]" == q;
                if ((0, S.A)(e)) return (0, a.A)(e, x);
                if (q == P || q == U || O && !f) {
                  if (A = N || O ? {} : (0, _.A)(e), !x) return N ? function (t, e) {
                    return (0, s.A)(t, p(t), e);
                  }(e, function (t, e) {
                    return t && (0, s.A)(e, (0, l.A)(e), t);
                  }(A, e)) : function (t, e) {
                    return (0, s.A)(t, (0, u.A)(t), e);
                  }(e, function (t, e) {
                    return t && (0, s.A)(e, (0, o.A)(e), t);
                  }(A, e));
                } else {
                  if (!z[q]) return f ? e : {};
                  A = k(e, q, x);
                }
              }
              m || (m = new r.A());
              var T = m.get(e);
              if (T) return T;
              m.set(e, A), M(e) ? e.forEach(function (r) {
                A.add(t(r, n, h, r, e, m));
              }) : R(e) && e.forEach(function (r, i) {
                A.set(i, t(r, n, h, i, e, m));
              });
              var j = E ? N ? b : g.A : N ? l.A : o.A,
                C = w ? void 0 : j(e);
              return function (t, e) {
                for (var n = -1, r = null == t ? 0 : t.length; ++n < r && !1 !== e(t[n], n, t););
              }(C || e, function (r, s) {
                C && (r = e[s = r]), (0, i.A)(A, s, t(r, n, h, s, e, m));
              }), A;
            },
            $ = function $(t) {
              return F(t, 5);
            };
        },
        8138: function _(t, e) {
          "use strict";

          e.A = function (t, e) {
            return t === e || t != t && e != e;
          };
        },
        8412: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return u;
            }
          });
          var r = n(2159),
            i = n(7948),
            s = function s(t) {
              return (0, i.A)(t) && "[object Arguments]" == (0, r.A)(t);
            },
            o = Object.prototype,
            l = o.hasOwnProperty,
            a = o.propertyIsEnumerable,
            c = s(function () {
              return arguments;
            }()) ? s : function (t) {
              return (0, i.A)(t) && l.call(t, "callee") && !a.call(t, "callee");
            },
            u = c;
        },
        723: function _(t, e) {
          "use strict";

          var n = Array.isArray;
          e.A = n;
        },
        3628: function _(t, e, n) {
          "use strict";

          var r = n(7572),
            i = n(1628);
          e.A = function (t) {
            return null != t && (0, i.A)(t.length) && !(0, r.A)(t);
          };
        },
        776: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return l;
            }
          });
          var r = n(5507),
            i = "object" == ( false ? 0 : _typeof(exports)) && exports && !exports.nodeType && exports,
            s = i && "object" == ( false ? 0 : _typeof(module)) && module && !module.nodeType && module,
            o = s && s.exports === i ? r.A.Buffer : void 0,
            l = (o ? o.isBuffer : void 0) || function () {
              return !1;
            };
        },
        5123: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return S;
            }
          });
          var r = n(2673),
            i = n(3558);
          function s(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.__data__ = new i.A(); ++e < n;) this.add(t[e]);
          }
          s.prototype.add = s.prototype.push = function (t) {
            return this.__data__.set(t, "__lodash_hash_undefined__"), this;
          }, s.prototype.has = function (t) {
            return this.__data__.has(t);
          };
          var o = s,
            l = function l(t, e) {
              for (var n = -1, r = null == t ? 0 : t.length; ++n < r;) if (e(t[n], n, t)) return !0;
              return !1;
            },
            a = function a(t, e, n, r, i, s) {
              var a = 1 & n,
                c = t.length,
                u = e.length;
              if (c != u && !(a && u > c)) return !1;
              var h = s.get(t),
                d = s.get(e);
              if (h && d) return h == e && d == t;
              var f = -1,
                p = !0,
                g = 2 & n ? new o() : void 0;
              for (s.set(t, e), s.set(e, t); ++f < c;) {
                var m = t[f],
                  b = e[f];
                if (r) var y = a ? r(b, m, f, e, t, s) : r(m, b, f, t, e, s);
                if (void 0 !== y) {
                  if (y) continue;
                  p = !1;
                  break;
                }
                if (g) {
                  if (!l(e, function (t, e) {
                    if (o = e, !g.has(o) && (m === t || i(m, t, n, r, s))) return g.push(e);
                    var o;
                  })) {
                    p = !1;
                    break;
                  }
                } else if (m !== b && !i(m, b, n, r, s)) {
                  p = !1;
                  break;
                }
              }
              return s["delete"](t), s["delete"](e), p;
            },
            c = n(439),
            u = n(7218),
            h = n(8138),
            d = function d(t) {
              var e = -1,
                n = Array(t.size);
              return t.forEach(function (t, r) {
                n[++e] = [r, t];
              }), n;
            },
            f = function f(t) {
              var e = -1,
                n = Array(t.size);
              return t.forEach(function (t) {
                n[++e] = t;
              }), n;
            },
            p = c.A ? c.A.prototype : void 0,
            g = p ? p.valueOf : void 0,
            m = n(2816),
            b = Object.prototype.hasOwnProperty,
            y = n(7995),
            v = n(723),
            A = n(776),
            x = n(5755),
            N = "[object Arguments]",
            E = "[object Array]",
            w = "[object Object]",
            q = Object.prototype.hasOwnProperty,
            k = function k(t, e, n, i, s, o) {
              var l = (0, v.A)(t),
                c = (0, v.A)(e),
                p = l ? E : (0, y.A)(t),
                k = c ? E : (0, y.A)(e),
                _ = (p = p == N ? w : p) == w,
                L = (k = k == N ? w : k) == w,
                S = p == k;
              if (S && (0, A.A)(t)) {
                if (!(0, A.A)(e)) return !1;
                l = !0, _ = !1;
              }
              if (S && !_) return o || (o = new r.A()), l || (0, x.A)(t) ? a(t, e, n, i, s, o) : function (t, e, n, r, i, s, o) {
                switch (n) {
                  case "[object DataView]":
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                    t = t.buffer, e = e.buffer;
                  case "[object ArrayBuffer]":
                    return !(t.byteLength != e.byteLength || !s(new u.A(t), new u.A(e)));
                  case "[object Boolean]":
                  case "[object Date]":
                  case "[object Number]":
                    return (0, h.A)(+t, +e);
                  case "[object Error]":
                    return t.name == e.name && t.message == e.message;
                  case "[object RegExp]":
                  case "[object String]":
                    return t == e + "";
                  case "[object Map]":
                    var l = d;
                  case "[object Set]":
                    var c = 1 & r;
                    if (l || (l = f), t.size != e.size && !c) return !1;
                    var p = o.get(t);
                    if (p) return p == e;
                    r |= 2, o.set(t, e);
                    var m = a(l(t), l(e), r, i, s, o);
                    return o["delete"](t), m;
                  case "[object Symbol]":
                    if (g) return g.call(t) == g.call(e);
                }
                return !1;
              }(t, e, p, n, i, s, o);
              if (!(1 & n)) {
                var O = _ && q.call(t, "__wrapped__"),
                  T = L && q.call(e, "__wrapped__");
                if (O || T) {
                  var j = O ? t.value() : t,
                    C = T ? e.value() : e;
                  return o || (o = new r.A()), s(j, C, n, i, o);
                }
              }
              return !!S && (o || (o = new r.A()), function (t, e, n, r, i, s) {
                var o = 1 & n,
                  l = (0, m.A)(t),
                  a = l.length;
                if (a != (0, m.A)(e).length && !o) return !1;
                for (var c = a; c--;) {
                  var u = l[c];
                  if (!(o ? u in e : b.call(e, u))) return !1;
                }
                var h = s.get(t),
                  d = s.get(e);
                if (h && d) return h == e && d == t;
                var f = !0;
                s.set(t, e), s.set(e, t);
                for (var p = o; ++c < a;) {
                  var g = t[u = l[c]],
                    y = e[u];
                  if (r) var v = o ? r(y, g, u, e, t, s) : r(g, y, u, t, e, s);
                  if (!(void 0 === v ? g === y || i(g, y, n, r, s) : v)) {
                    f = !1;
                    break;
                  }
                  p || (p = "constructor" == u);
                }
                if (f && !p) {
                  var A = t.constructor,
                    x = e.constructor;
                  A == x || !("constructor" in t) || !("constructor" in e) || "function" == typeof A && A instanceof A && "function" == typeof x && x instanceof x || (f = !1);
                }
                return s["delete"](t), s["delete"](e), f;
              }(t, e, n, i, s, o));
            },
            _ = n(7948),
            L = function t(e, n, r, i, s) {
              return e === n || (null == e || null == n || !(0, _.A)(e) && !(0, _.A)(n) ? e != e && n != n : k(e, n, r, i, t, s));
            },
            S = function S(t, e) {
              return L(t, e);
            };
        },
        7572: function _(t, e, n) {
          "use strict";

          var r = n(2159),
            i = n(659);
          e.A = function (t) {
            if (!(0, i.A)(t)) return !1;
            var e = (0, r.A)(t);
            return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e;
          };
        },
        1628: function _(t, e) {
          "use strict";

          e.A = function (t) {
            return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991;
          };
        },
        659: function _(t, e) {
          "use strict";

          e.A = function (t) {
            var e = _typeof(t);
            return null != t && ("object" == e || "function" == e);
          };
        },
        7948: function _(t, e) {
          "use strict";

          e.A = function (t) {
            return null != t && "object" == _typeof(t);
          };
        },
        5755: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return u;
            }
          });
          var r = n(2159),
            i = n(1628),
            s = n(7948),
            o = {};
          o["[object Float32Array]"] = o["[object Float64Array]"] = o["[object Int8Array]"] = o["[object Int16Array]"] = o["[object Int32Array]"] = o["[object Uint8Array]"] = o["[object Uint8ClampedArray]"] = o["[object Uint16Array]"] = o["[object Uint32Array]"] = !0, o["[object Arguments]"] = o["[object Array]"] = o["[object ArrayBuffer]"] = o["[object Boolean]"] = o["[object DataView]"] = o["[object Date]"] = o["[object Error]"] = o["[object Function]"] = o["[object Map]"] = o["[object Number]"] = o["[object Object]"] = o["[object RegExp]"] = o["[object Set]"] = o["[object String]"] = o["[object WeakMap]"] = !1;
          var l = n(5771),
            a = n(8795),
            c = a.A && a.A.isTypedArray,
            u = c ? (0, l.A)(c) : function (t) {
              return (0, s.A)(t) && (0, i.A)(t.length) && !!o[(0, r.A)(t)];
            };
        },
        3169: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return a;
            }
          });
          var r = n(6753),
            i = n(501),
            s = (0, n(2217).A)(Object.keys, Object),
            o = Object.prototype.hasOwnProperty,
            l = n(3628),
            a = function a(t) {
              return (0, l.A)(t) ? (0, r.A)(t) : function (t) {
                if (!(0, i.A)(t)) return s(t);
                var e = [];
                for (var n in Object(t)) o.call(t, n) && "constructor" != n && e.push(n);
                return e;
              }(t);
            };
        },
        2624: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return c;
            }
          });
          var r = n(6753),
            i = n(659),
            s = n(501),
            o = Object.prototype.hasOwnProperty,
            l = function l(t) {
              if (!(0, i.A)(t)) return function (t) {
                var e = [];
                if (null != t) for (var n in Object(t)) e.push(n);
                return e;
              }(t);
              var e = (0, s.A)(t),
                n = [];
              for (var r in t) ("constructor" != r || !e && o.call(t, r)) && n.push(r);
              return n;
            },
            a = n(3628),
            c = function c(t) {
              return (0, a.A)(t) ? (0, r.A)(t, !0) : l(t);
            };
        },
        8347: function _(t, e, n) {
          "use strict";

          n.d(e, {
            A: function A() {
              return H;
            }
          });
          var r,
            i,
            s,
            o,
            l = n(2673),
            a = n(6770),
            c = n(8138),
            u = function u(t, e, n) {
              (void 0 !== n && !(0, c.A)(t[e], n) || void 0 === n && !(e in t)) && (0, a.A)(t, e, n);
            },
            h = function h(t, e, n) {
              for (var r = -1, i = Object(t), s = n(t), o = s.length; o--;) {
                var l = s[++r];
                if (!1 === e(i[l], l, i)) break;
              }
              return t;
            },
            d = n(3812),
            f = n(1827),
            p = n(4405),
            g = n(1683),
            m = n(8412),
            b = n(723),
            y = n(3628),
            v = n(7948),
            A = n(776),
            x = n(7572),
            N = n(659),
            E = n(2159),
            w = n(8769),
            q = Function.prototype,
            k = Object.prototype,
            _ = q.toString,
            L = k.hasOwnProperty,
            S = _.call(Object),
            O = n(5755),
            T = function T(t, e) {
              if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e];
            },
            j = n(9601),
            C = n(2624),
            R = function R(t, e, n, r, i, s, o) {
              var l,
                a = T(t, n),
                c = T(e, n),
                h = o.get(c);
              if (h) u(t, n, h);else {
                var q = s ? s(a, c, n + "", t, e, o) : void 0,
                  k = void 0 === q;
                if (k) {
                  var R = (0, b.A)(c),
                    I = !R && (0, A.A)(c),
                    B = !R && !I && (0, O.A)(c);
                  q = c, R || I || B ? (0, b.A)(a) ? q = a : (l = a, (0, v.A)(l) && (0, y.A)(l) ? q = (0, p.A)(a) : I ? (k = !1, q = (0, d.A)(c, !0)) : B ? (k = !1, q = (0, f.A)(c, !0)) : q = []) : function (t) {
                    if (!(0, v.A)(t) || "[object Object]" != (0, E.A)(t)) return !1;
                    var e = (0, w.A)(t);
                    if (null === e) return !0;
                    var n = L.call(e, "constructor") && e.constructor;
                    return "function" == typeof n && n instanceof n && _.call(n) == S;
                  }(c) || (0, m.A)(c) ? (q = a, (0, m.A)(a) ? q = function (t) {
                    return (0, j.A)(t, (0, C.A)(t));
                  }(a) : (0, N.A)(a) && !(0, x.A)(a) || (q = (0, g.A)(c))) : k = !1;
                }
                k && (o.set(c, q), i(q, c, r, s, o), o["delete"](c)), u(t, n, q);
              }
            },
            I = function t(e, n, r, i, s) {
              e !== n && h(n, function (o, a) {
                if (s || (s = new l.A()), (0, N.A)(o)) R(e, n, a, r, t, i, s);else {
                  var c = i ? i(T(e, a), o, a + "", e, n, s) : void 0;
                  void 0 === c && (c = o), u(e, a, c);
                }
              }, C.A);
            },
            B = function B(t) {
              return t;
            },
            M = Math.max,
            U = n(7889),
            D = U.A ? function (t, e) {
              return (0, U.A)(t, "toString", {
                configurable: !0,
                enumerable: !1,
                value: (n = e, function () {
                  return n;
                }),
                writable: !0
              });
              var n;
            } : B,
            P = Date.now,
            z = (r = D, i = 0, s = 0, function () {
              var t = P(),
                e = 16 - (t - s);
              if (s = t, e > 0) {
                if (++i >= 800) return arguments[0];
              } else i = 0;
              return r.apply(void 0, arguments);
            }),
            F = function F(t, e) {
              return z(function (t, e, n) {
                return e = M(void 0 === e ? t.length - 1 : e, 0), function () {
                  for (var r = arguments, i = -1, s = M(r.length - e, 0), o = Array(s); ++i < s;) o[i] = r[e + i];
                  i = -1;
                  for (var l = Array(e + 1); ++i < e;) l[i] = r[i];
                  return l[e] = n(o), function (t, e, n) {
                    switch (n.length) {
                      case 0:
                        return t.call(e);
                      case 1:
                        return t.call(e, n[0]);
                      case 2:
                        return t.call(e, n[0], n[1]);
                      case 3:
                        return t.call(e, n[0], n[1], n[2]);
                    }
                    return t.apply(e, n);
                  }(t, this, l);
                };
              }(t, e, B), t + "");
            },
            $ = n(3767),
            H = (o = function o(t, e, n) {
              I(t, e, n);
            }, F(function (t, e) {
              var n = -1,
                r = e.length,
                i = r > 1 ? e[r - 1] : void 0,
                s = r > 2 ? e[2] : void 0;
              for (i = o.length > 3 && "function" == typeof i ? (r--, i) : void 0, s && function (t, e, n) {
                if (!(0, N.A)(n)) return !1;
                var r = _typeof(e);
                return !!("number" == r ? (0, y.A)(n) && (0, $.A)(e, n.length) : "string" == r && e in n) && (0, c.A)(n[e], t);
              }(e[0], e[1], s) && (i = r < 3 ? void 0 : i, r = 1), t = Object(t); ++n < r;) {
                var l = e[n];
                l && o(t, l, n);
              }
              return t;
            }));
        },
        6935: function _(t, e) {
          "use strict";

          e.A = function () {
            return [];
          };
        },
        6003: function _(t, e, n) {
          "use strict";

          n.r(e), n.d(e, {
            Attributor: function Attributor() {
              return i;
            },
            AttributorStore: function AttributorStore() {
              return d;
            },
            BlockBlot: function BlockBlot() {
              return w;
            },
            ClassAttributor: function ClassAttributor() {
              return c;
            },
            ContainerBlot: function ContainerBlot() {
              return k;
            },
            EmbedBlot: function EmbedBlot() {
              return _;
            },
            InlineBlot: function InlineBlot() {
              return N;
            },
            LeafBlot: function LeafBlot() {
              return m;
            },
            ParentBlot: function ParentBlot() {
              return A;
            },
            Registry: function Registry() {
              return l;
            },
            Scope: function Scope() {
              return r;
            },
            ScrollBlot: function ScrollBlot() {
              return O;
            },
            StyleAttributor: function StyleAttributor() {
              return h;
            },
            TextBlot: function TextBlot() {
              return j;
            }
          });
          var r = function (t) {
            return t[t.TYPE = 3] = "TYPE", t[t.LEVEL = 12] = "LEVEL", t[t.ATTRIBUTE = 13] = "ATTRIBUTE", t[t.BLOT = 14] = "BLOT", t[t.INLINE = 7] = "INLINE", t[t.BLOCK = 11] = "BLOCK", t[t.BLOCK_BLOT = 10] = "BLOCK_BLOT", t[t.INLINE_BLOT = 6] = "INLINE_BLOT", t[t.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", t[t.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", t[t.ANY = 15] = "ANY", t;
          }(r || {});
          var i = /*#__PURE__*/function () {
            function i(t, e) {
              var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              _classCallCheck(this, i);
              this.attrName = t, this.keyName = e;
              var _i16 = r.TYPE & r.ATTRIBUTE;
              this.scope = null != n.scope ? n.scope & r.LEVEL | _i16 : r.ATTRIBUTE, null != n.whitelist && (this.whitelist = n.whitelist);
            }
            return _createClass(i, [{
              key: "add",
              value: function add(t, e) {
                return !!this.canAdd(t, e) && (t.setAttribute(this.keyName, e), !0);
              }
            }, {
              key: "canAdd",
              value: function canAdd(t, e) {
                return null == this.whitelist || ("string" == typeof e ? this.whitelist.indexOf(e.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e) > -1);
              }
            }, {
              key: "remove",
              value: function remove(t) {
                t.removeAttribute(this.keyName);
              }
            }, {
              key: "value",
              value: function value(t) {
                var e = t.getAttribute(this.keyName);
                return this.canAdd(t, e) && e ? e : "";
              }
            }], [{
              key: "keys",
              value: function keys(t) {
                return Array.from(t.attributes).map(function (t) {
                  return t.name;
                });
              }
            }]);
          }();
          var s = /*#__PURE__*/function (_Error) {
            function s(t) {
              var _this46;
              _classCallCheck(this, s);
              _this46 = _callSuper(this, s, [t = "[Parchment] " + t]), _this46.message = t, _this46.name = _this46.constructor.name;
              return _this46;
            }
            _inherits(s, _Error);
            return _createClass(s);
          }(/*#__PURE__*/_wrapNativeSuper(Error));
          var o = /*#__PURE__*/function () {
            function t() {
              _classCallCheck(this, t);
              this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
            }
            return _createClass(t, [{
              key: "create",
              value: function create(e, n, r) {
                var i = this.query(n);
                if (null == i) throw new s("Unable to create ".concat(n, " blot"));
                var o = i,
                  l = n instanceof Node || n.nodeType === Node.TEXT_NODE ? n : o.create(r),
                  a = new o(e, l, r);
                return t.blots.set(a.domNode, a), a;
              }
            }, {
              key: "find",
              value: function find(e) {
                var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                return t.find(e, n);
              }
            }, {
              key: "query",
              value: function query(_t40) {
                var _this47 = this;
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.ANY;
                var n;
                return "string" == typeof _t40 ? n = this.types[_t40] || this.attributes[_t40] : _t40 instanceof Text || _t40.nodeType === Node.TEXT_NODE ? n = this.types.text : "number" == typeof _t40 ? _t40 & r.LEVEL & r.BLOCK ? n = this.types.block : _t40 & r.LEVEL & r.INLINE && (n = this.types.inline) : _t40 instanceof Element && ((_t40.getAttribute("class") || "").split(/\s+/).some(function (_t41) {
                  return n = _this47.classes[_t41], !!n;
                }), n = n || this.tags[_t40.tagName]), null == n ? null : "scope" in n && e & r.LEVEL & n.scope && e & r.TYPE & n.scope ? n : null;
              }
            }, {
              key: "register",
              value: function register() {
                var _this48 = this;
                for (var _len2 = arguments.length, _t42 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  _t42[_key2] = arguments[_key2];
                }
                return _t42.map(function (_t43) {
                  var e = "blotName" in _t43,
                    n = "attrName" in _t43;
                  if (!e && !n) throw new s("Invalid definition");
                  if (e && "abstract" === _t43.blotName) throw new s("Cannot register abstract class");
                  var r = e ? _t43.blotName : n ? _t43.attrName : void 0;
                  return _this48.types[r] = _t43, n ? "string" == typeof _t43.keyName && (_this48.attributes[_t43.keyName] = _t43) : e && (_t43.className && (_this48.classes[_t43.className] = _t43), _t43.tagName && (Array.isArray(_t43.tagName) ? _t43.tagName = _t43.tagName.map(function (_t44) {
                    return _t44.toUpperCase();
                  }) : _t43.tagName = _t43.tagName.toUpperCase(), (Array.isArray(_t43.tagName) ? _t43.tagName : [_t43.tagName]).forEach(function (e) {
                    (null == _this48.tags[e] || null == _t43.className) && (_this48.tags[e] = _t43);
                  }))), _t43;
                });
              }
            }], [{
              key: "find",
              value: function find(_t39) {
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                if (null == _t39) return null;
                if (this.blots.has(_t39)) return this.blots.get(_t39) || null;
                if (e) {
                  var _n28 = null;
                  try {
                    _n28 = _t39.parentNode;
                  } catch (_unused) {
                    return null;
                  }
                  return this.find(_n28, e);
                }
                return null;
              }
            }]);
          }();
          o.blots = new WeakMap();
          var l = o;
          function a(t, e) {
            return (t.getAttribute("class") || "").split(/\s+/).filter(function (t) {
              return 0 === t.indexOf("".concat(e, "-"));
            });
          }
          var c = /*#__PURE__*/function (_i17) {
            function c() {
              _classCallCheck(this, c);
              return _callSuper(this, c, arguments);
            }
            _inherits(c, _i17);
            return _createClass(c, [{
              key: "add",
              value: function add(t, e) {
                return !!this.canAdd(t, e) && (this.remove(t), t.classList.add("".concat(this.keyName, "-").concat(e)), !0);
              }
            }, {
              key: "remove",
              value: function remove(t) {
                a(t, this.keyName).forEach(function (e) {
                  t.classList.remove(e);
                }), 0 === t.classList.length && t.removeAttribute("class");
              }
            }, {
              key: "value",
              value: function value(t) {
                var e = (a(t, this.keyName)[0] || "").slice(this.keyName.length + 1);
                return this.canAdd(t, e) ? e : "";
              }
            }], [{
              key: "keys",
              value: function keys(t) {
                return (t.getAttribute("class") || "").split(/\s+/).map(function (t) {
                  return t.split("-").slice(0, -1).join("-");
                });
              }
            }]);
          }(i);
          function u(t) {
            var e = t.split("-"),
              n = e.slice(1).map(function (t) {
                return t[0].toUpperCase() + t.slice(1);
              }).join("");
            return e[0] + n;
          }
          var h = /*#__PURE__*/function (_i18) {
              function h() {
                _classCallCheck(this, h);
                return _callSuper(this, h, arguments);
              }
              _inherits(h, _i18);
              return _createClass(h, [{
                key: "add",
                value: function add(t, e) {
                  return !!this.canAdd(t, e) && (t.style[u(this.keyName)] = e, !0);
                }
              }, {
                key: "remove",
                value: function remove(t) {
                  t.style[u(this.keyName)] = "", t.getAttribute("style") || t.removeAttribute("style");
                }
              }, {
                key: "value",
                value: function value(t) {
                  var e = t.style[u(this.keyName)];
                  return this.canAdd(t, e) ? e : "";
                }
              }], [{
                key: "keys",
                value: function keys(t) {
                  return (t.getAttribute("style") || "").split(";").map(function (t) {
                    return t.split(":")[0].trim();
                  });
                }
              }]);
            }(i),
            d = /*#__PURE__*/function () {
              function d(t) {
                _classCallCheck(this, d);
                this.attributes = {}, this.domNode = t, this.build();
              }
              return _createClass(d, [{
                key: "attribute",
                value: function attribute(t, e) {
                  e ? t.add(this.domNode, e) && (null != t.value(this.domNode) ? this.attributes[t.attrName] = t : delete this.attributes[t.attrName]) : (t.remove(this.domNode), delete this.attributes[t.attrName]);
                }
              }, {
                key: "build",
                value: function build() {
                  var _this49 = this;
                  this.attributes = {};
                  var t = l.find(this.domNode);
                  if (null == t) return;
                  var e = i.keys(this.domNode),
                    n = c.keys(this.domNode),
                    s = h.keys(this.domNode);
                  e.concat(n).concat(s).forEach(function (e) {
                    var n = t.scroll.query(e, r.ATTRIBUTE);
                    n instanceof i && (_this49.attributes[n.attrName] = n);
                  });
                }
              }, {
                key: "copy",
                value: function copy(t) {
                  var _this50 = this;
                  Object.keys(this.attributes).forEach(function (e) {
                    var n = _this50.attributes[e].value(_this50.domNode);
                    t.format(e, n);
                  });
                }
              }, {
                key: "move",
                value: function move(t) {
                  var _this51 = this;
                  this.copy(t), Object.keys(this.attributes).forEach(function (t) {
                    _this51.attributes[t].remove(_this51.domNode);
                  }), this.attributes = {};
                }
              }, {
                key: "values",
                value: function values() {
                  var _this52 = this;
                  return Object.keys(this.attributes).reduce(function (t, e) {
                    return t[e] = _this52.attributes[e].value(_this52.domNode), t;
                  }, {});
                }
              }]);
            }(),
            f = /*#__PURE__*/function () {
              function f(t, e) {
                _classCallCheck(this, f);
                this.scroll = t, this.domNode = e, l.blots.set(e, this), this.prev = null, this.next = null;
              }
              return _createClass(f, [{
                key: "statics",
                get: function get() {
                  return this.constructor;
                }
              }, {
                key: "attach",
                value: function attach() {}
              }, {
                key: "clone",
                value: function clone() {
                  var t = this.domNode.cloneNode(!1);
                  return this.scroll.create(t);
                }
              }, {
                key: "detach",
                value: function detach() {
                  null != this.parent && this.parent.removeChild(this), l.blots["delete"](this.domNode);
                }
              }, {
                key: "deleteAt",
                value: function deleteAt(t, e) {
                  this.isolate(t, e).remove();
                }
              }, {
                key: "formatAt",
                value: function formatAt(t, e, n, i) {
                  var s = this.isolate(t, e);
                  if (null != this.scroll.query(n, r.BLOT) && i) s.wrap(n, i);else if (null != this.scroll.query(n, r.ATTRIBUTE)) {
                    var _t45 = this.scroll.create(this.statics.scope);
                    s.wrap(_t45), _t45.format(n, i);
                  }
                }
              }, {
                key: "insertAt",
                value: function insertAt(t, e, n) {
                  var r = null == n ? this.scroll.create("text", e) : this.scroll.create(e, n),
                    i = this.split(t);
                  this.parent.insertBefore(r, i || void 0);
                }
              }, {
                key: "isolate",
                value: function isolate(t, e) {
                  var n = this.split(t);
                  if (null == n) throw new Error("Attempt to isolate at end");
                  return n.split(e), n;
                }
              }, {
                key: "length",
                value: function length() {
                  return 1;
                }
              }, {
                key: "offset",
                value: function offset() {
                  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.parent;
                  return null == this.parent || this === t ? 0 : this.parent.children.offset(this) + this.parent.offset(t);
                }
              }, {
                key: "optimize",
                value: function optimize(t) {
                  this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
                }
              }, {
                key: "remove",
                value: function remove() {
                  null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();
                }
              }, {
                key: "replaceWith",
                value: function replaceWith(t, e) {
                  var n = "string" == typeof t ? this.scroll.create(t, e) : t;
                  return null != this.parent && (this.parent.insertBefore(n, this.next || void 0), this.remove()), n;
                }
              }, {
                key: "split",
                value: function split(t, e) {
                  return 0 === t ? this : this.next;
                }
              }, {
                key: "update",
                value: function update(t, e) {}
              }, {
                key: "wrap",
                value: function wrap(t, e) {
                  var n = "string" == typeof t ? this.scroll.create(t, e) : t;
                  if (null != this.parent && this.parent.insertBefore(n, this.next || void 0), "function" != typeof n.appendChild) throw new s("Cannot wrap ".concat(t));
                  return n.appendChild(this), n;
                }
              }], [{
                key: "create",
                value: function create(t) {
                  if (null == this.tagName) throw new s("Blot definition missing tagName");
                  var e, n;
                  return Array.isArray(this.tagName) ? ("string" == typeof t ? (n = t.toUpperCase(), parseInt(n, 10).toString() === n && (n = parseInt(n, 10))) : "number" == typeof t && (n = t), e = "number" == typeof n ? document.createElement(this.tagName[n - 1]) : n && this.tagName.indexOf(n) > -1 ? document.createElement(n) : document.createElement(this.tagName[0])) : e = document.createElement(this.tagName), this.className && e.classList.add(this.className), e;
                }
              }]);
            }();
          f.blotName = "abstract";
          var p = f;
          var g = /*#__PURE__*/function (_p) {
            function g() {
              _classCallCheck(this, g);
              return _callSuper(this, g, arguments);
            }
            _inherits(g, _p);
            return _createClass(g, [{
              key: "index",
              value: function index(t, e) {
                return this.domNode === t || this.domNode.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e, 1) : -1;
              }
            }, {
              key: "position",
              value: function position(t, e) {
                var n = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
                return t > 0 && (n += 1), [this.parent.domNode, n];
              }
            }, {
              key: "value",
              value: function value() {
                return _defineProperty({}, this.statics.blotName, this.statics.value(this.domNode) || !0);
              }
            }], [{
              key: "value",
              value: function value(t) {
                return !0;
              }
            }]);
          }(p);
          g.scope = r.INLINE_BLOT;
          var m = g;
          var b = /*#__PURE__*/function () {
            function b() {
              _classCallCheck(this, b);
              this.head = null, this.tail = null, this.length = 0;
            }
            return _createClass(b, [{
              key: "append",
              value: function append() {
                for (var _len3 = arguments.length, t = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  t[_key3] = arguments[_key3];
                }
                if (this.insertBefore(t[0], null), t.length > 1) {
                  var _e31 = t.slice(1);
                  this.append.apply(this, _toConsumableArray(_e31));
                }
              }
            }, {
              key: "at",
              value: function at(t) {
                var e = this.iterator();
                var n = e();
                for (; n && t > 0;) t -= 1, n = e();
                return n;
              }
            }, {
              key: "contains",
              value: function contains(t) {
                var e = this.iterator();
                var n = e();
                for (; n;) {
                  if (n === t) return !0;
                  n = e();
                }
                return !1;
              }
            }, {
              key: "indexOf",
              value: function indexOf(t) {
                var e = this.iterator();
                var n = e(),
                  r = 0;
                for (; n;) {
                  if (n === t) return r;
                  r += 1, n = e();
                }
                return -1;
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(t, e) {
                null != t && (this.remove(t), t.next = e, null != e ? (t.prev = e.prev, null != e.prev && (e.prev.next = t), e.prev = t, e === this.head && (this.head = t)) : null != this.tail ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : (t.prev = null, this.head = this.tail = t), this.length += 1);
              }
            }, {
              key: "offset",
              value: function offset(t) {
                var e = 0,
                  n = this.head;
                for (; null != n;) {
                  if (n === t) return e;
                  e += n.length(), n = n.next;
                }
                return -1;
              }
            }, {
              key: "remove",
              value: function remove(t) {
                this.contains(t) && (null != t.prev && (t.prev.next = t.next), null != t.next && (t.next.prev = t.prev), t === this.head && (this.head = t.next), t === this.tail && (this.tail = t.prev), this.length -= 1);
              }
            }, {
              key: "iterator",
              value: function iterator() {
                var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.head;
                return function () {
                  var e = t;
                  return null != t && (t = t.next), e;
                };
              }
            }, {
              key: "find",
              value: function find(t) {
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                var n = this.iterator();
                var r = n();
                for (; r;) {
                  var _i19 = r.length();
                  if (t < _i19 || e && t === _i19 && (null == r.next || 0 !== r.next.length())) return [r, t];
                  t -= _i19, r = n();
                }
                return [null, 0];
              }
            }, {
              key: "forEach",
              value: function forEach(t) {
                var e = this.iterator();
                var n = e();
                for (; n;) t(n), n = e();
              }
            }, {
              key: "forEachAt",
              value: function forEachAt(t, e, n) {
                if (e <= 0) return;
                var _this$find = this.find(t),
                  _this$find2 = _slicedToArray(_this$find, 2),
                  r = _this$find2[0],
                  i = _this$find2[1];
                var s = t - i;
                var o = this.iterator(r);
                var l = o();
                for (; l && s < t + e;) {
                  var _r21 = l.length();
                  t > s ? n(l, t - s, Math.min(e, s + _r21 - t)) : n(l, 0, Math.min(_r21, t + e - s)), s += _r21, l = o();
                }
              }
            }, {
              key: "map",
              value: function map(t) {
                return this.reduce(function (e, n) {
                  return e.push(t(n)), e;
                }, []);
              }
            }, {
              key: "reduce",
              value: function reduce(t, e) {
                var n = this.iterator();
                var r = n();
                for (; r;) e = t(e, r), r = n();
                return e;
              }
            }]);
          }();
          function y(t, e) {
            var n = e.find(t);
            if (n) return n;
            try {
              return e.create(t);
            } catch (_unused2) {
              var _n29 = e.create(r.INLINE);
              return Array.from(t.childNodes).forEach(function (t) {
                _n29.domNode.appendChild(t);
              }), t.parentNode && t.parentNode.replaceChild(_n29.domNode, t), _n29.attach(), _n29;
            }
          }
          var v = /*#__PURE__*/function (_p2) {
            function t(_t46, e) {
              var _this53;
              _classCallCheck(this, t);
              _this53 = _callSuper(this, t, [_t46, e]), _this53.uiNode = null, _this53.build();
              return _this53;
            }
            _inherits(t, _p2);
            return _createClass(t, [{
              key: "appendChild",
              value: function appendChild(_t47) {
                this.insertBefore(_t47);
              }
            }, {
              key: "attach",
              value: function attach() {
                _superPropGet(t, "attach", this, 3)([]), this.children.forEach(function (_t48) {
                  _t48.attach();
                });
              }
            }, {
              key: "attachUI",
              value: function attachUI(e) {
                null != this.uiNode && this.uiNode.remove(), this.uiNode = e, t.uiClass && this.uiNode.classList.add(t.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
              }
            }, {
              key: "build",
              value: function build() {
                var _this54 = this;
                this.children = new b(), Array.from(this.domNode.childNodes).filter(function (_t49) {
                  return _t49 !== _this54.uiNode;
                }).reverse().forEach(function (_t50) {
                  try {
                    var _e32 = y(_t50, _this54.scroll);
                    _this54.insertBefore(_e32, _this54.children.head || void 0);
                  } catch (_t51) {
                    if (_t51 instanceof s) return;
                    throw _t51;
                  }
                });
              }
            }, {
              key: "deleteAt",
              value: function deleteAt(_t52, e) {
                if (0 === _t52 && e === this.length()) return this.remove();
                this.children.forEachAt(_t52, e, function (_t53, e, n) {
                  _t53.deleteAt(e, n);
                });
              }
            }, {
              key: "descendant",
              value: function descendant(e) {
                var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var _this$children$find3 = this.children.find(n),
                  _this$children$find4 = _slicedToArray(_this$children$find3, 2),
                  r = _this$children$find4[0],
                  i = _this$children$find4[1];
                return null == e.blotName && e(r) || null != e.blotName && r instanceof e ? [r, i] : r instanceof t ? r.descendant(e, i) : [null, -1];
              }
            }, {
              key: "descendants",
              value: function descendants(e) {
                var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;
                var i = [],
                  s = r;
                return this.children.forEachAt(n, r, function (n, r, o) {
                  (null == e.blotName && e(n) || null != e.blotName && n instanceof e) && i.push(n), n instanceof t && (i = i.concat(n.descendants(e, r, s))), s -= o;
                }), i;
              }
            }, {
              key: "detach",
              value: function detach() {
                this.children.forEach(function (_t54) {
                  _t54.detach();
                }), _superPropGet(t, "detach", this, 3)([]);
              }
            }, {
              key: "enforceAllowedChildren",
              value: function enforceAllowedChildren() {
                var _this55 = this;
                var e = !1;
                this.children.forEach(function (n) {
                  e || _this55.statics.allowedChildren.some(function (_t55) {
                    return n instanceof _t55;
                  }) || (n.statics.scope === r.BLOCK_BLOT ? (null != n.next && _this55.splitAfter(n), null != n.prev && _this55.splitAfter(n.prev), n.parent.unwrap(), e = !0) : n instanceof t ? n.unwrap() : n.remove());
                });
              }
            }, {
              key: "formatAt",
              value: function formatAt(_t56, e, n, r) {
                this.children.forEachAt(_t56, e, function (_t57, e, i) {
                  _t57.formatAt(e, i, n, r);
                });
              }
            }, {
              key: "insertAt",
              value: function insertAt(_t58, e, n) {
                var _this$children$find5 = this.children.find(_t58),
                  _this$children$find6 = _slicedToArray(_this$children$find5, 2),
                  r = _this$children$find6[0],
                  i = _this$children$find6[1];
                if (r) r.insertAt(i, e, n);else {
                  var _t59 = null == n ? this.scroll.create("text", e) : this.scroll.create(e, n);
                  this.appendChild(_t59);
                }
              }
            }, {
              key: "insertBefore",
              value: function insertBefore(_t60, e) {
                null != _t60.parent && _t60.parent.children.remove(_t60);
                var n = null;
                this.children.insertBefore(_t60, e || null), _t60.parent = this, null != e && (n = e.domNode), (this.domNode.parentNode !== _t60.domNode || this.domNode.nextSibling !== n) && this.domNode.insertBefore(_t60.domNode, n), _t60.attach();
              }
            }, {
              key: "length",
              value: function length() {
                return this.children.reduce(function (_t61, e) {
                  return _t61 + e.length();
                }, 0);
              }
            }, {
              key: "moveChildren",
              value: function moveChildren(_t62, e) {
                this.children.forEach(function (n) {
                  _t62.insertBefore(n, e);
                });
              }
            }, {
              key: "optimize",
              value: function optimize(_t63) {
                if (_superPropGet(t, "optimize", this, 3)([_t63]), this.enforceAllowedChildren(), null != this.uiNode && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), 0 === this.children.length) if (null != this.statics.defaultChild) {
                  var _t64 = this.scroll.create(this.statics.defaultChild.blotName);
                  this.appendChild(_t64);
                } else this.remove();
              }
            }, {
              key: "path",
              value: function path(e) {
                var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                var _this$children$find7 = this.children.find(e, n),
                  _this$children$find8 = _slicedToArray(_this$children$find7, 2),
                  r = _this$children$find8[0],
                  i = _this$children$find8[1],
                  s = [[this, e]];
                return r instanceof t ? s.concat(r.path(i, n)) : (null != r && s.push([r, i]), s);
              }
            }, {
              key: "removeChild",
              value: function removeChild(_t65) {
                this.children.remove(_t65);
              }
            }, {
              key: "replaceWith",
              value: function replaceWith(e, n) {
                var r = "string" == typeof e ? this.scroll.create(e, n) : e;
                return r instanceof t && this.moveChildren(r), _superPropGet(t, "replaceWith", this, 3)([r]);
              }
            }, {
              key: "split",
              value: function split(_t66) {
                var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                if (!e) {
                  if (0 === _t66) return this;
                  if (_t66 === this.length()) return this.next;
                }
                var n = this.clone();
                return this.parent && this.parent.insertBefore(n, this.next || void 0), this.children.forEachAt(_t66, this.length(), function (_t67, r, i) {
                  var s = _t67.split(r, e);
                  null != s && n.appendChild(s);
                }), n;
              }
            }, {
              key: "splitAfter",
              value: function splitAfter(_t68) {
                var e = this.clone();
                for (; null != _t68.next;) e.appendChild(_t68.next);
                return this.parent && this.parent.insertBefore(e, this.next || void 0), e;
              }
            }, {
              key: "unwrap",
              value: function unwrap() {
                this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
              }
            }, {
              key: "update",
              value: function update(_t69, e) {
                var _this56 = this;
                var n = [],
                  r = [];
                _t69.forEach(function (_t70) {
                  _t70.target === _this56.domNode && "childList" === _t70.type && (n.push.apply(n, _toConsumableArray(_t70.addedNodes)), r.push.apply(r, _toConsumableArray(_t70.removedNodes)));
                }), r.forEach(function (_t71) {
                  if (null != _t71.parentNode && "IFRAME" !== _t71.tagName && document.body.compareDocumentPosition(_t71) & Node.DOCUMENT_POSITION_CONTAINED_BY) return;
                  var e = _this56.scroll.find(_t71);
                  null != e && (null == e.domNode.parentNode || e.domNode.parentNode === _this56.domNode) && e.detach();
                }), n.filter(function (_t72) {
                  return _t72.parentNode === _this56.domNode && _t72 !== _this56.uiNode;
                }).sort(function (_t73, e) {
                  return _t73 === e ? 0 : _t73.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1;
                }).forEach(function (_t74) {
                  var e = null;
                  null != _t74.nextSibling && (e = _this56.scroll.find(_t74.nextSibling));
                  var n = y(_t74, _this56.scroll);
                  (n.next !== e || null == n.next) && (null != n.parent && n.parent.removeChild(_this56), _this56.insertBefore(n, e || void 0));
                }), this.enforceAllowedChildren();
              }
            }]);
          }(p);
          v.uiClass = "";
          var A = v,
            x = /*#__PURE__*/function (_A) {
              function t(_t76, e) {
                var _this57;
                _classCallCheck(this, t);
                _this57 = _callSuper(this, t, [_t76, e]), _this57.attributes = new d(_this57.domNode);
                return _this57;
              }
              _inherits(t, _A);
              return _createClass(t, [{
                key: "format",
                value: function format(e, n) {
                  var _this58 = this;
                  if (e !== this.statics.blotName || n) {
                    var _t77 = this.scroll.query(e, r.INLINE);
                    if (null == _t77) return;
                    _t77 instanceof i ? this.attributes.attribute(_t77, n) : n && (e !== this.statics.blotName || this.formats()[e] !== n) && this.replaceWith(e, n);
                  } else this.children.forEach(function (e) {
                    e instanceof t || (e = e.wrap(t.blotName, !0)), _this58.attributes.copy(e);
                  }), this.unwrap();
                }
              }, {
                key: "formats",
                value: function formats() {
                  var _t78 = this.attributes.values(),
                    e = this.statics.formats(this.domNode, this.scroll);
                  return null != e && (_t78[this.statics.blotName] = e), _t78;
                }
              }, {
                key: "formatAt",
                value: function formatAt(_t79, e, n, i) {
                  null != this.formats()[n] || this.scroll.query(n, r.ATTRIBUTE) ? this.isolate(_t79, e).format(n, i) : _superPropGet(t, "formatAt", this, 3)([_t79, e, n, i]);
                }
              }, {
                key: "optimize",
                value: function optimize(e) {
                  _superPropGet(t, "optimize", this, 3)([e]);
                  var n = this.formats();
                  if (0 === Object.keys(n).length) return this.unwrap();
                  var r = this.next;
                  r instanceof t && r.prev === this && function (t, e) {
                    if (Object.keys(t).length !== Object.keys(e).length) return !1;
                    for (var _n30 in t) if (t[_n30] !== e[_n30]) return !1;
                    return !0;
                  }(n, r.formats()) && (r.moveChildren(this), r.remove());
                }
              }, {
                key: "replaceWith",
                value: function replaceWith(_t80, e) {
                  var n = _superPropGet(t, "replaceWith", this, 3)([_t80, e]);
                  return this.attributes.copy(n), n;
                }
              }, {
                key: "update",
                value: function update(_t81, e) {
                  var _this59 = this;
                  _superPropGet(t, "update", this, 3)([_t81, e]), _t81.some(function (_t82) {
                    return _t82.target === _this59.domNode && "attributes" === _t82.type;
                  }) && this.attributes.build();
                }
              }, {
                key: "wrap",
                value: function wrap(e, n) {
                  var r = _superPropGet(t, "wrap", this, 3)([e, n]);
                  return r instanceof t && this.attributes.move(r), r;
                }
              }], [{
                key: "create",
                value: function create(_t75) {
                  return _superPropGet(t, "create", this, 2)([_t75]);
                }
              }, {
                key: "formats",
                value: function formats(e, n) {
                  var r = n.query(t.blotName);
                  if (null == r || e.tagName !== r.tagName) {
                    if ("string" == typeof this.tagName) return !0;
                    if (Array.isArray(this.tagName)) return e.tagName.toLowerCase();
                  }
                }
              }]);
            }(A);
          x.allowedChildren = [x, m], x.blotName = "inline", x.scope = r.INLINE_BLOT, x.tagName = "SPAN";
          var N = x,
            E = /*#__PURE__*/function (_A2) {
              function t(_t84, e) {
                var _this60;
                _classCallCheck(this, t);
                _this60 = _callSuper(this, t, [_t84, e]), _this60.attributes = new d(_this60.domNode);
                return _this60;
              }
              _inherits(t, _A2);
              return _createClass(t, [{
                key: "format",
                value: function format(e, n) {
                  var s = this.scroll.query(e, r.BLOCK);
                  null != s && (s instanceof i ? this.attributes.attribute(s, n) : e !== this.statics.blotName || n ? n && (e !== this.statics.blotName || this.formats()[e] !== n) && this.replaceWith(e, n) : this.replaceWith(t.blotName));
                }
              }, {
                key: "formats",
                value: function formats() {
                  var _t85 = this.attributes.values(),
                    e = this.statics.formats(this.domNode, this.scroll);
                  return null != e && (_t85[this.statics.blotName] = e), _t85;
                }
              }, {
                key: "formatAt",
                value: function formatAt(_t86, e, n, i) {
                  null != this.scroll.query(n, r.BLOCK) ? this.format(n, i) : _superPropGet(t, "formatAt", this, 3)([_t86, e, n, i]);
                }
              }, {
                key: "insertAt",
                value: function insertAt(_t87, e, n) {
                  if (null == n || null != this.scroll.query(e, r.INLINE)) _superPropGet(t, "insertAt", this, 3)([_t87, e, n]);else {
                    var _r22 = this.split(_t87);
                    if (null == _r22) throw new Error("Attempt to insertAt after block boundaries");
                    {
                      var _t88 = this.scroll.create(e, n);
                      _r22.parent.insertBefore(_t88, _r22);
                    }
                  }
                }
              }, {
                key: "replaceWith",
                value: function replaceWith(_t89, e) {
                  var n = _superPropGet(t, "replaceWith", this, 3)([_t89, e]);
                  return this.attributes.copy(n), n;
                }
              }, {
                key: "update",
                value: function update(_t90, e) {
                  var _this61 = this;
                  _superPropGet(t, "update", this, 3)([_t90, e]), _t90.some(function (_t91) {
                    return _t91.target === _this61.domNode && "attributes" === _t91.type;
                  }) && this.attributes.build();
                }
              }], [{
                key: "create",
                value: function create(_t83) {
                  return _superPropGet(t, "create", this, 2)([_t83]);
                }
              }, {
                key: "formats",
                value: function formats(e, n) {
                  var r = n.query(t.blotName);
                  if (null == r || e.tagName !== r.tagName) {
                    if ("string" == typeof this.tagName) return !0;
                    if (Array.isArray(this.tagName)) return e.tagName.toLowerCase();
                  }
                }
              }]);
            }(A);
          E.blotName = "block", E.scope = r.BLOCK_BLOT, E.tagName = "P", E.allowedChildren = [N, E, m];
          var w = E,
            q = /*#__PURE__*/function (_A3) {
              function q() {
                _classCallCheck(this, q);
                return _callSuper(this, q, arguments);
              }
              _inherits(q, _A3);
              return _createClass(q, [{
                key: "checkMerge",
                value: function checkMerge() {
                  return null !== this.next && this.next.statics.blotName === this.statics.blotName;
                }
              }, {
                key: "deleteAt",
                value: function deleteAt(t, e) {
                  _superPropGet(q, "deleteAt", this, 3)([t, e]), this.enforceAllowedChildren();
                }
              }, {
                key: "formatAt",
                value: function formatAt(t, e, n, r) {
                  _superPropGet(q, "formatAt", this, 3)([t, e, n, r]), this.enforceAllowedChildren();
                }
              }, {
                key: "insertAt",
                value: function insertAt(t, e, n) {
                  _superPropGet(q, "insertAt", this, 3)([t, e, n]), this.enforceAllowedChildren();
                }
              }, {
                key: "optimize",
                value: function optimize(t) {
                  _superPropGet(q, "optimize", this, 3)([t]), this.children.length > 0 && null != this.next && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
                }
              }]);
            }(A);
          q.blotName = "container", q.scope = r.BLOCK_BLOT;
          var k = q,
            _ = /*#__PURE__*/function (_m2) {
              function _() {
                _classCallCheck(this, _);
                return _callSuper(this, _, arguments);
              }
              _inherits(_, _m2);
              return _createClass(_, [{
                key: "format",
                value: function format(t, e) {
                  _superPropGet(_, "formatAt", this, 3)([0, this.length(), t, e]);
                }
              }, {
                key: "formatAt",
                value: function formatAt(t, e, n, r) {
                  0 === t && e === this.length() ? this.format(n, r) : _superPropGet(_, "formatAt", this, 3)([t, e, n, r]);
                }
              }, {
                key: "formats",
                value: function formats() {
                  return this.statics.formats(this.domNode, this.scroll);
                }
              }], [{
                key: "formats",
                value: function formats(t, e) {}
              }]);
            }(m),
            L = {
              attributes: !0,
              characterData: !0,
              characterDataOldValue: !0,
              childList: !0,
              subtree: !0
            },
            S = /*#__PURE__*/function (_A4) {
              function S(t, e) {
                var _this62;
                _classCallCheck(this, S);
                _this62 = _callSuper(this, S, [null, e]), _this62.registry = t, _this62.scroll = _assertThisInitialized(_this62), _this62.build(), _this62.observer = new MutationObserver(function (t) {
                  _this62.update(t);
                }), _this62.observer.observe(_this62.domNode, L), _this62.attach();
                return _this62;
              }
              _inherits(S, _A4);
              return _createClass(S, [{
                key: "create",
                value: function create(t, e) {
                  return this.registry.create(this, t, e);
                }
              }, {
                key: "find",
                value: function find(t) {
                  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                  var n = this.registry.find(t, e);
                  return n ? n.scroll === this ? n : e ? this.find(n.scroll.domNode.parentNode, !0) : null : null;
                }
              }, {
                key: "query",
                value: function query(t) {
                  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.ANY;
                  return this.registry.query(t, e);
                }
              }, {
                key: "register",
                value: function register() {
                  var _this$registry;
                  return (_this$registry = this.registry).register.apply(_this$registry, arguments);
                }
              }, {
                key: "build",
                value: function build() {
                  null != this.scroll && _superPropGet(S, "build", this, 3)([]);
                }
              }, {
                key: "detach",
                value: function detach() {
                  _superPropGet(S, "detach", this, 3)([]), this.observer.disconnect();
                }
              }, {
                key: "deleteAt",
                value: function deleteAt(t, e) {
                  this.update(), 0 === t && e === this.length() ? this.children.forEach(function (t) {
                    t.remove();
                  }) : _superPropGet(S, "deleteAt", this, 3)([t, e]);
                }
              }, {
                key: "formatAt",
                value: function formatAt(t, e, n, r) {
                  this.update(), _superPropGet(S, "formatAt", this, 3)([t, e, n, r]);
                }
              }, {
                key: "insertAt",
                value: function insertAt(t, e, n) {
                  this.update(), _superPropGet(S, "insertAt", this, 3)([t, e, n]);
                }
              }, {
                key: "optimize",
                value: function optimize() {
                  var _this63 = this;
                  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                  _superPropGet(S, "optimize", this, 3)([e]);
                  var n = e.mutationsMap || new WeakMap();
                  var r = Array.from(this.observer.takeRecords());
                  for (; r.length > 0;) t.push(r.pop());
                  var _i20 = function i(t) {
                      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
                      null == t || t === _this63 || null != t.domNode.parentNode && (n.has(t.domNode) || n.set(t.domNode, []), e && _i20(t.parent));
                    },
                    _s11 = function s(t) {
                      n.has(t.domNode) && (t instanceof A && t.children.forEach(_s11), n["delete"](t.domNode), t.optimize(e));
                    };
                  var o = t;
                  for (var _e33 = 0; o.length > 0; _e33 += 1) {
                    if (_e33 >= 100) throw new Error("[Parchment] Maximum optimize iterations reached");
                    for (o.forEach(function (t) {
                      var e = _this63.find(t.target, !0);
                      null != e && (e.domNode === t.target && ("childList" === t.type ? (_i20(_this63.find(t.previousSibling, !1)), Array.from(t.addedNodes).forEach(function (t) {
                        var e = _this63.find(t, !1);
                        _i20(e, !1), e instanceof A && e.children.forEach(function (t) {
                          _i20(t, !1);
                        });
                      })) : "attributes" === t.type && _i20(e.prev)), _i20(e));
                    }), this.children.forEach(_s11), o = Array.from(this.observer.takeRecords()), r = o.slice(); r.length > 0;) t.push(r.pop());
                  }
                }
              }, {
                key: "update",
                value: function update(t) {
                  var _this64 = this;
                  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                  t = t || this.observer.takeRecords();
                  var n = new WeakMap();
                  t.map(function (t) {
                    var e = _this64.find(t.target, !0);
                    return null == e ? null : n.has(e.domNode) ? (n.get(e.domNode).push(t), null) : (n.set(e.domNode, [t]), e);
                  }).forEach(function (t) {
                    null != t && t !== _this64 && n.has(t.domNode) && t.update(n.get(t.domNode) || [], e);
                  }), e.mutationsMap = n, n.has(this.domNode) && _superPropGet(S, "update", this, 3)([n.get(this.domNode), e]), this.optimize(t, e);
                }
              }]);
            }(A);
          S.blotName = "scroll", S.defaultChild = w, S.allowedChildren = [w, k], S.scope = r.BLOCK_BLOT, S.tagName = "DIV";
          var O = S,
            T = /*#__PURE__*/function (_m3) {
              function t(_t94, e) {
                var _this65;
                _classCallCheck(this, t);
                _this65 = _callSuper(this, t, [_t94, e]), _this65.text = _this65.statics.value(_this65.domNode);
                return _this65;
              }
              _inherits(t, _m3);
              return _createClass(t, [{
                key: "deleteAt",
                value: function deleteAt(_t95, e) {
                  this.domNode.data = this.text = this.text.slice(0, _t95) + this.text.slice(_t95 + e);
                }
              }, {
                key: "index",
                value: function index(_t96, e) {
                  return this.domNode === _t96 ? e : -1;
                }
              }, {
                key: "insertAt",
                value: function insertAt(_t97, e, n) {
                  null == n ? (this.text = this.text.slice(0, _t97) + e + this.text.slice(_t97), this.domNode.data = this.text) : _superPropGet(t, "insertAt", this, 3)([_t97, e, n]);
                }
              }, {
                key: "length",
                value: function length() {
                  return this.text.length;
                }
              }, {
                key: "optimize",
                value: function optimize(e) {
                  _superPropGet(t, "optimize", this, 3)([e]), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof t && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
                }
              }, {
                key: "position",
                value: function position(_t98) {
                  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                  return [this.domNode, _t98];
                }
              }, {
                key: "split",
                value: function split(_t99) {
                  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                  if (!e) {
                    if (0 === _t99) return this;
                    if (_t99 === this.length()) return this.next;
                  }
                  var n = this.scroll.create(this.domNode.splitText(_t99));
                  return this.parent.insertBefore(n, this.next || void 0), this.text = this.statics.value(this.domNode), n;
                }
              }, {
                key: "update",
                value: function update(_t100, e) {
                  var _this66 = this;
                  _t100.some(function (_t101) {
                    return "characterData" === _t101.type && _t101.target === _this66.domNode;
                  }) && (this.text = this.statics.value(this.domNode));
                }
              }, {
                key: "value",
                value: function value() {
                  return this.text;
                }
              }], [{
                key: "create",
                value: function create(_t92) {
                  return document.createTextNode(_t92);
                }
              }, {
                key: "value",
                value: function value(_t93) {
                  return _t93.data;
                }
              }]);
            }(m);
          T.blotName = "text", T.scope = r.INLINE_BLOT;
          var j = T;
        }
      },
      e = {};
    function n(r) {
      var i = e[r];
      if (void 0 !== i) return i.exports;
      var s = e[r] = {
        id: r,
        loaded: !1,
        exports: {}
      };
      return t[r](s, s.exports, n), s.loaded = !0, s.exports;
    }
    n.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t["default"];
      } : function () {
        return t;
      };
      return n.d(e, {
        a: e
      }), e;
    }, n.d = function (t, e) {
      for (var r in e) n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, {
        enumerable: !0,
        get: e[r]
      });
    }, n.g = function () {
      if ("object" == (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis))) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t) {
        if ("object" == (typeof window === "undefined" ? "undefined" : _typeof(window))) return window;
      }
    }(), n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, n.r = function (t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      });
    }, n.nmd = function (t) {
      return t.paths = [], t.children || (t.children = []), t;
    };
    var r = {};
    return function (_Class4, _Class5) {
      "use strict";

      n.d(r, {
        "default": function _default() {
          return It;
        }
      });
      var t = n(3729),
        e = n(8276),
        i = n(7912),
        s = n(6003);
      var o = /*#__PURE__*/function (_s$ClassAttributor) {
        function o() {
          _classCallCheck(this, o);
          return _callSuper(this, o, arguments);
        }
        _inherits(o, _s$ClassAttributor);
        return _createClass(o, [{
          key: "add",
          value: function add(t, e) {
            var n = 0;
            if ("+1" === e || "-1" === e) {
              var _r23 = this.value(t) || 0;
              n = "+1" === e ? _r23 + 1 : _r23 - 1;
            } else "number" == typeof e && (n = e);
            return 0 === n ? (this.remove(t), !0) : _superPropGet(o, "add", this, 3)([t, n.toString()]);
          }
        }, {
          key: "canAdd",
          value: function canAdd(t, e) {
            return _superPropGet(o, "canAdd", this, 3)([t, e]) || _superPropGet(o, "canAdd", this, 3)([t, parseInt(e, 10)]);
          }
        }, {
          key: "value",
          value: function value(t) {
            return parseInt(_superPropGet(o, "value", this, 3)([t]), 10) || void 0;
          }
        }]);
      }(s.ClassAttributor);
      var l = new o("indent", "ql-indent", {
          scope: s.Scope.BLOCK,
          whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
        }),
        a = n(9698);
      var c = /*#__PURE__*/function (_a$Ay) {
        function c() {
          _classCallCheck(this, c);
          return _callSuper(this, c, arguments);
        }
        _inherits(c, _a$Ay);
        return _createClass(c);
      }(a.Ay);
      _defineProperty(c, "blotName", "blockquote");
      _defineProperty(c, "tagName", "blockquote");
      var u = c;
      var h = /*#__PURE__*/function (_a$Ay2) {
        function h() {
          _classCallCheck(this, h);
          return _callSuper(this, h, arguments);
        }
        _inherits(h, _a$Ay2);
        return _createClass(h, null, [{
          key: "formats",
          value: function formats(t) {
            return this.tagName.indexOf(t.tagName) + 1;
          }
        }]);
      }(a.Ay);
      _defineProperty(h, "blotName", "header");
      _defineProperty(h, "tagName", ["H1", "H2", "H3", "H4", "H5", "H6"]);
      var d = h,
        f = n(580),
        p = n(6142);
      var g = /*#__PURE__*/function (_f$A) {
        function g() {
          _classCallCheck(this, g);
          return _callSuper(this, g, arguments);
        }
        _inherits(g, _f$A);
        return _createClass(g);
      }(f.A);
      g.blotName = "list-container", g.tagName = "OL";
      var m = /*#__PURE__*/function (_a$Ay3) {
        function m(t, e) {
          var _this67;
          _classCallCheck(this, m);
          _this67 = _callSuper(this, m, [t, e]);
          var n = e.ownerDocument.createElement("span"),
            r = function r(n) {
              if (!t.isEnabled()) return;
              var r = _this67.statics.formats(e, t);
              "checked" === r ? (_this67.format("list", "unchecked"), n.preventDefault()) : "unchecked" === r && (_this67.format("list", "checked"), n.preventDefault());
            };
          n.addEventListener("mousedown", r), n.addEventListener("touchstart", r), _this67.attachUI(n);
          return _this67;
        }
        _inherits(m, _a$Ay3);
        return _createClass(m, [{
          key: "format",
          value: function format(t, e) {
            t === this.statics.blotName && e ? this.domNode.setAttribute("data-list", e) : _superPropGet(m, "format", this, 3)([t, e]);
          }
        }], [{
          key: "create",
          value: function create(t) {
            var e = _superPropGet(m, "create", this, 2)([]);
            return e.setAttribute("data-list", t), e;
          }
        }, {
          key: "formats",
          value: function formats(t) {
            return t.getAttribute("data-list") || void 0;
          }
        }, {
          key: "register",
          value: function register() {
            p.Ay.register(g);
          }
        }]);
      }(a.Ay);
      m.blotName = "list", m.tagName = "LI", g.allowedChildren = [m], m.requiredContainer = g;
      var b = n(9541),
        y = n(8638),
        v = n(6772),
        A = n(664),
        x = n(4850);
      var N = /*#__PURE__*/function (_x$A5) {
        function N() {
          _classCallCheck(this, N);
          return _callSuper(this, N, arguments);
        }
        _inherits(N, _x$A5);
        return _createClass(N, [{
          key: "optimize",
          value: function optimize(t) {
            _superPropGet(N, "optimize", this, 3)([t]), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
          }
        }], [{
          key: "create",
          value: function create() {
            return _superPropGet(N, "create", this, 2)([]);
          }
        }, {
          key: "formats",
          value: function formats() {
            return !0;
          }
        }]);
      }(x.A);
      _defineProperty(N, "blotName", "bold");
      _defineProperty(N, "tagName", ["STRONG", "B"]);
      var E = N;
      var w = /*#__PURE__*/function (_x$A6) {
        function w() {
          _classCallCheck(this, w);
          return _callSuper(this, w, arguments);
        }
        _inherits(w, _x$A6);
        return _createClass(w, [{
          key: "format",
          value: function format(t, e) {
            t === this.statics.blotName && e ? this.domNode.setAttribute("href", this.constructor.sanitize(e)) : _superPropGet(w, "format", this, 3)([t, e]);
          }
        }], [{
          key: "create",
          value: function create(t) {
            var e = _superPropGet(w, "create", this, 2)([t]);
            return e.setAttribute("href", this.sanitize(t)), e.setAttribute("rel", "noopener noreferrer"), e.setAttribute("target", "_blank"), e;
          }
        }, {
          key: "formats",
          value: function formats(t) {
            return t.getAttribute("href");
          }
        }, {
          key: "sanitize",
          value: function sanitize(t) {
            return q(t, this.PROTOCOL_WHITELIST) ? t : this.SANITIZED_URL;
          }
        }]);
      }(x.A);
      _defineProperty(w, "blotName", "link");
      _defineProperty(w, "tagName", "A");
      _defineProperty(w, "SANITIZED_URL", "about:blank");
      _defineProperty(w, "PROTOCOL_WHITELIST", ["http", "https", "mailto", "tel", "sms"]);
      function q(t, e) {
        var n = document.createElement("a");
        n.href = t;
        var r = n.href.slice(0, n.href.indexOf(":"));
        return e.indexOf(r) > -1;
      }
      var k = /*#__PURE__*/function (_x$A7) {
        function k() {
          _classCallCheck(this, k);
          return _callSuper(this, k, arguments);
        }
        _inherits(k, _x$A7);
        return _createClass(k, null, [{
          key: "create",
          value: function create(t) {
            return "super" === t ? document.createElement("sup") : "sub" === t ? document.createElement("sub") : _superPropGet(k, "create", this, 2)([t]);
          }
        }, {
          key: "formats",
          value: function formats(t) {
            return "SUB" === t.tagName ? "sub" : "SUP" === t.tagName ? "super" : void 0;
          }
        }]);
      }(x.A);
      _defineProperty(k, "blotName", "script");
      _defineProperty(k, "tagName", ["SUB", "SUP"]);
      var _ = k;
      var L = /*#__PURE__*/function (_x$A8) {
        function L() {
          _classCallCheck(this, L);
          return _callSuper(this, L, arguments);
        }
        _inherits(L, _x$A8);
        return _createClass(L);
      }(x.A);
      _defineProperty(L, "blotName", "underline");
      _defineProperty(L, "tagName", "U");
      var S = L,
        O = n(746);
      var T = /*#__PURE__*/function (_O$A) {
        function T() {
          _classCallCheck(this, T);
          return _callSuper(this, T, arguments);
        }
        _inherits(T, _O$A);
        return _createClass(T, [{
          key: "html",
          value: function html() {
            var _this$value = this.value(),
              t = _this$value.formula;
            return "<span>".concat(t, "</span>");
          }
        }], [{
          key: "create",
          value: function create(t) {
            if (null == window.katex) throw new Error("Formula module requires KaTeX.");
            var e = _superPropGet(T, "create", this, 2)([t]);
            return "string" == typeof t && (window.katex.render(t, e, {
              throwOnError: !1,
              errorColor: "#f00"
            }), e.setAttribute("data-value", t)), e;
          }
        }, {
          key: "value",
          value: function value(t) {
            return t.getAttribute("data-value");
          }
        }]);
      }(O.A);
      _defineProperty(T, "blotName", "formula");
      _defineProperty(T, "className", "ql-formula");
      _defineProperty(T, "tagName", "SPAN");
      var j = T;
      var C = ["alt", "height", "width"];
      var R = /*#__PURE__*/function (_s$EmbedBlot) {
        function R() {
          _classCallCheck(this, R);
          return _callSuper(this, R, arguments);
        }
        _inherits(R, _s$EmbedBlot);
        return _createClass(R, [{
          key: "format",
          value: function format(t, e) {
            C.indexOf(t) > -1 ? e ? this.domNode.setAttribute(t, e) : this.domNode.removeAttribute(t) : _superPropGet(R, "format", this, 3)([t, e]);
          }
        }], [{
          key: "create",
          value: function create(t) {
            var e = _superPropGet(R, "create", this, 2)([t]);
            return "string" == typeof t && e.setAttribute("src", this.sanitize(t)), e;
          }
        }, {
          key: "formats",
          value: function formats(t) {
            return C.reduce(function (e, n) {
              return t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e;
            }, {});
          }
        }, {
          key: "match",
          value: function match(t) {
            return /\.(jpe?g|gif|png)$/.test(t) || /^data:image\/.+;base64/.test(t);
          }
        }, {
          key: "sanitize",
          value: function sanitize(t) {
            return q(t, ["http", "https", "data"]) ? t : "//:0";
          }
        }, {
          key: "value",
          value: function value(t) {
            return t.getAttribute("src");
          }
        }]);
      }(s.EmbedBlot);
      _defineProperty(R, "blotName", "image");
      _defineProperty(R, "tagName", "IMG");
      var I = R;
      var B = ["height", "width"];
      var M = /*#__PURE__*/function (_a$zo) {
        function M() {
          _classCallCheck(this, M);
          return _callSuper(this, M, arguments);
        }
        _inherits(M, _a$zo);
        return _createClass(M, [{
          key: "format",
          value: function format(t, e) {
            B.indexOf(t) > -1 ? e ? this.domNode.setAttribute(t, e) : this.domNode.removeAttribute(t) : _superPropGet(M, "format", this, 3)([t, e]);
          }
        }, {
          key: "html",
          value: function html() {
            var _this$value2 = this.value(),
              t = _this$value2.video;
            return "<a href=\"".concat(t, "\">").concat(t, "</a>");
          }
        }], [{
          key: "create",
          value: function create(t) {
            var e = _superPropGet(M, "create", this, 2)([t]);
            return e.setAttribute("frameborder", "0"), e.setAttribute("allowfullscreen", "true"), e.setAttribute("src", this.sanitize(t)), e;
          }
        }, {
          key: "formats",
          value: function formats(t) {
            return B.reduce(function (e, n) {
              return t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e;
            }, {});
          }
        }, {
          key: "sanitize",
          value: function sanitize(t) {
            return w.sanitize(t);
          }
        }, {
          key: "value",
          value: function value(t) {
            return t.getAttribute("src");
          }
        }]);
      }(a.zo);
      _defineProperty(M, "blotName", "video");
      _defineProperty(M, "className", "ql-video");
      _defineProperty(M, "tagName", "IFRAME");
      var U = M,
        D = n(9404),
        P = n(5232),
        z = n.n(P),
        F = n(4266),
        $ = n(3036),
        H = n(4541),
        V = n(5508),
        K = n(584);
      var W = new s.ClassAttributor("code-token", "hljs", {
        scope: s.Scope.INLINE
      });
      var Z = /*#__PURE__*/function (_x$A9) {
        function Z(t, e, n) {
          var _this68;
          _classCallCheck(this, Z);
          _this68 = _callSuper(this, Z, [t, e, n]), W.add(_this68.domNode, n);
          return _this68;
        }
        _inherits(Z, _x$A9);
        return _createClass(Z, [{
          key: "format",
          value: function format(t, e) {
            t !== Z.blotName ? _superPropGet(Z, "format", this, 3)([t, e]) : e ? W.add(this.domNode, e) : (W.remove(this.domNode), this.domNode.classList.remove(this.statics.className));
          }
        }, {
          key: "optimize",
          value: function optimize() {
            _superPropGet(Z, "optimize", this, 3)(arguments), W.value(this.domNode) || this.unwrap();
          }
        }], [{
          key: "formats",
          value: function formats(t, e) {
            for (; null != t && t !== e.domNode;) {
              if (t.classList && t.classList.contains(D.Ay.className)) return _superPropGet(Z, "formats", this, 2)([t, e]);
              t = t.parentNode;
            }
          }
        }]);
      }(x.A);
      Z.blotName = "code-token", Z.className = "ql-token";
      var G = /*#__PURE__*/function (_D$Ay) {
        function G() {
          _classCallCheck(this, G);
          return _callSuper(this, G, arguments);
        }
        _inherits(G, _D$Ay);
        return _createClass(G, [{
          key: "format",
          value: function format(t, e) {
            t === this.statics.blotName && e ? this.domNode.setAttribute("data-language", e) : _superPropGet(G, "format", this, 3)([t, e]);
          }
        }, {
          key: "replaceWith",
          value: function replaceWith(t, e) {
            return this.formatAt(0, this.length(), Z.blotName, !1), _superPropGet(G, "replaceWith", this, 3)([t, e]);
          }
        }], [{
          key: "create",
          value: function create(t) {
            var e = _superPropGet(G, "create", this, 2)([t]);
            return "string" == typeof t && e.setAttribute("data-language", t), e;
          }
        }, {
          key: "formats",
          value: function formats(t) {
            return t.getAttribute("data-language") || "plain";
          }
        }, {
          key: "register",
          value: function register() {}
        }]);
      }(D.Ay);
      var X = /*#__PURE__*/function (_D$EJ) {
        function X() {
          _classCallCheck(this, X);
          return _callSuper(this, X, arguments);
        }
        _inherits(X, _D$EJ);
        return _createClass(X, [{
          key: "attach",
          value: function attach() {
            _superPropGet(X, "attach", this, 3)([]), this.forceNext = !1, this.scroll.emitMount(this);
          }
        }, {
          key: "format",
          value: function format(t, e) {
            t === G.blotName && (this.forceNext = !0, this.children.forEach(function (n) {
              n.format(t, e);
            }));
          }
        }, {
          key: "formatAt",
          value: function formatAt(t, e, n, r) {
            n === G.blotName && (this.forceNext = !0), _superPropGet(X, "formatAt", this, 3)([t, e, n, r]);
          }
        }, {
          key: "highlight",
          value: function highlight(t) {
            var _this69 = this;
            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (null == this.children.head) return;
            var n = "".concat(Array.from(this.domNode.childNodes).filter(function (t) {
                return t !== _this69.uiNode;
              }).map(function (t) {
                return t.textContent;
              }).join("\n"), "\n"),
              r = G.formats(this.children.head.domNode);
            if (e || this.forceNext || this.cachedText !== n) {
              if (n.trim().length > 0 || null == this.cachedText) {
                var _e34 = this.children.reduce(function (t, e) {
                    return t.concat((0, a.mG)(e, !1));
                  }, new (z())()),
                  _i21 = t(n, r);
                _e34.diff(_i21).reduce(function (t, e) {
                  var n = e.retain,
                    r = e.attributes;
                  return n ? (r && Object.keys(r).forEach(function (e) {
                    [G.blotName, Z.blotName].includes(e) && _this69.formatAt(t, n, e, r[e]);
                  }), t + n) : t;
                }, 0);
              }
              this.cachedText = n, this.forceNext = !1;
            }
          }
        }, {
          key: "html",
          value: function html(t, e) {
            var _this$children$find9 = this.children.find(t),
              _this$children$find0 = _slicedToArray(_this$children$find9, 1),
              n = _this$children$find0[0];
            return "<pre data-language=\"".concat(n ? G.formats(n.domNode) : "plain", "\">\n").concat((0, V.X)(this.code(t, e)), "\n</pre>");
          }
        }, {
          key: "optimize",
          value: function optimize(t) {
            if (_superPropGet(X, "optimize", this, 3)([t]), null != this.parent && null != this.children.head && null != this.uiNode) {
              var _t102 = G.formats(this.children.head.domNode);
              _t102 !== this.uiNode.value && (this.uiNode.value = _t102);
            }
          }
        }]);
      }(D.EJ);
      X.allowedChildren = [G], G.requiredContainer = X, G.allowedChildren = [Z, H.A, V.A, $.A];
      var Q = /*#__PURE__*/function (_F$A) {
        function Q(t, e) {
          var _this70;
          _classCallCheck(this, Q);
          if (_this70 = _callSuper(this, Q, [t, e]), null == _this70.options.hljs) throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
          _this70.languages = _this70.options.languages.reduce(function (t, e) {
            var n = e.key;
            return t[n] = !0, t;
          }, {}), _this70.highlightBlot = _this70.highlightBlot.bind(_this70), _this70.initListener(), _this70.initTimer();
          return _this70;
        }
        _inherits(Q, _F$A);
        return _createClass(Q, [{
          key: "initListener",
          value: function initListener() {
            var _this71 = this;
            this.quill.on(p.Ay.events.SCROLL_BLOT_MOUNT, function (t) {
              if (!(t instanceof X)) return;
              var e = _this71.quill.root.ownerDocument.createElement("select");
              _this71.options.languages.forEach(function (t) {
                var n = t.key,
                  r = t.label;
                var i = e.ownerDocument.createElement("option");
                i.textContent = r, i.setAttribute("value", n), e.appendChild(i);
              }), e.addEventListener("change", function () {
                t.format(G.blotName, e.value), _this71.quill.root.focus(), _this71.highlight(t, !0);
              }), null == t.uiNode && (t.attachUI(e), t.children.head && (e.value = G.formats(t.children.head.domNode)));
            });
          }
        }, {
          key: "initTimer",
          value: function initTimer() {
            var _this72 = this;
            var t = null;
            this.quill.on(p.Ay.events.SCROLL_OPTIMIZE, function () {
              t && clearTimeout(t), t = setTimeout(function () {
                _this72.highlight(), t = null;
              }, _this72.options.interval);
            });
          }
        }, {
          key: "highlight",
          value: function highlight() {
            var _this73 = this;
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
              e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (this.quill.selection.composing) return;
            this.quill.update(p.Ay.sources.USER);
            var n = this.quill.getSelection();
            (null == t ? this.quill.scroll.descendants(X) : [t]).forEach(function (t) {
              t.highlight(_this73.highlightBlot, e);
            }), this.quill.update(p.Ay.sources.SILENT), null != n && this.quill.setSelection(n, p.Ay.sources.SILENT);
          }
        }, {
          key: "highlightBlot",
          value: function highlightBlot(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "plain";
            if (e = this.languages[e] ? e : "plain", "plain" === e) return (0, V.X)(t).split("\n").reduce(function (t, n, r) {
              return 0 !== r && t.insert("\n", _defineProperty({}, D.Ay.blotName, e)), t.insert(n);
            }, new (z())());
            var n = this.quill.root.ownerDocument.createElement("div");
            return n.classList.add(D.Ay.className), n.innerHTML = function (t, e, n) {
              if ("string" == typeof t.versionString) {
                var _r24 = t.versionString.split(".")[0];
                if (parseInt(_r24, 10) >= 11) return t.highlight(n, {
                  language: e
                }).value;
              }
              return t.highlight(e, n).value;
            }(this.options.hljs, e, t), (0, K.hV)(this.quill.scroll, n, [function (t, e) {
              var n = W.value(t);
              return n ? e.compose(new (z())().retain(e.length(), _defineProperty({}, Z.blotName, n))) : e;
            }], [function (t, n) {
              return t.data.split("\n").reduce(function (t, n, r) {
                return 0 !== r && t.insert("\n", _defineProperty({}, D.Ay.blotName, e)), t.insert(n);
              }, n);
            }], new WeakMap());
          }
        }], [{
          key: "register",
          value: function register() {
            p.Ay.register(Z, !0), p.Ay.register(G, !0), p.Ay.register(X, !0);
          }
        }]);
      }(F.A);
      Q.DEFAULTS = {
        hljs: window.hljs,
        interval: 1e3,
        languages: [{
          key: "plain",
          label: "Plain"
        }, {
          key: "bash",
          label: "Bash"
        }, {
          key: "cpp",
          label: "C++"
        }, {
          key: "cs",
          label: "C#"
        }, {
          key: "css",
          label: "CSS"
        }, {
          key: "diff",
          label: "Diff"
        }, {
          key: "xml",
          label: "HTML/XML"
        }, {
          key: "java",
          label: "Java"
        }, {
          key: "javascript",
          label: "JavaScript"
        }, {
          key: "markdown",
          label: "Markdown"
        }, {
          key: "php",
          label: "PHP"
        }, {
          key: "python",
          label: "Python"
        }, {
          key: "ruby",
          label: "Ruby"
        }, {
          key: "sql",
          label: "SQL"
        }]
      };
      var J = /*#__PURE__*/function (_a$Ay4) {
        function J() {
          _classCallCheck(this, J);
          return _callSuper(this, J, arguments);
        }
        _inherits(J, _a$Ay4);
        return _createClass(J, [{
          key: "cellOffset",
          value: function cellOffset() {
            return this.parent ? this.parent.children.indexOf(this) : -1;
          }
        }, {
          key: "format",
          value: function format(t, e) {
            t === J.blotName && e ? this.domNode.setAttribute("data-row", e) : _superPropGet(J, "format", this, 3)([t, e]);
          }
        }, {
          key: "row",
          value: function row() {
            return this.parent;
          }
        }, {
          key: "rowOffset",
          value: function rowOffset() {
            return this.row() ? this.row().rowOffset() : -1;
          }
        }, {
          key: "table",
          value: function table() {
            return this.row() && this.row().table();
          }
        }], [{
          key: "create",
          value: function create(t) {
            var e = _superPropGet(J, "create", this, 2)([]);
            return t ? e.setAttribute("data-row", t) : e.setAttribute("data-row", nt()), e;
          }
        }, {
          key: "formats",
          value: function formats(t) {
            if (t.hasAttribute("data-row")) return t.getAttribute("data-row");
          }
        }]);
      }(a.Ay);
      _defineProperty(J, "blotName", "table");
      _defineProperty(J, "tagName", "TD");
      var Y = /*#__PURE__*/function (_f$A2) {
        function Y() {
          _classCallCheck(this, Y);
          return _callSuper(this, Y, arguments);
        }
        _inherits(Y, _f$A2);
        return _createClass(Y, [{
          key: "checkMerge",
          value: function checkMerge() {
            if (_superPropGet(Y, "checkMerge", this, 3)([]) && null != this.next.children.head) {
              var _t103 = this.children.head.formats(),
                _e35 = this.children.tail.formats(),
                _n31 = this.next.children.head.formats(),
                _r25 = this.next.children.tail.formats();
              return _t103.table === _e35.table && _t103.table === _n31.table && _t103.table === _r25.table;
            }
            return !1;
          }
        }, {
          key: "optimize",
          value: function optimize(t) {
            var _this74 = this;
            _superPropGet(Y, "optimize", this, 3)([t]), this.children.forEach(function (t) {
              if (null == t.next) return;
              var e = t.formats(),
                n = t.next.formats();
              if (e.table !== n.table) {
                var _e36 = _this74.splitAfter(t);
                _e36 && _e36.optimize(), _this74.prev && _this74.prev.optimize();
              }
            });
          }
        }, {
          key: "rowOffset",
          value: function rowOffset() {
            return this.parent ? this.parent.children.indexOf(this) : -1;
          }
        }, {
          key: "table",
          value: function table() {
            return this.parent && this.parent.parent;
          }
        }]);
      }(f.A);
      _defineProperty(Y, "blotName", "table-row");
      _defineProperty(Y, "tagName", "TR");
      var tt = /*#__PURE__*/function (_f$A3) {
        function tt() {
          _classCallCheck(this, tt);
          return _callSuper(this, tt, arguments);
        }
        _inherits(tt, _f$A3);
        return _createClass(tt);
      }(f.A);
      _defineProperty(tt, "blotName", "table-body");
      _defineProperty(tt, "tagName", "TBODY");
      var et = /*#__PURE__*/function (_f$A4) {
        function et() {
          _classCallCheck(this, et);
          return _callSuper(this, et, arguments);
        }
        _inherits(et, _f$A4);
        return _createClass(et, [{
          key: "balanceCells",
          value: function balanceCells() {
            var _this75 = this;
            var t = this.descendants(Y),
              e = t.reduce(function (t, e) {
                return Math.max(e.children.length, t);
              }, 0);
            t.forEach(function (t) {
              new Array(e - t.children.length).fill(0).forEach(function () {
                var e;
                null != t.children.head && (e = J.formats(t.children.head.domNode));
                var n = _this75.scroll.create(J.blotName, e);
                t.appendChild(n), n.optimize();
              });
            });
          }
        }, {
          key: "cells",
          value: function cells(t) {
            return this.rows().map(function (e) {
              return e.children.at(t);
            });
          }
        }, {
          key: "deleteColumn",
          value: function deleteColumn(t) {
            var _this$descendant3 = this.descendant(tt),
              _this$descendant4 = _slicedToArray(_this$descendant3, 1),
              e = _this$descendant4[0];
            null != e && null != e.children.head && e.children.forEach(function (e) {
              var n = e.children.at(t);
              null != n && n.remove();
            });
          }
        }, {
          key: "insertColumn",
          value: function insertColumn(t) {
            var _this76 = this;
            var _this$descendant5 = this.descendant(tt),
              _this$descendant6 = _slicedToArray(_this$descendant5, 1),
              e = _this$descendant6[0];
            null != e && null != e.children.head && e.children.forEach(function (e) {
              var n = e.children.at(t),
                r = J.formats(e.children.head.domNode),
                i = _this76.scroll.create(J.blotName, r);
              e.insertBefore(i, n);
            });
          }
        }, {
          key: "insertRow",
          value: function insertRow(t) {
            var _this77 = this;
            var _this$descendant7 = this.descendant(tt),
              _this$descendant8 = _slicedToArray(_this$descendant7, 1),
              e = _this$descendant8[0];
            if (null == e || null == e.children.head) return;
            var n = nt(),
              r = this.scroll.create(Y.blotName);
            e.children.head.children.forEach(function () {
              var t = _this77.scroll.create(J.blotName, n);
              r.appendChild(t);
            });
            var i = e.children.at(t);
            e.insertBefore(r, i);
          }
        }, {
          key: "rows",
          value: function rows() {
            var t = this.children.head;
            return null == t ? [] : t.children.map(function (t) {
              return t;
            });
          }
        }]);
      }(f.A);
      _defineProperty(et, "blotName", "table-container");
      _defineProperty(et, "tagName", "TABLE");
      function nt() {
        return "row-".concat(Math.random().toString(36).slice(2, 6));
      }
      et.allowedChildren = [tt], tt.requiredContainer = et, tt.allowedChildren = [Y], Y.requiredContainer = tt, Y.allowedChildren = [J], J.requiredContainer = Y;
      var rt = /*#__PURE__*/function (_F$A2) {
        function rt() {
          var _this78;
          _classCallCheck(this, rt);
          _this78 = _callSuper(this, rt, arguments), _this78.listenBalanceCells();
          return _this78;
        }
        _inherits(rt, _F$A2);
        return _createClass(rt, [{
          key: "balanceTables",
          value: function balanceTables() {
            this.quill.scroll.descendants(et).forEach(function (t) {
              t.balanceCells();
            });
          }
        }, {
          key: "deleteColumn",
          value: function deleteColumn() {
            var _this$getTable = this.getTable(),
              _this$getTable2 = _slicedToArray(_this$getTable, 3),
              t = _this$getTable2[0],
              e = _this$getTable2[2];
            null != e && (t.deleteColumn(e.cellOffset()), this.quill.update(p.Ay.sources.USER));
          }
        }, {
          key: "deleteRow",
          value: function deleteRow() {
            var _this$getTable3 = this.getTable(),
              _this$getTable4 = _slicedToArray(_this$getTable3, 2),
              t = _this$getTable4[1];
            null != t && (t.remove(), this.quill.update(p.Ay.sources.USER));
          }
        }, {
          key: "deleteTable",
          value: function deleteTable() {
            var _this$getTable5 = this.getTable(),
              _this$getTable6 = _slicedToArray(_this$getTable5, 1),
              t = _this$getTable6[0];
            if (null == t) return;
            var e = t.offset();
            t.remove(), this.quill.update(p.Ay.sources.USER), this.quill.setSelection(e, p.Ay.sources.SILENT);
          }
        }, {
          key: "getTable",
          value: function getTable() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.quill.getSelection();
            if (null == t) return [null, null, null, -1];
            var _this$quill$getLine15 = this.quill.getLine(t.index),
              _this$quill$getLine16 = _slicedToArray(_this$quill$getLine15, 2),
              e = _this$quill$getLine16[0],
              n = _this$quill$getLine16[1];
            if (null == e || e.statics.blotName !== J.blotName) return [null, null, null, -1];
            var r = e.parent;
            return [r.parent.parent, r, e, n];
          }
        }, {
          key: "insertColumn",
          value: function insertColumn(t) {
            var e = this.quill.getSelection();
            if (!e) return;
            var _this$getTable7 = this.getTable(e),
              _this$getTable8 = _slicedToArray(_this$getTable7, 3),
              n = _this$getTable8[0],
              r = _this$getTable8[1],
              i = _this$getTable8[2];
            if (null == i) return;
            var s = i.cellOffset();
            n.insertColumn(s + t), this.quill.update(p.Ay.sources.USER);
            var o = r.rowOffset();
            0 === t && (o += 1), this.quill.setSelection(e.index + o, e.length, p.Ay.sources.SILENT);
          }
        }, {
          key: "insertColumnLeft",
          value: function insertColumnLeft() {
            this.insertColumn(0);
          }
        }, {
          key: "insertColumnRight",
          value: function insertColumnRight() {
            this.insertColumn(1);
          }
        }, {
          key: "insertRow",
          value: function insertRow(t) {
            var e = this.quill.getSelection();
            if (!e) return;
            var _this$getTable9 = this.getTable(e),
              _this$getTable0 = _slicedToArray(_this$getTable9, 3),
              n = _this$getTable0[0],
              r = _this$getTable0[1],
              i = _this$getTable0[2];
            if (null == i) return;
            var s = r.rowOffset();
            n.insertRow(s + t), this.quill.update(p.Ay.sources.USER), t > 0 ? this.quill.setSelection(e, p.Ay.sources.SILENT) : this.quill.setSelection(e.index + r.children.length, e.length, p.Ay.sources.SILENT);
          }
        }, {
          key: "insertRowAbove",
          value: function insertRowAbove() {
            this.insertRow(0);
          }
        }, {
          key: "insertRowBelow",
          value: function insertRowBelow() {
            this.insertRow(1);
          }
        }, {
          key: "insertTable",
          value: function insertTable(t, e) {
            var n = this.quill.getSelection();
            if (null == n) return;
            var r = new Array(t).fill(0).reduce(function (t) {
              var n = new Array(e).fill("\n").join("");
              return t.insert(n, {
                table: nt()
              });
            }, new (z())().retain(n.index));
            this.quill.updateContents(r, p.Ay.sources.USER), this.quill.setSelection(n.index, p.Ay.sources.SILENT), this.balanceTables();
          }
        }, {
          key: "listenBalanceCells",
          value: function listenBalanceCells() {
            var _this79 = this;
            this.quill.on(p.Ay.events.SCROLL_OPTIMIZE, function (t) {
              t.some(function (t) {
                return !!["TD", "TR", "TBODY", "TABLE"].includes(t.target.tagName) && (_this79.quill.once(p.Ay.events.TEXT_CHANGE, function (t, e, n) {
                  n === p.Ay.sources.USER && _this79.balanceTables();
                }), !0);
              });
            });
          }
        }], [{
          key: "register",
          value: function register() {
            p.Ay.register(J), p.Ay.register(Y), p.Ay.register(tt), p.Ay.register(et);
          }
        }]);
      }(F.A);
      var it = rt;
      var st = (0, n(6078).A)("quill:toolbar");
      var ot = /*#__PURE__*/function (_F$A3) {
        function ot(t, e) {
          var _this80;
          _classCallCheck(this, ot);
          if (_this80 = _callSuper(this, ot, [t, e]), Array.isArray(_this80.options.container)) {
            var _t$container;
            var _e37 = document.createElement("div");
            _e37.setAttribute("role", "toolbar"), function (t, e) {
              Array.isArray(e[0]) || (e = [e]), e.forEach(function (e) {
                var n = document.createElement("span");
                n.classList.add("ql-formats"), e.forEach(function (t) {
                  if ("string" == typeof t) lt(n, t);else {
                    var _e38 = Object.keys(t)[0],
                      _r26 = t[_e38];
                    Array.isArray(_r26) ? function (t, e, n) {
                      var r = document.createElement("select");
                      r.classList.add("ql-".concat(e)), n.forEach(function (t) {
                        var e = document.createElement("option");
                        !1 !== t ? e.setAttribute("value", String(t)) : e.setAttribute("selected", "selected"), r.appendChild(e);
                      }), t.appendChild(r);
                    }(n, _e38, _r26) : lt(n, _e38, _r26);
                  }
                }), t.appendChild(n);
              });
            }(_e37, _this80.options.container), (_t$container = t.container) !== null && _t$container !== void 0 && (_t$container = _t$container.parentNode) !== null && _t$container !== void 0 && _t$container.insertBefore(_e37, t.container), _this80.container = _e37;
          } else "string" == typeof _this80.options.container ? _this80.container = document.querySelector(_this80.options.container) : _this80.container = _this80.options.container;
          _this80.container instanceof HTMLElement ? (_this80.container.classList.add("ql-toolbar"), _this80.controls = [], _this80.handlers = {}, _this80.options.handlers && Object.keys(_this80.options.handlers).forEach(function (t) {
            var _this80$options$handl;
            var e = (_this80$options$handl = _this80.options.handlers) === null || _this80$options$handl === void 0 ? void 0 : _this80$options$handl[t];
            e && _this80.addHandler(t, e);
          }), Array.from(_this80.container.querySelectorAll("button, select")).forEach(function (t) {
            _this80.attach(t);
          }), _this80.quill.on(p.Ay.events.EDITOR_CHANGE, function () {
            var _this80$quill$selecti = _this80.quill.selection.getRange(),
              _this80$quill$selecti2 = _slicedToArray(_this80$quill$selecti, 1),
              t = _this80$quill$selecti2[0];
            _this80.update(t);
          })) : st.error("Container required for toolbar", _this80.options);
          return _this80;
        }
        _inherits(ot, _F$A3);
        return _createClass(ot, [{
          key: "addHandler",
          value: function addHandler(t, e) {
            this.handlers[t] = e;
          }
        }, {
          key: "attach",
          value: function attach(t) {
            var _this81 = this;
            var e = Array.from(t.classList).find(function (t) {
              return 0 === t.indexOf("ql-");
            });
            if (!e) return;
            if (e = e.slice(3), "BUTTON" === t.tagName && t.setAttribute("type", "button"), null == this.handlers[e] && null == this.quill.scroll.query(e)) return void st.warn("ignoring attaching to nonexistent format", e, t);
            var n = "SELECT" === t.tagName ? "change" : "click";
            t.addEventListener(n, function (n) {
              var r;
              if ("SELECT" === t.tagName) {
                if (t.selectedIndex < 0) return;
                var _e39 = t.options[t.selectedIndex];
                r = !_e39.hasAttribute("selected") && (_e39.value || !1);
              } else r = !t.classList.contains("ql-active") && (t.value || !t.hasAttribute("value")), n.preventDefault();
              _this81.quill.focus();
              var _this81$quill$selecti = _this81.quill.selection.getRange(),
                _this81$quill$selecti2 = _slicedToArray(_this81$quill$selecti, 1),
                i = _this81$quill$selecti2[0];
              if (null != _this81.handlers[e]) _this81.handlers[e].call(_this81, r);else if (_this81.quill.scroll.query(e).prototype instanceof s.EmbedBlot) {
                if (r = prompt("Enter ".concat(e)), !r) return;
                _this81.quill.updateContents(new (z())().retain(i.index)["delete"](i.length).insert(_defineProperty({}, e, r)), p.Ay.sources.USER);
              } else _this81.quill.format(e, r, p.Ay.sources.USER);
              _this81.update(i);
            }), this.controls.push([e, t]);
          }
        }, {
          key: "update",
          value: function update(t) {
            var e = null == t ? {} : this.quill.getFormat(t);
            this.controls.forEach(function (n) {
              var _n32 = _slicedToArray(n, 2),
                r = _n32[0],
                i = _n32[1];
              if ("SELECT" === i.tagName) {
                var _n33 = null;
                if (null == t) _n33 = null;else if (null == e[r]) _n33 = i.querySelector("option[selected]");else if (!Array.isArray(e[r])) {
                  var _t104 = e[r];
                  "string" == typeof _t104 && (_t104 = _t104.replace(/"/g, '\\"')), _n33 = i.querySelector("option[value=\"".concat(_t104, "\"]"));
                }
                null == _n33 ? (i.value = "", i.selectedIndex = -1) : _n33.selected = !0;
              } else if (null == t) i.classList.remove("ql-active"), i.setAttribute("aria-pressed", "false");else if (i.hasAttribute("value")) {
                var _t105 = e[r],
                  _n34 = _t105 === i.getAttribute("value") || null != _t105 && _t105.toString() === i.getAttribute("value") || null == _t105 && !i.getAttribute("value");
                i.classList.toggle("ql-active", _n34), i.setAttribute("aria-pressed", _n34.toString());
              } else {
                var _t106 = null != e[r];
                i.classList.toggle("ql-active", _t106), i.setAttribute("aria-pressed", _t106.toString());
              }
            });
          }
        }]);
      }(F.A);
      function lt(t, e, n) {
        var r = document.createElement("button");
        r.setAttribute("type", "button"), r.classList.add("ql-".concat(e)), r.setAttribute("aria-pressed", "false"), null != n ? (r.value = n, r.setAttribute("aria-label", "".concat(e, ": ").concat(n))) : r.setAttribute("aria-label", e), t.appendChild(r);
      }
      ot.DEFAULTS = {}, ot.DEFAULTS = {
        container: null,
        handlers: {
          clean: function clean() {
            var _this82 = this;
            var t = this.quill.getSelection();
            if (null != t) if (0 === t.length) {
              var _t107 = this.quill.getFormat();
              Object.keys(_t107).forEach(function (t) {
                null != _this82.quill.scroll.query(t, s.Scope.INLINE) && _this82.quill.format(t, !1, p.Ay.sources.USER);
              });
            } else this.quill.removeFormat(t, p.Ay.sources.USER);
          },
          direction: function direction(t) {
            var _this$quill$getFormat = this.quill.getFormat(),
              e = _this$quill$getFormat.align;
            "rtl" === t && null == e ? this.quill.format("align", "right", p.Ay.sources.USER) : t || "right" !== e || this.quill.format("align", !1, p.Ay.sources.USER), this.quill.format("direction", t, p.Ay.sources.USER);
          },
          indent: function indent(t) {
            var e = this.quill.getSelection(),
              n = this.quill.getFormat(e),
              r = parseInt(n.indent || 0, 10);
            if ("+1" === t || "-1" === t) {
              var _e40 = "+1" === t ? 1 : -1;
              "rtl" === n.direction && (_e40 *= -1), this.quill.format("indent", r + _e40, p.Ay.sources.USER);
            }
          },
          link: function link(t) {
            !0 === t && (t = prompt("Enter link URL:")), this.quill.format("link", t, p.Ay.sources.USER);
          },
          list: function list(t) {
            var e = this.quill.getSelection(),
              n = this.quill.getFormat(e);
            "check" === t ? "checked" === n.list || "unchecked" === n.list ? this.quill.format("list", !1, p.Ay.sources.USER) : this.quill.format("list", "unchecked", p.Ay.sources.USER) : this.quill.format("list", t, p.Ay.sources.USER);
          }
        }
      };
      var at = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>';
      var ct = {
        align: {
          "": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>',
          center: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>',
          right: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>',
          justify: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>'
        },
        background: '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>',
        blockquote: '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>',
        bold: '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>',
        clean: '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>',
        code: at,
        "code-block": at,
        color: '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>',
        direction: {
          "": '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>',
          rtl: '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>'
        },
        formula: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>',
        header: {
          1: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>',
          2: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>'
        },
        italic: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>',
        image: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>',
        indent: {
          "+1": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>',
          "-1": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>'
        },
        link: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>',
        list: {
          bullet: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>',
          check: '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>',
          ordered: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>'
        },
        script: {
          sub: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>',
          "super": '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>'
        },
        strike: '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>',
        table: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>',
        underline: '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>',
        video: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>'
      };
      var ut = 0;
      function ht(t, e) {
        t.setAttribute(e, "".concat(!("true" === t.getAttribute(e))));
      }
      var dt = /*#__PURE__*/function () {
          function dt(t) {
            var _this83 = this;
            _classCallCheck(this, dt);
            this.select = t, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", function () {
              _this83.togglePicker();
            }), this.label.addEventListener("keydown", function (t) {
              switch (t.key) {
                case "Enter":
                  _this83.togglePicker();
                  break;
                case "Escape":
                  _this83.escape(), t.preventDefault();
              }
            }), this.select.addEventListener("change", this.update.bind(this));
          }
          return _createClass(dt, [{
            key: "togglePicker",
            value: function togglePicker() {
              this.container.classList.toggle("ql-expanded"), ht(this.label, "aria-expanded"), ht(this.options, "aria-hidden");
            }
          }, {
            key: "buildItem",
            value: function buildItem(t) {
              var _this84 = this;
              var e = document.createElement("span");
              e.tabIndex = "0", e.setAttribute("role", "button"), e.classList.add("ql-picker-item");
              var n = t.getAttribute("value");
              return n && e.setAttribute("data-value", n), t.textContent && e.setAttribute("data-label", t.textContent), e.addEventListener("click", function () {
                _this84.selectItem(e, !0);
              }), e.addEventListener("keydown", function (t) {
                switch (t.key) {
                  case "Enter":
                    _this84.selectItem(e, !0), t.preventDefault();
                    break;
                  case "Escape":
                    _this84.escape(), t.preventDefault();
                }
              }), e;
            }
          }, {
            key: "buildLabel",
            value: function buildLabel() {
              var t = document.createElement("span");
              return t.classList.add("ql-picker-label"), t.innerHTML = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>', t.tabIndex = "0", t.setAttribute("role", "button"), t.setAttribute("aria-expanded", "false"), this.container.appendChild(t), t;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions() {
              var _this85 = this;
              var t = document.createElement("span");
              t.classList.add("ql-picker-options"), t.setAttribute("aria-hidden", "true"), t.tabIndex = "-1", t.id = "ql-picker-options-".concat(ut), ut += 1, this.label.setAttribute("aria-controls", t.id), this.options = t, Array.from(this.select.options).forEach(function (e) {
                var n = _this85.buildItem(e);
                t.appendChild(n), !0 === e.selected && _this85.selectItem(n);
              }), this.container.appendChild(t);
            }
          }, {
            key: "buildPicker",
            value: function buildPicker() {
              var _this86 = this;
              Array.from(this.select.attributes).forEach(function (t) {
                _this86.container.setAttribute(t.name, t.value);
              }), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions();
            }
          }, {
            key: "escape",
            value: function escape() {
              var _this87 = this;
              this.close(), setTimeout(function () {
                return _this87.label.focus();
              }, 1);
            }
          }, {
            key: "close",
            value: function close() {
              this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true");
            }
          }, {
            key: "selectItem",
            value: function selectItem(t) {
              var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              var n = this.container.querySelector(".ql-selected");
              t !== n && (null != n && n.classList.remove("ql-selected"), null != t && (t.classList.add("ql-selected"), this.select.selectedIndex = Array.from(t.parentNode.children).indexOf(t), t.hasAttribute("data-value") ? this.label.setAttribute("data-value", t.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t.hasAttribute("data-label") ? this.label.setAttribute("data-label", t.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e && (this.select.dispatchEvent(new Event("change")), this.close())));
            }
          }, {
            key: "update",
            value: function update() {
              var t;
              if (this.select.selectedIndex > -1) {
                var _e41 = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                t = this.select.options[this.select.selectedIndex], this.selectItem(_e41);
              } else this.selectItem(null);
              var e = null != t && t !== this.select.querySelector("option[selected]");
              this.label.classList.toggle("ql-active", e);
            }
          }]);
        }(),
        ft = /*#__PURE__*/function (_dt) {
          function ft(t, e) {
            var _this88;
            _classCallCheck(this, ft);
            _this88 = _callSuper(this, ft, [t]), _this88.label.innerHTML = e, _this88.container.classList.add("ql-color-picker"), Array.from(_this88.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach(function (t) {
              t.classList.add("ql-primary");
            });
            return _this88;
          }
          _inherits(ft, _dt);
          return _createClass(ft, [{
            key: "buildItem",
            value: function buildItem(t) {
              var e = _superPropGet(ft, "buildItem", this, 3)([t]);
              return e.style.backgroundColor = t.getAttribute("value") || "", e;
            }
          }, {
            key: "selectItem",
            value: function selectItem(t, e) {
              _superPropGet(ft, "selectItem", this, 3)([t, e]);
              var n = this.label.querySelector(".ql-color-label"),
                r = t && t.getAttribute("data-value") || "";
              n && ("line" === n.tagName ? n.style.stroke = r : n.style.fill = r);
            }
          }]);
        }(dt),
        pt = /*#__PURE__*/function (_dt2) {
          function pt(t, e) {
            var _this89;
            _classCallCheck(this, pt);
            _this89 = _callSuper(this, pt, [t]), _this89.container.classList.add("ql-icon-picker"), Array.from(_this89.container.querySelectorAll(".ql-picker-item")).forEach(function (t) {
              t.innerHTML = e[t.getAttribute("data-value") || ""];
            }), _this89.defaultItem = _this89.container.querySelector(".ql-selected"), _this89.selectItem(_this89.defaultItem);
            return _this89;
          }
          _inherits(pt, _dt2);
          return _createClass(pt, [{
            key: "selectItem",
            value: function selectItem(t, e) {
              _superPropGet(pt, "selectItem", this, 3)([t, e]);
              var n = t || this.defaultItem;
              if (null != n) {
                if (this.label.innerHTML === n.innerHTML) return;
                this.label.innerHTML = n.innerHTML;
              }
            }
          }]);
        }(dt),
        gt = /*#__PURE__*/function () {
          function gt(t, e) {
            var _this90 = this;
            _classCallCheck(this, gt);
            this.quill = t, this.boundsContainer = e || document.body, this.root = t.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, function (t) {
              var _getComputedStyle = getComputedStyle(t, null),
                e = _getComputedStyle.overflowY;
              return "visible" !== e && "clip" !== e;
            }(this.quill.root) && this.quill.root.addEventListener("scroll", function () {
              _this90.root.style.marginTop = -1 * _this90.quill.root.scrollTop + "px";
            }), this.hide();
          }
          return _createClass(gt, [{
            key: "hide",
            value: function hide() {
              this.root.classList.add("ql-hidden");
            }
          }, {
            key: "position",
            value: function position(t) {
              var e = t.left + t.width / 2 - this.root.offsetWidth / 2,
                n = t.bottom + this.quill.root.scrollTop;
              this.root.style.left = "".concat(e, "px"), this.root.style.top = "".concat(n, "px"), this.root.classList.remove("ql-flip");
              var r = this.boundsContainer.getBoundingClientRect(),
                i = this.root.getBoundingClientRect();
              var s = 0;
              if (i.right > r.right && (s = r.right - i.right, this.root.style.left = "".concat(e + s, "px")), i.left < r.left && (s = r.left - i.left, this.root.style.left = "".concat(e + s, "px")), i.bottom > r.bottom) {
                var _e42 = i.bottom - i.top,
                  _r27 = t.bottom - t.top + _e42;
                this.root.style.top = n - _r27 + "px", this.root.classList.add("ql-flip");
              }
              return s;
            }
          }, {
            key: "show",
            value: function show() {
              this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden");
            }
          }]);
        }(),
        mt = n(8347),
        bt = n(5374),
        yt = n(9609);
      var vt = [!1, "center", "right", "justify"],
        At = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"],
        xt = [!1, "serif", "monospace"],
        Nt = ["1", "2", "3", !1],
        Et = ["small", !1, "large", "huge"];
      var wt = /*#__PURE__*/function (_yt$A) {
        function wt(t, e) {
          var _this91;
          _classCallCheck(this, wt);
          _this91 = _callSuper(this, wt, [t, e]);
          var _n35 = function n(e) {
            document.body.contains(t.root) ? (null == _this91.tooltip || _this91.tooltip.root.contains(e.target) || document.activeElement === _this91.tooltip.textbox || _this91.quill.hasFocus() || _this91.tooltip.hide(), null != _this91.pickers && _this91.pickers.forEach(function (t) {
              t.container.contains(e.target) || t.close();
            })) : document.body.removeEventListener("click", _n35);
          };
          t.emitter.listenDOM("click", document.body, _n35);
          return _this91;
        }
        _inherits(wt, _yt$A);
        return _createClass(wt, [{
          key: "addModule",
          value: function addModule(t) {
            var e = _superPropGet(wt, "addModule", this, 3)([t]);
            return "toolbar" === t && this.extendToolbar(e), e;
          }
        }, {
          key: "buildButtons",
          value: function buildButtons(t, e) {
            Array.from(t).forEach(function (t) {
              (t.getAttribute("class") || "").split(/\s+/).forEach(function (n) {
                if (n.startsWith("ql-") && (n = n.slice(3), null != e[n])) if ("direction" === n) t.innerHTML = e[n][""] + e[n].rtl;else if ("string" == typeof e[n]) t.innerHTML = e[n];else {
                  var _r28 = t.value || "";
                  null != _r28 && e[n][_r28] && (t.innerHTML = e[n][_r28]);
                }
              });
            });
          }
        }, {
          key: "buildPickers",
          value: function buildPickers(t, e) {
            var _this92 = this;
            this.pickers = Array.from(t).map(function (t) {
              if (t.classList.contains("ql-align") && (null == t.querySelector("option") && kt(t, vt), "object" == _typeof(e.align))) return new pt(t, e.align);
              if (t.classList.contains("ql-background") || t.classList.contains("ql-color")) {
                var _n36 = t.classList.contains("ql-background") ? "background" : "color";
                return null == t.querySelector("option") && kt(t, At, "background" === _n36 ? "#ffffff" : "#000000"), new ft(t, e[_n36]);
              }
              return null == t.querySelector("option") && (t.classList.contains("ql-font") ? kt(t, xt) : t.classList.contains("ql-header") ? kt(t, Nt) : t.classList.contains("ql-size") && kt(t, Et)), new dt(t);
            }), this.quill.on(bt.A.events.EDITOR_CHANGE, function () {
              _this92.pickers.forEach(function (t) {
                t.update();
              });
            });
          }
        }]);
      }(yt.A);
      wt.DEFAULTS = (0, mt.A)({}, yt.A.DEFAULTS, {
        modules: {
          toolbar: {
            handlers: {
              formula: function formula() {
                this.quill.theme.tooltip.edit("formula");
              },
              image: function image() {
                var _this93 = this;
                var t = this.container.querySelector("input.ql-image[type=file]");
                null == t && (t = document.createElement("input"), t.setAttribute("type", "file"), t.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", ")), t.classList.add("ql-image"), t.addEventListener("change", function () {
                  var e = _this93.quill.getSelection(!0);
                  _this93.quill.uploader.upload(e, t.files), t.value = "";
                }), this.container.appendChild(t)), t.click();
              },
              video: function video() {
                this.quill.theme.tooltip.edit("video");
              }
            }
          }
        }
      });
      var qt = /*#__PURE__*/function (_gt) {
        function qt(t, e) {
          var _this94;
          _classCallCheck(this, qt);
          _this94 = _callSuper(this, qt, [t, e]), _this94.textbox = _this94.root.querySelector('input[type="text"]'), _this94.listen();
          return _this94;
        }
        _inherits(qt, _gt);
        return _createClass(qt, [{
          key: "listen",
          value: function listen() {
            var _this95 = this;
            this.textbox.addEventListener("keydown", function (t) {
              "Enter" === t.key ? (_this95.save(), t.preventDefault()) : "Escape" === t.key && (_this95.cancel(), t.preventDefault());
            });
          }
        }, {
          key: "cancel",
          value: function cancel() {
            this.hide(), this.restoreFocus();
          }
        }, {
          key: "edit",
          value: function edit() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "link",
              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            if (this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), null == this.textbox) return;
            null != e ? this.textbox.value = e : t !== this.root.getAttribute("data-mode") && (this.textbox.value = "");
            var n = this.quill.getBounds(this.quill.selection.savedRange);
            null != n && this.position(n), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-".concat(t)) || ""), this.root.setAttribute("data-mode", t);
          }
        }, {
          key: "restoreFocus",
          value: function restoreFocus() {
            this.quill.focus({
              preventScroll: !0
            });
          }
        }, {
          key: "save",
          value: function save() {
            var t = this.textbox.value;
            switch (this.root.getAttribute("data-mode")) {
              case "link":
                {
                  var _e43 = this.quill.root.scrollTop;
                  this.linkRange ? (this.quill.formatText(this.linkRange, "link", t, bt.A.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", t, bt.A.sources.USER)), this.quill.root.scrollTop = _e43;
                  break;
                }
              case "video":
                t = function (t) {
                  var e = t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
                  return e ? "".concat(e[1] || "https", "://www.youtube.com/embed/").concat(e[2], "?showinfo=0") : (e = t.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) ? "".concat(e[1] || "https", "://player.vimeo.com/video/").concat(e[2], "/") : t;
                }(t);
              case "formula":
                {
                  if (!t) break;
                  var _e44 = this.quill.getSelection(!0);
                  if (null != _e44) {
                    var _n37 = _e44.index + _e44.length;
                    this.quill.insertEmbed(_n37, this.root.getAttribute("data-mode"), t, bt.A.sources.USER), "formula" === this.root.getAttribute("data-mode") && this.quill.insertText(_n37 + 1, " ", bt.A.sources.USER), this.quill.setSelection(_n37 + 2, bt.A.sources.USER);
                  }
                  break;
                }
            }
            this.textbox.value = "", this.hide();
          }
        }]);
      }(gt);
      function kt(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        e.forEach(function (e) {
          var r = document.createElement("option");
          e === n ? r.setAttribute("selected", "selected") : r.setAttribute("value", String(e)), t.appendChild(r);
        });
      }
      var _t = n(8298);
      var Lt = [["bold", "italic", "link"], [{
        header: 1
      }, {
        header: 2
      }, "blockquote"]];
      var St = /*#__PURE__*/function (_qt) {
        function St(t, e) {
          var _this96;
          _classCallCheck(this, St);
          _this96 = _callSuper(this, St, [t, e]), _this96.quill.on(bt.A.events.EDITOR_CHANGE, function (t, e, n, r) {
            if (t === bt.A.events.SELECTION_CHANGE) if (null != e && e.length > 0 && r === bt.A.sources.USER) {
              _this96.show(), _this96.root.style.left = "0px", _this96.root.style.width = "", _this96.root.style.width = "".concat(_this96.root.offsetWidth, "px");
              var _t108 = _this96.quill.getLines(e.index, e.length);
              if (1 === _t108.length) {
                var _t109 = _this96.quill.getBounds(e);
                null != _t109 && _this96.position(_t109);
              } else {
                var _n38 = _t108[_t108.length - 1],
                  _r29 = _this96.quill.getIndex(_n38),
                  _i22 = Math.min(_n38.length() - 1, e.index + e.length - _r29),
                  _s12 = _this96.quill.getBounds(new _t.Q(_r29, _i22));
                null != _s12 && _this96.position(_s12);
              }
            } else document.activeElement !== _this96.textbox && _this96.quill.hasFocus() && _this96.hide();
          });
          return _this96;
        }
        _inherits(St, _qt);
        return _createClass(St, [{
          key: "listen",
          value: function listen() {
            var _this97 = this;
            _superPropGet(St, "listen", this, 3)([]), this.root.querySelector(".ql-close").addEventListener("click", function () {
              _this97.root.classList.remove("ql-editing");
            }), this.quill.on(bt.A.events.SCROLL_OPTIMIZE, function () {
              setTimeout(function () {
                if (_this97.root.classList.contains("ql-hidden")) return;
                var t = _this97.quill.getSelection();
                if (null != t) {
                  var _e45 = _this97.quill.getBounds(t);
                  null != _e45 && _this97.position(_e45);
                }
              }, 1);
            });
          }
        }, {
          key: "cancel",
          value: function cancel() {
            this.show();
          }
        }, {
          key: "position",
          value: function position(t) {
            var e = _superPropGet(St, "position", this, 3)([t]),
              n = this.root.querySelector(".ql-tooltip-arrow");
            return n.style.marginLeft = "", 0 !== e && (n.style.marginLeft = -1 * e - n.offsetWidth / 2 + "px"), e;
          }
        }]);
      }(qt);
      _defineProperty(St, "TEMPLATE", ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join(""));
      var Ot = /*#__PURE__*/function (_wt) {
        function Ot(t, e) {
          var _this98;
          _classCallCheck(this, Ot);
          null != e.modules.toolbar && null == e.modules.toolbar.container && (e.modules.toolbar.container = Lt), _this98 = _callSuper(this, Ot, [t, e]), _this98.quill.container.classList.add("ql-bubble");
          return _this98;
        }
        _inherits(Ot, _wt);
        return _createClass(Ot, [{
          key: "extendToolbar",
          value: function extendToolbar(t) {
            this.tooltip = new St(this.quill, this.options.bounds), null != t.container && (this.tooltip.root.appendChild(t.container), this.buildButtons(t.container.querySelectorAll("button"), ct), this.buildPickers(t.container.querySelectorAll("select"), ct));
          }
        }]);
      }(wt);
      Ot.DEFAULTS = (0, mt.A)({}, wt.DEFAULTS, {
        modules: {
          toolbar: {
            handlers: {
              link: function link(t) {
                t ? this.quill.theme.tooltip.edit() : this.quill.format("link", !1);
              }
            }
          }
        }
      });
      var Tt = [[{
        header: ["1", "2", "3", !1]
      }], ["bold", "italic", "underline", "link"], [{
        list: "ordered"
      }, {
        list: "bullet"
      }], ["clean"]];
      var jt = /*#__PURE__*/function (_qt2) {
        function jt() {
          var _this99;
          _classCallCheck(this, jt);
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          _this99 = _callSuper(this, jt, [].concat(args));
          _defineProperty(_this99, "preview", _this99.root.querySelector("a.ql-preview"));
          return _this99;
        }
        _inherits(jt, _qt2);
        return _createClass(jt, [{
          key: "listen",
          value: function listen() {
            var _this100 = this;
            _superPropGet(jt, "listen", this, 3)([]), this.root.querySelector("a.ql-action").addEventListener("click", function (t) {
              _this100.root.classList.contains("ql-editing") ? _this100.save() : _this100.edit("link", _this100.preview.textContent), t.preventDefault();
            }), this.root.querySelector("a.ql-remove").addEventListener("click", function (t) {
              if (null != _this100.linkRange) {
                var _t110 = _this100.linkRange;
                _this100.restoreFocus(), _this100.quill.formatText(_t110, "link", !1, bt.A.sources.USER), delete _this100.linkRange;
              }
              t.preventDefault(), _this100.hide();
            }), this.quill.on(bt.A.events.SELECTION_CHANGE, function (t, e, n) {
              if (null != t) {
                if (0 === t.length && n === bt.A.sources.USER) {
                  var _this100$quill$scroll = _this100.quill.scroll.descendant(w, t.index),
                    _this100$quill$scroll2 = _slicedToArray(_this100$quill$scroll, 2),
                    _e46 = _this100$quill$scroll2[0],
                    _n39 = _this100$quill$scroll2[1];
                  if (null != _e46) {
                    _this100.linkRange = new _t.Q(t.index - _n39, _e46.length());
                    var _r30 = w.formats(_e46.domNode);
                    _this100.preview.textContent = _r30, _this100.preview.setAttribute("href", _r30), _this100.show();
                    var _i23 = _this100.quill.getBounds(_this100.linkRange);
                    return void (null != _i23 && _this100.position(_i23));
                  }
                } else delete _this100.linkRange;
                _this100.hide();
              }
            });
          }
        }, {
          key: "show",
          value: function show() {
            _superPropGet(jt, "show", this, 3)([]), this.root.removeAttribute("data-mode");
          }
        }]);
      }(qt);
      _defineProperty(jt, "TEMPLATE", ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join(""));
      var Ct = /*#__PURE__*/function (_wt2) {
        function Ct(t, e) {
          var _this101;
          _classCallCheck(this, Ct);
          null != e.modules.toolbar && null == e.modules.toolbar.container && (e.modules.toolbar.container = Tt), _this101 = _callSuper(this, Ct, [t, e]), _this101.quill.container.classList.add("ql-snow");
          return _this101;
        }
        _inherits(Ct, _wt2);
        return _createClass(Ct, [{
          key: "extendToolbar",
          value: function extendToolbar(t) {
            null != t.container && (t.container.classList.add("ql-snow"), this.buildButtons(t.container.querySelectorAll("button"), ct), this.buildPickers(t.container.querySelectorAll("select"), ct), this.tooltip = new jt(this.quill, this.options.bounds), t.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({
              key: "k",
              shortKey: !0
            }, function (e, n) {
              t.handlers.link.call(t, !n.format.link);
            }));
          }
        }]);
      }(wt);
      Ct.DEFAULTS = (0, mt.A)({}, wt.DEFAULTS, {
        modules: {
          toolbar: {
            handlers: {
              link: function link(t) {
                if (t) {
                  var _t111 = this.quill.getSelection();
                  if (null == _t111 || 0 === _t111.length) return;
                  var _e47 = this.quill.getText(_t111);
                  /^\S+@\S+\.\S+$/.test(_e47) && 0 !== _e47.indexOf("mailto:") && (_e47 = "mailto:".concat(_e47));
                  var _n40 = this.quill.theme.tooltip;
                  _n40.edit("link", _e47);
                } else this.quill.format("link", !1);
              }
            }
          }
        }
      });
      var Rt = Ct;
      t["default"].register({
        "attributors/attribute/direction": i.Mc,
        "attributors/class/align": e.qh,
        "attributors/class/background": b.l,
        "attributors/class/color": y.g3,
        "attributors/class/direction": i.sY,
        "attributors/class/font": v.q,
        "attributors/class/size": A.U,
        "attributors/style/align": e.Hu,
        "attributors/style/background": b.s,
        "attributors/style/color": y.JM,
        "attributors/style/direction": i.VL,
        "attributors/style/font": v.z,
        "attributors/style/size": A.r
      }, !0), t["default"].register({
        "formats/align": e.qh,
        "formats/direction": i.sY,
        "formats/indent": l,
        "formats/background": b.s,
        "formats/color": y.JM,
        "formats/font": v.q,
        "formats/size": A.U,
        "formats/blockquote": u,
        "formats/code-block": D.Ay,
        "formats/header": d,
        "formats/list": m,
        "formats/bold": E,
        "formats/code": D.Cy,
        "formats/italic": (_Class4 = /*#__PURE__*/function (_E) {
          function formats_italic() {
            _classCallCheck(this, formats_italic);
            return _callSuper(this, formats_italic, arguments);
          }
          _inherits(formats_italic, _E);
          return _createClass(formats_italic);
        }(E), _defineProperty(_Class4, "blotName", "italic"), _defineProperty(_Class4, "tagName", ["EM", "I"]), _Class4),
        "formats/link": w,
        "formats/script": _,
        "formats/strike": (_Class5 = /*#__PURE__*/function (_E2) {
          function formats_strike() {
            _classCallCheck(this, formats_strike);
            return _callSuper(this, formats_strike, arguments);
          }
          _inherits(formats_strike, _E2);
          return _createClass(formats_strike);
        }(E), _defineProperty(_Class5, "blotName", "strike"), _defineProperty(_Class5, "tagName", ["S", "STRIKE"]), _Class5),
        "formats/underline": S,
        "formats/formula": j,
        "formats/image": I,
        "formats/video": U,
        "modules/syntax": Q,
        "modules/table": it,
        "modules/toolbar": ot,
        "themes/bubble": Ot,
        "themes/snow": Rt,
        "ui/icons": ct,
        "ui/picker": dt,
        "ui/icon-picker": pt,
        "ui/color-picker": ft,
        "ui/tooltip": gt
      }, !0);
      var It = t["default"];
    }(), r["default"];
  }();
});

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_header */ "./resources/js/_header.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_header__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_js */ "./resources/js/_js.js");
/* harmony import */ var _projects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_projects */ "./resources/js/_projects.js");
/* harmony import */ var _quill_init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_quill-init */ "./resources/js/_quill-init.js");
/* harmony import */ var _Board__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Board */ "./resources/js/Board.js");
/* harmony import */ var _logo_init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_logo-init */ "./resources/js/_logo-init.js");







/***/ }),

/***/ "./resources/js/tm.js":
/*!****************************!*\
  !*** ./resources/js/tm.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/*!
 * VERSION: 1.17.0
 * DATE: 2015-05-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope =  true && module.exports && "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
  "use strict";

  _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
    var s = function s(t) {
        var e,
          i = [],
          s = t.length;
        for (e = 0; e !== s; i.push(t[e++]));
        return i;
      },
      _r = function r(t, e, s) {
        i.call(this, t, e, s), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = _r.prototype.render;
      },
      n = 1e-10,
      a = i._internals,
      o = a.isSelector,
      h = a.isArray,
      l = _r.prototype = i.to({}, .1, {}),
      _ = [];
    _r.version = "1.17.0", l.constructor = _r, l.kill()._gc = !1, _r.killTweensOf = _r.killDelayedCallsTo = i.killTweensOf, _r.getTweensOf = i.getTweensOf, _r.lagSmoothing = i.lagSmoothing, _r.ticker = i.ticker, _r.render = i.render, l.invalidate = function () {
      return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this);
    }, l.updateTo = function (t, e) {
      var s,
        r = this.ratio,
        n = this.vars.immediateRender || t.immediateRender;
      e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
      for (s in t) this.vars[s] = t[s];
      if (this._initted || n) if (e) this._initted = !1, n && this.render(0, !0, !0);else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
        var a = this._time;
        this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1);
      } else if (this._time > 0 || n) {
        this._initted = !1, this._init();
        for (var o, h = 1 / (1 - r), l = this._firstPT; l;) o = l.s + l.c, l.c *= h, l.s = o - l.c, l = l._next;
      }
      return this;
    }, l.render = function (t, e, i) {
      this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
      var s,
        r,
        o,
        h,
        l,
        _,
        u,
        c,
        f = this._dirty ? this.totalDuration() : this._totalDuration,
        p = this._time,
        m = this._totalTime,
        d = this._cycle,
        g = this._duration,
        v = this._rawPrevTime;
      if (t >= f ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = g, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (s = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === g && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > v || v === n) && v !== t && (i = !0, v > n && (r = "onReverseComplete")), this._rawPrevTime = c = !e || t || v === t ? t : n)) : 1e-7 > t ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== m || 0 === g && v > 0) && (r = "onReverseComplete", s = this._reversed), 0 > t && (this._active = !1, 0 === g && (this._initted || !this.vars.lazy || i) && (v >= 0 && (i = !0), this._rawPrevTime = c = !e || t || v === t ? t : n)), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (h = g + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 !== (1 & this._cycle) && (this._time = g - this._time), this._time > g ? this._time = g : 0 > this._time && (this._time = 0)), this._easeType ? (l = this._time / g, _ = this._easeType, u = this._easePower, (1 === _ || 3 === _ && l >= .5) && (l = 1 - l), 3 === _ && (l *= 2), 1 === u ? l *= l : 2 === u ? l *= l * l : 3 === u ? l *= l * l * l : 4 === u && (l *= l * l * l * l), this.ratio = 1 === _ ? 1 - l : 2 === _ ? l : .5 > this._time / g ? l / 2 : 1 - l / 2) : this.ratio = this._ease.getRatio(this._time / g)), p === this._time && !i && d === this._cycle) return m !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")), void 0;
      if (!this._initted) {
        if (this._init(), !this._initted || this._gc) return;
        if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = p, this._totalTime = m, this._rawPrevTime = v, this._cycle = d, a.lazyTweens.push(this), this._lazy = [t, e], void 0;
        this._time && !s ? this.ratio = this._ease.getRatio(this._time / g) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
      }
      for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== p && t >= 0 && (this._active = !0), 0 === m && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === g) && (e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
      this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._totalTime !== m || s) && this._callback("onUpdate")), this._cycle !== d && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === g && this._rawPrevTime === n && c !== n && (this._rawPrevTime = 0));
    }, _r.to = function (t, e, i) {
      return new _r(t, e, i);
    }, _r.from = function (t, e, i) {
      return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new _r(t, e, i);
    }, _r.fromTo = function (t, e, i, s) {
      return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new _r(t, e, s);
    }, _r.staggerTo = _r.allTo = function (t, e, n, a, l, u, c) {
      a = a || 0;
      var f,
        p,
        m,
        d,
        g = n.delay || 0,
        v = [],
        y = function y() {
          n.onComplete && n.onComplete.apply(n.onCompleteScope || this, arguments), l.apply(c || n.callbackScope || this, u || _);
        };
      for (h(t) || ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = s(t))), t = t || [], 0 > a && (t = s(t), t.reverse(), a *= -1), f = t.length - 1, m = 0; f >= m; m++) {
        p = {};
        for (d in n) p[d] = n[d];
        p.delay = g, m === f && l && (p.onComplete = y), v[m] = new _r(t[m], e, p), g += a;
      }
      return v;
    }, _r.staggerFrom = _r.allFrom = function (t, e, i, s, n, a, o) {
      return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, _r.staggerTo(t, e, i, s, n, a, o);
    }, _r.staggerFromTo = _r.allFromTo = function (t, e, i, s, n, a, o, h) {
      return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, _r.staggerTo(t, e, s, n, a, o, h);
    }, _r.delayedCall = function (t, e, i, s, n) {
      return new _r(e, 0, {
        delay: t,
        onComplete: e,
        onCompleteParams: i,
        callbackScope: s,
        onReverseComplete: e,
        onReverseCompleteParams: i,
        immediateRender: !1,
        useFrames: n,
        overwrite: 0
      });
    }, _r.set = function (t, e) {
      return new _r(t, 0, e);
    }, _r.isTweening = function (t) {
      return i.getTweensOf(t, !0).length > 0;
    };
    var _u = function u(t, e) {
        for (var s = [], r = 0, n = t._first; n;) n instanceof i ? s[r++] = n : (e && (s[r++] = n), s = s.concat(_u(n, e)), r = s.length), n = n._next;
        return s;
      },
      c = _r.getAllTweens = function (e) {
        return _u(t._rootTimeline, e).concat(_u(t._rootFramesTimeline, e));
      };
    _r.killAll = function (t, i, s, r) {
      null == i && (i = !0), null == s && (s = !0);
      var n,
        a,
        o,
        h = c(0 != r),
        l = h.length,
        _ = i && s && r;
      for (o = 0; l > o; o++) a = h[o], (_ || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1));
    }, _r.killChildTweensOf = function (t, e) {
      if (null != t) {
        var n,
          l,
          _,
          u,
          c,
          f = a.tweenLookup;
        if ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = s(t)), h(t)) for (u = t.length; --u > -1;) _r.killChildTweensOf(t[u], e);else {
          n = [];
          for (_ in f) for (l = f[_].target.parentNode; l;) l === t && (n = n.concat(f[_].tweens)), l = l.parentNode;
          for (c = n.length, u = 0; c > u; u++) e && n[u].totalTime(n[u].totalDuration()), n[u]._enabled(!1, !1);
        }
      }
    };
    var f = function f(t, i, s, r) {
      i = i !== !1, s = s !== !1, r = r !== !1;
      for (var n, a, o = c(r), h = i && s && r, l = o.length; --l > -1;) a = o[l], (h || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && a.paused(t);
    };
    return _r.pauseAll = function (t, e, i) {
      f(!0, t, e, i);
    }, _r.resumeAll = function (t, e, i) {
      f(!1, t, e, i);
    }, _r.globalTimeScale = function (e) {
      var s = t._rootTimeline,
        r = i.ticker.time;
      return arguments.length ? (e = e || n, s._startTime = r - (r - s._startTime) * s._timeScale / e, s = t._rootFramesTimeline, r = i.ticker.frame, s._startTime = r - (r - s._startTime) * s._timeScale / e, s._timeScale = t._rootTimeline._timeScale = e, e) : s._timeScale;
    }, l.progress = function (t) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration();
    }, l.totalProgress = function (t) {
      return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration();
    }, l.time = function (t, e) {
      return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time;
    }, l.duration = function (e) {
      return arguments.length ? t.prototype.duration.call(this, e) : this._duration;
    }, l.totalDuration = function (t) {
      return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration);
    }, l.repeat = function (t) {
      return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat;
    }, l.repeatDelay = function (t) {
      return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay;
    }, l.yoyo = function (t) {
      return arguments.length ? (this._yoyo = t, this) : this._yoyo;
    }, _r;
  }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
    var s = function s(t) {
        e.call(this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
        var i,
          s,
          r = this.vars;
        for (s in r) i = r[s], h(i) && -1 !== i.join("").indexOf("{self}") && (r[s] = this._swapSelfInParams(i));
        h(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger);
      },
      r = 1e-10,
      n = i._internals,
      a = s._internals = {},
      o = n.isSelector,
      h = n.isArray,
      l = n.lazyTweens,
      _ = n.lazyRender,
      u = [],
      c = _gsScope._gsDefine.globals,
      f = function f(t) {
        var e,
          i = {};
        for (e in t) i[e] = t[e];
        return i;
      },
      p = a.pauseCallback = function (t, e, i, s) {
        var n,
          a = t._timeline,
          o = a._totalTime,
          h = t._startTime,
          l = 0 > t._rawPrevTime || 0 === t._rawPrevTime && a._reversed,
          _ = l ? 0 : r,
          c = l ? r : 0;
        if (e || !this._forcingPlayhead) {
          for (a.pause(h), n = t._prev; n && n._startTime === h;) n._rawPrevTime = c, n = n._prev;
          for (n = t._next; n && n._startTime === h;) n._rawPrevTime = _, n = n._next;
          e && e.apply(s || a.vars.callbackScope || a, i || u), (this._forcingPlayhead || !a._paused) && a.seek(o);
        }
      },
      m = function m(t) {
        var e,
          i = [],
          s = t.length;
        for (e = 0; e !== s; i.push(t[e++]));
        return i;
      },
      d = s.prototype = new e();
    return s.version = "1.17.0", d.constructor = s, d.kill()._gc = d._forcingPlayhead = !1, d.to = function (t, e, s, r) {
      var n = s.repeat && c.TweenMax || i;
      return e ? this.add(new n(t, e, s), r) : this.set(t, s, r);
    }, d.from = function (t, e, s, r) {
      return this.add((s.repeat && c.TweenMax || i).from(t, e, s), r);
    }, d.fromTo = function (t, e, s, r, n) {
      var a = r.repeat && c.TweenMax || i;
      return e ? this.add(a.fromTo(t, e, s, r), n) : this.set(t, r, n);
    }, d.staggerTo = function (t, e, r, n, a, h, l, _) {
      var u,
        c = new s({
          onComplete: h,
          onCompleteParams: l,
          callbackScope: _,
          smoothChildTiming: this.smoothChildTiming
        });
      for ("string" == typeof t && (t = i.selector(t) || t), t = t || [], o(t) && (t = m(t)), n = n || 0, 0 > n && (t = m(t), t.reverse(), n *= -1), u = 0; t.length > u; u++) r.startAt && (r.startAt = f(r.startAt)), c.to(t[u], e, f(r), u * n);
      return this.add(c, a);
    }, d.staggerFrom = function (t, e, i, s, r, n, a, o) {
      return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, s, r, n, a, o);
    }, d.staggerFromTo = function (t, e, i, s, r, n, a, o, h) {
      return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, s, r, n, a, o, h);
    }, d.call = function (t, e, s, r) {
      return this.add(i.delayedCall(0, t, e, s), r);
    }, d.set = function (t, e, s) {
      return s = this._parseTimeOrLabel(s, 0, !0), null == e.immediateRender && (e.immediateRender = s === this._time && !this._paused), this.add(new i(t, 0, e), s);
    }, s.exportRoot = function (t, e) {
      t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
      var r,
        n,
        a = new s(t),
        o = a._timeline;
      for (null == e && (e = !0), o._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = o._time, r = o._first; r;) n = r._next, e && r instanceof i && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay), r = n;
      return o.add(a, 0), a;
    }, d.add = function (r, n, a, o) {
      var l, _, u, c, f, p;
      if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, r)), !(r instanceof t)) {
        if (r instanceof Array || r && r.push && h(r)) {
          for (a = a || "normal", o = o || 0, l = n, _ = r.length, u = 0; _ > u; u++) h(c = r[u]) && (c = new s({
            tweens: c
          })), this.add(c, l), "string" != typeof c && "function" != typeof c && ("sequence" === a ? l = c._startTime + c.totalDuration() / c._timeScale : "start" === a && (c._startTime -= c.delay())), l += o;
          return this._uncache(!0);
        }
        if ("string" == typeof r) return this.addLabel(r, n);
        if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
        r = i.delayedCall(0, r);
      }
      if (e.prototype.add.call(this, r, n), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (f = this, p = f.rawTime() > r._startTime; f._timeline;) p && f._timeline.smoothChildTiming ? f.totalTime(f._totalTime, !0) : f._gc && f._enabled(!0, !1), f = f._timeline;
      return this;
    }, d.remove = function (e) {
      if (e instanceof t) return this._remove(e, !1);
      if (e instanceof Array || e && e.push && h(e)) {
        for (var i = e.length; --i > -1;) this.remove(e[i]);
        return this;
      }
      return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e);
    }, d._remove = function (t, i) {
      e.prototype._remove.call(this, t, i);
      var s = this._last;
      return s ? this._time > s._startTime + s._totalDuration / s._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this;
    }, d.append = function (t, e) {
      return this.add(t, this._parseTimeOrLabel(null, e, !0, t));
    }, d.insert = d.insertMultiple = function (t, e, i, s) {
      return this.add(t, e || 0, i, s);
    }, d.appendMultiple = function (t, e, i, s) {
      return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, s);
    }, d.addLabel = function (t, e) {
      return this._labels[t] = this._parseTimeOrLabel(e), this;
    }, d.addPause = function (t, e, s, r) {
      var n = i.delayedCall(0, p, ["{self}", e, s, r], this);
      return n.data = "isPause", this.add(n, t);
    }, d.removeLabel = function (t) {
      return delete this._labels[t], this;
    }, d.getLabelTime = function (t) {
      return null != this._labels[t] ? this._labels[t] : -1;
    }, d._parseTimeOrLabel = function (e, i, s, r) {
      var n;
      if (r instanceof t && r.timeline === this) this.remove(r);else if (r && (r instanceof Array || r.push && h(r))) for (n = r.length; --n > -1;) r[n] instanceof t && r[n].timeline === this && this.remove(r[n]);
      if ("string" == typeof i) return this._parseTimeOrLabel(i, s && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, s);
      if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = this.duration());else {
        if (n = e.indexOf("="), -1 === n) return null == this._labels[e] ? s ? this._labels[e] = this.duration() + i : i : this._labels[e] + i;
        i = parseInt(e.charAt(n - 1) + "1", 10) * Number(e.substr(n + 1)), e = n > 1 ? this._parseTimeOrLabel(e.substr(0, n - 1), 0, s) : this.duration();
      }
      return Number(e) + i;
    }, d.seek = function (t, e) {
      return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1);
    }, d.stop = function () {
      return this.paused(!0);
    }, d.gotoAndPlay = function (t, e) {
      return this.play(t, e);
    }, d.gotoAndStop = function (t, e) {
      return this.pause(t, e);
    }, d.render = function (t, e, i) {
      this._gc && this._enabled(!0, !1);
      var s,
        n,
        a,
        o,
        h,
        u = this._dirty ? this.totalDuration() : this._totalDuration,
        c = this._time,
        f = this._startTime,
        p = this._timeScale,
        m = this._paused;
      if (t >= u) this._totalTime = this._time = u, this._reversed || this._hasPausedChild() || (n = !0, o = "onComplete", h = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === t || 0 > this._rawPrevTime || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (h = !0, this._rawPrevTime > r && (o = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = u + 1e-4;else if (1e-7 > t) {
        if (this._totalTime = this._time = 0, (0 !== c || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || 0 > t && this._rawPrevTime >= 0)) && (o = "onReverseComplete", n = this._reversed), 0 > t) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (h = n = !0, o = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (h = !0), this._rawPrevTime = t;else {
          if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, 0 === t && n) for (s = this._first; s && 0 === s._startTime;) s._duration || (n = !1), s = s._next;
          t = 0, this._initted || (h = !0);
        }
      } else this._totalTime = this._time = this._rawPrevTime = t;
      if (this._time !== c && this._first || i || h) {
        if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== c && t > 0 && (this._active = !0), 0 === c && this.vars.onStart && 0 !== this._time && (e || this._callback("onStart")), this._time >= c) for (s = this._first; s && (a = s._next, !this._paused || m);) (s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;else for (s = this._last; s && (a = s._prev, !this._paused || m);) (s._active || c >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;
        this._onUpdate && (e || (l.length && _(), this._callback("onUpdate"))), o && (this._gc || (f === this._startTime || p !== this._timeScale) && (0 === this._time || u >= this.totalDuration()) && (n && (l.length && _(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this._callback(o)));
      }
    }, d._hasPausedChild = function () {
      for (var t = this._first; t;) {
        if (t._paused || t instanceof s && t._hasPausedChild()) return !0;
        t = t._next;
      }
      return !1;
    }, d.getChildren = function (t, e, s, r) {
      r = r || -9999999999;
      for (var n = [], a = this._first, o = 0; a;) r > a._startTime || (a instanceof i ? e !== !1 && (n[o++] = a) : (s !== !1 && (n[o++] = a), t !== !1 && (n = n.concat(a.getChildren(!0, e, s)), o = n.length))), a = a._next;
      return n;
    }, d.getTweensOf = function (t, e) {
      var s,
        r,
        n = this._gc,
        a = [],
        o = 0;
      for (n && this._enabled(!0, !0), s = i.getTweensOf(t), r = s.length; --r > -1;) (s[r].timeline === this || e && this._contains(s[r])) && (a[o++] = s[r]);
      return n && this._enabled(!1, !0), a;
    }, d.recent = function () {
      return this._recent;
    }, d._contains = function (t) {
      for (var e = t.timeline; e;) {
        if (e === this) return !0;
        e = e.timeline;
      }
      return !1;
    }, d.shiftChildren = function (t, e, i) {
      i = i || 0;
      for (var s, r = this._first, n = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
      if (e) for (s in n) n[s] >= i && (n[s] += t);
      return this._uncache(!0);
    }, d._kill = function (t, e) {
      if (!t && !e) return this._enabled(!1, !1);
      for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), s = i.length, r = !1; --s > -1;) i[s]._kill(t, e) && (r = !0);
      return r;
    }, d.clear = function (t) {
      var e = this.getChildren(!1, !0, !0),
        i = e.length;
      for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
      return t !== !1 && (this._labels = {}), this._uncache(!0);
    }, d.invalidate = function () {
      for (var e = this._first; e;) e.invalidate(), e = e._next;
      return t.prototype.invalidate.call(this);
    }, d._enabled = function (t, i) {
      if (t === this._gc) for (var s = this._first; s;) s._enabled(t, !0), s = s._next;
      return e.prototype._enabled.call(this, t, i);
    }, d.totalTime = function () {
      this._forcingPlayhead = !0;
      var e = t.prototype.totalTime.apply(this, arguments);
      return this._forcingPlayhead = !1, e;
    }, d.duration = function (t) {
      return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration);
    }, d.totalDuration = function (t) {
      if (!arguments.length) {
        if (this._dirty) {
          for (var e, i, s = 0, r = this._last, n = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > n && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : n = r._startTime, 0 > r._startTime && !r._paused && (s -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), n = 0), i = r._startTime + r._totalDuration / r._timeScale, i > s && (s = i), r = e;
          this._duration = this._totalDuration = s, this._dirty = !1;
        }
        return this._totalDuration;
      }
      return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this;
    }, d.paused = function (e) {
      if (!e) for (var i = this._first, s = this._time; i;) i._startTime === s && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
      return t.prototype.paused.apply(this, arguments);
    }, d.usesFrames = function () {
      for (var e = this._timeline; e._timeline;) e = e._timeline;
      return e === t._rootFramesTimeline;
    }, d.rawTime = function () {
      return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
    }, s;
  }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (t, e, i) {
    var s = function s(e) {
        t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0;
      },
      r = 1e-10,
      n = e._internals,
      a = n.lazyTweens,
      o = n.lazyRender,
      h = new i(null, null, 1, 0),
      l = s.prototype = new t();
    return l.constructor = s, l.kill()._gc = !1, s.version = "1.17.0", l.invalidate = function () {
      return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this);
    }, l.addCallback = function (t, i, s, r) {
      return this.add(e.delayedCall(0, t, s, r), i);
    }, l.removeCallback = function (t, e) {
      if (t) if (null == e) this._kill(null, t);else for (var i = this.getTweensOf(t, !1), s = i.length, r = this._parseTimeOrLabel(e); --s > -1;) i[s]._startTime === r && i[s]._enabled(!1, !1);
      return this;
    }, l.removePause = function (e) {
      return this.removeCallback(t._internals.pauseCallback, e);
    }, l.tweenTo = function (t, i) {
      i = i || {};
      var s,
        r,
        n,
        a = {
          ease: h,
          useFrames: this.usesFrames(),
          immediateRender: !1
        };
      for (r in i) a[r] = i[r];
      return a.time = this._parseTimeOrLabel(t), s = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, n = new e(this, s, a), a.onStart = function () {
        n.target.paused(!0), n.vars.time !== n.target.time() && s === n.duration() && n.duration(Math.abs(n.vars.time - n.target.time()) / n.target._timeScale), i.onStart && n._callback("onStart");
      }, n;
    }, l.tweenFromTo = function (t, e, i) {
      i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
        onComplete: this.seek,
        onCompleteParams: [t],
        callbackScope: this
      }, i.immediateRender = i.immediateRender !== !1;
      var s = this.tweenTo(e, i);
      return s.duration(Math.abs(s.vars.time - t) / this._timeScale || .001);
    }, l.render = function (t, e, i) {
      this._gc && this._enabled(!0, !1);
      var s,
        n,
        h,
        l,
        _,
        u,
        c = this._dirty ? this.totalDuration() : this._totalDuration,
        f = this._duration,
        p = this._time,
        m = this._totalTime,
        d = this._startTime,
        g = this._timeScale,
        v = this._rawPrevTime,
        y = this._paused,
        T = this._cycle;
      if (t >= c) this._locked || (this._totalTime = c, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (n = !0, l = "onComplete", _ = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === t || 0 > v || v === r) && v !== t && this._first && (_ = !0, v > r && (l = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = f, t = f + 1e-4);else if (1e-7 > t) {
        if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== p || 0 === f && v !== r && (v > 0 || 0 > t && v >= 0) && !this._locked) && (l = "onReverseComplete", n = this._reversed), 0 > t) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (_ = n = !0, l = "onReverseComplete") : v >= 0 && this._first && (_ = !0), this._rawPrevTime = t;else {
          if (this._rawPrevTime = f || !e || t || this._rawPrevTime === t ? t : r, 0 === t && n) for (s = this._first; s && 0 === s._startTime;) s._duration || (n = !1), s = s._next;
          t = 0, this._initted || (_ = !0);
        }
      } else 0 === f && 0 > v && (_ = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (u = f + this._repeatDelay, this._cycle = this._totalTime / u >> 0, 0 !== this._cycle && this._cycle === this._totalTime / u && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && 0 !== (1 & this._cycle) && (this._time = f - this._time), this._time > f ? (this._time = f, t = f + 1e-4) : 0 > this._time ? this._time = t = 0 : t = this._time));
      if (this._cycle !== T && !this._locked) {
        var x = this._yoyo && 0 !== (1 & T),
          w = x === (this._yoyo && 0 !== (1 & this._cycle)),
          b = this._totalTime,
          P = this._cycle,
          k = this._rawPrevTime,
          S = this._time;
        if (this._totalTime = T * f, T > this._cycle ? x = !x : this._totalTime += f, this._time = p, this._rawPrevTime = 0 === f ? v - 1e-4 : v, this._cycle = T, this._locked = !0, p = x ? 0 : f, this.render(p, e, 0 === f), e || this._gc || this.vars.onRepeat && this._callback("onRepeat"), w && (p = x ? f + 1e-4 : -1e-4, this.render(p, !0, !1)), this._locked = !1, this._paused && !y) return;
        this._time = S, this._totalTime = b, this._cycle = P, this._rawPrevTime = k;
      }
      if (!(this._time !== p && this._first || i || _)) return m !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")), void 0;
      if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== m && t > 0 && (this._active = !0), 0 === m && this.vars.onStart && 0 !== this._totalTime && (e || this._callback("onStart")), this._time >= p) for (s = this._first; s && (h = s._next, !this._paused || y);) (s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = h;else for (s = this._last; s && (h = s._prev, !this._paused || y);) (s._active || p >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = h;
      this._onUpdate && (e || (a.length && o(), this._callback("onUpdate"))), l && (this._locked || this._gc || (d === this._startTime || g !== this._timeScale) && (0 === this._time || c >= this.totalDuration()) && (n && (a.length && o(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[l] && this._callback(l)));
    }, l.getActive = function (t, e, i) {
      null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
      var s,
        r,
        n = [],
        a = this.getChildren(t, e, i),
        o = 0,
        h = a.length;
      for (s = 0; h > s; s++) r = a[s], r.isActive() && (n[o++] = r);
      return n;
    }, l.getLabelAfter = function (t) {
      t || 0 !== t && (t = this._time);
      var e,
        i = this.getLabelsArray(),
        s = i.length;
      for (e = 0; s > e; e++) if (i[e].time > t) return i[e].name;
      return null;
    }, l.getLabelBefore = function (t) {
      null == t && (t = this._time);
      for (var e = this.getLabelsArray(), i = e.length; --i > -1;) if (t > e[i].time) return e[i].name;
      return null;
    }, l.getLabelsArray = function () {
      var t,
        e = [],
        i = 0;
      for (t in this._labels) e[i++] = {
        time: this._labels[t],
        name: t
      };
      return e.sort(function (t, e) {
        return t.time - e.time;
      }), e;
    }, l.progress = function (t, e) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration();
    }, l.totalProgress = function (t, e) {
      return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration();
    }, l.totalDuration = function (e) {
      return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration);
    }, l.time = function (t, e) {
      return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time;
    }, l.repeat = function (t) {
      return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat;
    }, l.repeatDelay = function (t) {
      return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay;
    }, l.yoyo = function (t) {
      return arguments.length ? (this._yoyo = t, this) : this._yoyo;
    }, l.currentLabel = function (t) {
      return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8);
    }, s;
  }, !0), function () {
    var t = 180 / Math.PI,
      e = [],
      i = [],
      s = [],
      r = {},
      n = _gsScope._gsDefine.globals,
      a = function a(t, e, i, s) {
        this.a = t, this.b = e, this.c = i, this.d = s, this.da = s - t, this.ca = i - t, this.ba = e - t;
      },
      o = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
      h = function h(t, e, i, s) {
        var r = {
            a: t
          },
          n = {},
          a = {},
          o = {
            c: s
          },
          h = (t + e) / 2,
          l = (e + i) / 2,
          _ = (i + s) / 2,
          u = (h + l) / 2,
          c = (l + _) / 2,
          f = (c - u) / 8;
        return r.b = h + (t - h) / 4, n.b = u + f, r.c = n.a = (r.b + n.b) / 2, n.c = a.a = (u + c) / 2, a.b = c - f, o.b = _ + (s - _) / 4, a.c = o.a = (a.b + o.b) / 2, [r, n, a, o];
      },
      l = function l(t, r, n, a, o) {
        var l,
          _,
          u,
          c,
          f,
          p,
          m,
          d,
          g,
          v,
          y,
          T,
          x,
          w = t.length - 1,
          b = 0,
          P = t[0].a;
        for (l = 0; w > l; l++) f = t[b], _ = f.a, u = f.d, c = t[b + 1].d, o ? (y = e[l], T = i[l], x = .25 * (T + y) * r / (a ? .5 : s[l] || .5), p = u - (u - _) * (a ? .5 * r : 0 !== y ? x / y : 0), m = u + (c - u) * (a ? .5 * r : 0 !== T ? x / T : 0), d = u - (p + ((m - p) * (3 * y / (y + T) + .5) / 4 || 0))) : (p = u - .5 * (u - _) * r, m = u + .5 * (c - u) * r, d = u - (p + m) / 2), p += d, m += d, f.c = g = p, f.b = 0 !== l ? P : P = f.a + .6 * (f.c - f.a), f.da = u - _, f.ca = g - _, f.ba = P - _, n ? (v = h(_, P, g, u), t.splice(b, 1, v[0], v[1], v[2], v[3]), b += 4) : b++, P = m;
        f = t[b], f.b = P, f.c = P + .4 * (f.d - P), f.da = f.d - f.a, f.ca = f.c - f.a, f.ba = P - f.a, n && (v = h(f.a, P, f.c, f.d), t.splice(b, 1, v[0], v[1], v[2], v[3]));
      },
      _ = function _(t, s, r, n) {
        var o,
          h,
          l,
          _,
          u,
          c,
          f = [];
        if (n) for (t = [n].concat(t), h = t.length; --h > -1;) "string" == typeof (c = t[h][s]) && "=" === c.charAt(1) && (t[h][s] = n[s] + Number(c.charAt(0) + c.substr(2)));
        if (o = t.length - 2, 0 > o) return f[0] = new a(t[0][s], 0, 0, t[-1 > o ? 0 : 1][s]), f;
        for (h = 0; o > h; h++) l = t[h][s], _ = t[h + 1][s], f[h] = new a(l, 0, 0, _), r && (u = t[h + 2][s], e[h] = (e[h] || 0) + (_ - l) * (_ - l), i[h] = (i[h] || 0) + (u - _) * (u - _));
        return f[h] = new a(t[h][s], 0, 0, t[h + 1][s]), f;
      },
      u = function u(t, n, a, h, _u2, c) {
        var f,
          p,
          m,
          d,
          g,
          v,
          y,
          T,
          x = {},
          w = [],
          b = c || t[0];
        _u2 = "string" == typeof _u2 ? "," + _u2 + "," : o, null == n && (n = 1);
        for (p in t[0]) w.push(p);
        if (t.length > 1) {
          for (T = t[t.length - 1], y = !0, f = w.length; --f > -1;) if (p = w[f], Math.abs(b[p] - T[p]) > .05) {
            y = !1;
            break;
          }
          y && (t = t.concat(), c && t.unshift(c), t.push(t[1]), c = t[t.length - 3]);
        }
        for (e.length = i.length = s.length = 0, f = w.length; --f > -1;) p = w[f], r[p] = -1 !== _u2.indexOf("," + p + ","), x[p] = _(t, p, r[p], c);
        for (f = e.length; --f > -1;) e[f] = Math.sqrt(e[f]), i[f] = Math.sqrt(i[f]);
        if (!h) {
          for (f = w.length; --f > -1;) if (r[p]) for (m = x[w[f]], v = m.length - 1, d = 0; v > d; d++) g = m[d + 1].da / i[d] + m[d].da / e[d], s[d] = (s[d] || 0) + g * g;
          for (f = s.length; --f > -1;) s[f] = Math.sqrt(s[f]);
        }
        for (f = w.length, d = a ? 4 : 1; --f > -1;) p = w[f], m = x[p], l(m, n, a, h, r[p]), y && (m.splice(0, d), m.splice(m.length - d, d));
        return x;
      },
      c = function c(t, e, i) {
        e = e || "soft";
        var s,
          r,
          n,
          o,
          h,
          l,
          _,
          u,
          c,
          f,
          p,
          m = {},
          d = "cubic" === e ? 3 : 2,
          g = "soft" === e,
          v = [];
        if (g && i && (t = [i].concat(t)), null == t || d + 1 > t.length) throw "invalid Bezier data";
        for (c in t[0]) v.push(c);
        for (l = v.length; --l > -1;) {
          for (c = v[l], m[c] = h = [], f = 0, u = t.length, _ = 0; u > _; _++) s = null == i ? t[_][c] : "string" == typeof (p = t[_][c]) && "=" === p.charAt(1) ? i[c] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && _ > 1 && u - 1 > _ && (h[f++] = (s + h[f - 2]) / 2), h[f++] = s;
          for (u = f - d + 1, f = 0, _ = 0; u > _; _ += d) s = h[_], r = h[_ + 1], n = h[_ + 2], o = 2 === d ? 0 : h[_ + 3], h[f++] = p = 3 === d ? new a(s, r, n, o) : new a(s, (2 * r + s) / 3, (2 * r + n) / 3, n);
          h.length = f;
        }
        return m;
      },
      f = function f(t, e, i) {
        for (var s, r, n, a, o, h, l, _, u, c, f, p = 1 / i, m = t.length; --m > -1;) for (c = t[m], n = c.a, a = c.d - n, o = c.c - n, h = c.b - n, s = r = 0, _ = 1; i >= _; _++) l = p * _, u = 1 - l, s = r - (r = (l * l * a + 3 * u * (l * o + u * h)) * l), f = m * i + _ - 1, e[f] = (e[f] || 0) + s * s;
      },
      p = function p(t, e) {
        e = e >> 0 || 6;
        var i,
          s,
          r,
          n,
          a = [],
          o = [],
          h = 0,
          l = 0,
          _ = e - 1,
          u = [],
          c = [];
        for (i in t) f(t[i], a, e);
        for (r = a.length, s = 0; r > s; s++) h += Math.sqrt(a[s]), n = s % e, c[n] = h, n === _ && (l += h, n = s / e >> 0, u[n] = c, o[n] = l, h = 0, c = []);
        return {
          length: l,
          lengths: o,
          segments: u
        };
      },
      m = _gsScope._gsDefine.plugin({
        propName: "bezier",
        priority: -1,
        version: "1.3.4",
        API: 2,
        global: !0,
        init: function init(t, e, i) {
          this._target = t, e instanceof Array && (e = {
            values: e
          }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
          var s,
            r,
            n,
            a,
            o,
            h = e.values || [],
            l = {},
            _ = h[0],
            f = e.autoRotate || i.vars.orientToBezier;
          this._autoRotate = f ? f instanceof Array ? f : [["x", "y", "rotation", f === !0 ? 0 : Number(f) || 0]] : null;
          for (s in _) this._props.push(s);
          for (n = this._props.length; --n > -1;) s = this._props[n], this._overwriteProps.push(s), r = this._func[s] = "function" == typeof t[s], l[s] = r ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]() : parseFloat(t[s]), o || l[s] !== h[0][s] && (o = l);
          if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : c(h, e.type, l), this._segCount = this._beziers[s].length, this._timeRes) {
            var m = p(this._beziers, this._timeRes);
            this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length;
          }
          if (f = this._autoRotate) for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), n = f.length; --n > -1;) {
            for (a = 0; 3 > a; a++) s = f[n][a], this._func[s] = "function" == typeof t[s] ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)] : !1;
            s = f[n][2], this._initialRotations[n] = this._func[s] ? this._func[s].call(this._target) : this._target[s];
          }
          return this._startRatio = i.vars.runBackwards ? 1 : 0, !0;
        },
        set: function set(e) {
          var i,
            s,
            r,
            n,
            a,
            o,
            h,
            l,
            _,
            u,
            c = this._segCount,
            f = this._func,
            p = this._target,
            m = e !== this._startRatio;
          if (this._timeRes) {
            if (_ = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && c - 1 > r) {
              for (l = c - 1; l > r && e >= (this._l2 = _[++r]););
              this._l1 = _[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0];
            } else if (this._l1 > e && r > 0) {
              for (; r > 0 && (this._l1 = _[--r]) >= e;);
              0 === r && this._l1 > e ? this._l1 = 0 : r++, this._l2 = _[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si];
            }
            if (i = r, e -= this._l1, r = this._si, e > this._s2 && u.length - 1 > r) {
              for (l = u.length - 1; l > r && e >= (this._s2 = u[++r]););
              this._s1 = u[r - 1], this._si = r;
            } else if (this._s1 > e && r > 0) {
              for (; r > 0 && (this._s1 = u[--r]) >= e;);
              0 === r && this._s1 > e ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r;
            }
            o = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec;
          } else i = 0 > e ? 0 : e >= 1 ? c - 1 : c * e >> 0, o = (e - i * (1 / c)) * c;
          for (s = 1 - o, r = this._props.length; --r > -1;) n = this._props[r], a = this._beziers[n][i], h = (o * o * a.da + 3 * s * (o * a.ca + s * a.ba)) * o + a.a, this._round[n] && (h = Math.round(h)), f[n] ? p[n](h) : p[n] = h;
          if (this._autoRotate) {
            var d,
              g,
              v,
              y,
              T,
              x,
              w,
              b = this._autoRotate;
            for (r = b.length; --r > -1;) n = b[r][2], x = b[r][3] || 0, w = b[r][4] === !0 ? 1 : t, a = this._beziers[b[r][0]], d = this._beziers[b[r][1]], a && d && (a = a[i], d = d[i], g = a.a + (a.b - a.a) * o, y = a.b + (a.c - a.b) * o, g += (y - g) * o, y += (a.c + (a.d - a.c) * o - y) * o, v = d.a + (d.b - d.a) * o, T = d.b + (d.c - d.b) * o, v += (T - v) * o, T += (d.c + (d.d - d.c) * o - T) * o, h = m ? Math.atan2(T - v, y - g) * w + x : this._initialRotations[r], f[n] ? p[n](h) : p[n] = h);
          }
        }
      }),
      d = m.prototype;
    m.bezierThrough = u, m.cubicToQuadratic = h, m._autoCSS = !0, m.quadraticToCubic = function (t, e, i) {
      return new a(t, (2 * e + t) / 3, (2 * e + i) / 3, i);
    }, m._cssRegister = function () {
      var t = n.CSSPlugin;
      if (t) {
        var e = t._internals,
          i = e._parseToProxy,
          s = e._setPluginRatio,
          r = e.CSSPropTween;
        e._registerComplexSpecialProp("bezier", {
          parser: function parser(t, e, n, a, o, h) {
            e instanceof Array && (e = {
              values: e
            }), h = new m();
            var l,
              _,
              u,
              c = e.values,
              f = c.length - 1,
              p = [],
              d = {};
            if (0 > f) return o;
            for (l = 0; f >= l; l++) u = i(t, c[l], a, o, h, f !== l), p[l] = u.end;
            for (_ in e) d[_] = e[_];
            return d.values = p, o = new r(t, "bezier", 0, 0, u.pt, 2), o.data = u, o.plugin = h, o.setRatio = s, 0 === d.autoRotate && (d.autoRotate = !0), !d.autoRotate || d.autoRotate instanceof Array || (l = d.autoRotate === !0 ? 0 : Number(d.autoRotate), d.autoRotate = null != u.end.left ? [["left", "top", "rotation", l, !1]] : null != u.end.x ? [["x", "y", "rotation", l, !1]] : !1), d.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform), h._onInitTween(u.proxy, d, a._tween), o;
          }
        });
      }
    }, d._roundProps = function (t, e) {
      for (var i = this._overwriteProps, s = i.length; --s > -1;) (t[i[s]] || t.bezier || t.bezierThrough) && (this._round[i[s]] = e);
    }, d._kill = function (t) {
      var e,
        i,
        s = this._props;
      for (e in this._beziers) if (e in t) for (delete this._beziers[e], delete this._func[e], i = s.length; --i > -1;) s[i] === e && s.splice(i, 1);
      return this._super._kill.call(this, t);
    };
  }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) {
    var i,
      s,
      r,
      n,
      _a = function a() {
        t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = _a.prototype.setRatio;
      },
      o = _gsScope._gsDefine.globals,
      h = {},
      l = _a.prototype = new t("css");
    l.constructor = _a, _a.version = "1.17.0", _a.API = 2, _a.defaultTransformPerspective = 0, _a.defaultSkewType = "compensated", _a.defaultSmoothOrigin = !0, l = "px", _a.suffixMap = {
      top: l,
      right: l,
      bottom: l,
      left: l,
      width: l,
      height: l,
      fontSize: l,
      padding: l,
      margin: l,
      perspective: l,
      lineHeight: ""
    };
    var _,
      u,
      c,
      f,
      p,
      m,
      d = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
      g = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
      v = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
      y = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
      T = /(?:\d|\-|\+|=|#|\.)*/g,
      x = /opacity *= *([^)]*)/i,
      w = /opacity:([^;]*)/i,
      b = /alpha\(opacity *=.+?\)/i,
      P = /^(rgb|hsl)/,
      k = /([A-Z])/g,
      S = /-([a-z])/gi,
      R = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
      O = function O(t, e) {
        return e.toUpperCase();
      },
      A = /(?:Left|Right|Width)/i,
      C = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
      D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
      M = /,(?=[^\)]*(?:\(|$))/gi,
      z = Math.PI / 180,
      I = 180 / Math.PI,
      F = {},
      N = document,
      E = function E(t) {
        return N.createElementNS ? N.createElementNS("http://www.w3.org/1999/xhtml", t) : N.createElement(t);
      },
      L = E("div"),
      X = E("img"),
      B = _a._internals = {
        _specialProps: h
      },
      Y = navigator.userAgent,
      j = function () {
        var t = Y.indexOf("Android"),
          e = E("a");
        return c = -1 !== Y.indexOf("Safari") && -1 === Y.indexOf("Chrome") && (-1 === t || Number(Y.substr(t + 8, 1)) > 3), p = c && 6 > Number(Y.substr(Y.indexOf("Version/") + 8, 1)), f = -1 !== Y.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Y) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Y)) && (m = parseFloat(RegExp.$1)), e ? (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity)) : !1;
      }(),
      U = function U(t) {
        return x.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
      },
      q = function q(t) {
        window.console && console.log(t);
      },
      V = "",
      G = "",
      W = function W(t, e) {
        e = e || L;
        var i,
          s,
          r = e.style;
        if (void 0 !== r[t]) return t;
        for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], s = 5; --s > -1 && void 0 === r[i[s] + t];);
        return s >= 0 ? (G = 3 === s ? "ms" : i[s], V = "-" + G.toLowerCase() + "-", G + t) : null;
      },
      Z = N.defaultView ? N.defaultView.getComputedStyle : function () {},
      Q = _a.getStyle = function (t, e, i, s, r) {
        var n;
        return j || "opacity" !== e ? (!s && t.style[e] ? n = t.style[e] : (i = i || Z(t)) ? n = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(k, "-$1").toLowerCase()) : t.currentStyle && (n = t.currentStyle[e]), null == r || n && "none" !== n && "auto" !== n && "auto auto" !== n ? n : r) : U(t);
      },
      $ = B.convertToPixels = function (t, i, s, r, n) {
        if ("px" === r || !r) return s;
        if ("auto" === r || !s) return 0;
        var o,
          h,
          l,
          _ = A.test(i),
          u = t,
          c = L.style,
          f = 0 > s;
        if (f && (s = -s), "%" === r && -1 !== i.indexOf("border")) o = s / 100 * (_ ? t.clientWidth : t.clientHeight);else {
          if (c.cssText = "border:0 solid red;position:" + Q(t, "position") + ";line-height:0;", "%" !== r && u.appendChild) c[_ ? "borderLeftWidth" : "borderTopWidth"] = s + r;else {
            if (u = t.parentNode || N.body, h = u._gsCache, l = e.ticker.frame, h && _ && h.time === l) return h.width * s / 100;
            c[_ ? "width" : "height"] = s + r;
          }
          u.appendChild(L), o = parseFloat(L[_ ? "offsetWidth" : "offsetHeight"]), u.removeChild(L), _ && "%" === r && _a.cacheWidths !== !1 && (h = u._gsCache = u._gsCache || {}, h.time = l, h.width = 100 * (o / s)), 0 !== o || n || (o = $(t, i, s, r, !0));
        }
        return f ? -o : o;
      },
      H = B.calculateOffset = function (t, e, i) {
        if ("absolute" !== Q(t, "position", i)) return 0;
        var s = "left" === e ? "Left" : "Top",
          r = Q(t, "margin" + s, i);
        return t["offset" + s] - ($(t, e, parseFloat(r), r.replace(T, "")) || 0);
      },
      K = function K(t, e) {
        var i,
          s,
          r,
          n = {};
        if (e = e || Z(t, null)) {
          if (i = e.length) for (; --i > -1;) r = e[i], (-1 === r.indexOf("-transform") || Pe === r) && (n[r.replace(S, O)] = e.getPropertyValue(r));else for (i in e) (-1 === i.indexOf("Transform") || be === i) && (n[i] = e[i]);
        } else if (e = t.currentStyle || t.style) for (i in e) "string" == typeof i && void 0 === n[i] && (n[i.replace(S, O)] = e[i]);
        return j || (n.opacity = U(t)), s = Ne(t, e, !1), n.rotation = s.rotation, n.skewX = s.skewX, n.scaleX = s.scaleX, n.scaleY = s.scaleY, n.x = s.x, n.y = s.y, Se && (n.z = s.z, n.rotationX = s.rotationX, n.rotationY = s.rotationY, n.scaleZ = s.scaleZ), n.filters && delete n.filters, n;
      },
      J = function J(t, e, i, s, r) {
        var n,
          a,
          o,
          h = {},
          l = t.style;
        for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (n = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" == typeof n || "string" == typeof n) && (h[a] = "auto" !== n || "left" !== a && "top" !== a ? "" !== n && "auto" !== n && "none" !== n || "string" != typeof e[a] || "" === e[a].replace(y, "") ? n : 0 : H(t, a), void 0 !== l[a] && (o = new fe(l, a, l[a], o)));
        if (s) for (a in s) "className" !== a && (h[a] = s[a]);
        return {
          difs: h,
          firstMPT: o
        };
      },
      te = {
        width: ["Left", "Right"],
        height: ["Top", "Bottom"]
      },
      ee = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
      ie = function ie(t, e, i) {
        var s = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
          r = te[e],
          n = r.length;
        for (i = i || Z(t, null); --n > -1;) s -= parseFloat(Q(t, "padding" + r[n], i, !0)) || 0, s -= parseFloat(Q(t, "border" + r[n] + "Width", i, !0)) || 0;
        return s;
      },
      se = function se(t, e) {
        (null == t || "" === t || "auto" === t || "auto auto" === t) && (t = "0 0");
        var i = t.split(" "),
          s = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0],
          r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1];
        return null == r ? r = "center" === s ? "50%" : "0" : "center" === r && (r = "50%"), ("center" === s || isNaN(parseFloat(s)) && -1 === (s + "").indexOf("=")) && (s = "50%"), t = s + " " + r + (i.length > 2 ? " " + i[2] : ""), e && (e.oxp = -1 !== s.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === s.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(s.replace(y, "")), e.oy = parseFloat(r.replace(y, "")), e.v = t), e || t;
      },
      re = function re(t, e) {
        return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e);
      },
      ne = function ne(t, e) {
        return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t);
      },
      ae = function ae(t, e, i, s) {
        var r,
          n,
          a,
          o,
          h,
          l = 1e-6;
        return null == t ? o = e : "number" == typeof t ? o = t : (r = 360, n = t.split("_"), h = "=" === t.charAt(1), a = (h ? parseInt(t.charAt(0) + "1", 10) * parseFloat(n[0].substr(2)) : parseFloat(n[0])) * (-1 === t.indexOf("rad") ? 1 : I) - (h ? 0 : e), n.length && (s && (s[i] = e + a), -1 !== t.indexOf("short") && (a %= r, a !== a % (r / 2) && (a = 0 > a ? a + r : a - r)), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * r) % r - (0 | a / r) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (0 | a / r) * r)), o = e + a), l > o && o > -l && (o = 0), o;
      },
      oe = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        fuchsia: [255, 0, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      },
      he = function he(t, e, i) {
        return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 0 | 255 * (1 > 6 * t ? e + 6 * (i - e) * t : .5 > t ? i : 2 > 3 * t ? e + 6 * (i - e) * (2 / 3 - t) : e) + .5;
      },
      le = _a.parseColor = function (t) {
        var e, i, s, r, n, a;
        return t && "" !== t ? "number" == typeof t ? [t >> 16, 255 & t >> 8, 255 & t] : ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), oe[t] ? oe[t] : "#" === t.charAt(0) ? (4 === t.length && (e = t.charAt(1), i = t.charAt(2), s = t.charAt(3), t = "#" + e + e + i + i + s + s), t = parseInt(t.substr(1), 16), [t >> 16, 255 & t >> 8, 255 & t]) : "hsl" === t.substr(0, 3) ? (t = t.match(d), r = Number(t[0]) % 360 / 360, n = Number(t[1]) / 100, a = Number(t[2]) / 100, i = .5 >= a ? a * (n + 1) : a + n - a * n, e = 2 * a - i, t.length > 3 && (t[3] = Number(t[3])), t[0] = he(r + 1 / 3, e, i), t[1] = he(r, e, i), t[2] = he(r - 1 / 3, e, i), t) : (t = t.match(d) || oe.transparent, t[0] = Number(t[0]), t[1] = Number(t[1]), t[2] = Number(t[2]), t.length > 3 && (t[3] = Number(t[3])), t)) : oe.black;
      },
      _e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
    for (l in oe) _e += "|" + l + "\\b";
    _e = RegExp(_e + ")", "gi");
    var ue = function ue(t, e, i, s) {
        if (null == t) return function (t) {
          return t;
        };
        var r,
          n = e ? (t.match(_e) || [""])[0] : "",
          a = t.split(n).join("").match(v) || [],
          o = t.substr(0, t.indexOf(a[0])),
          h = ")" === t.charAt(t.length - 1) ? ")" : "",
          l = -1 !== t.indexOf(" ") ? " " : ",",
          _ = a.length,
          u = _ > 0 ? a[0].replace(d, "") : "";
        return _ ? r = e ? function (t) {
          var e, c, f, p;
          if ("number" == typeof t) t += u;else if (s && M.test(t)) {
            for (p = t.replace(M, "|").split("|"), f = 0; p.length > f; f++) p[f] = r(p[f]);
            return p.join(",");
          }
          if (e = (t.match(_e) || [n])[0], c = t.split(e).join("").match(v) || [], f = c.length, _ > f--) for (; _ > ++f;) c[f] = i ? c[0 | (f - 1) / 2] : a[f];
          return o + c.join(l) + l + e + h + (-1 !== t.indexOf("inset") ? " inset" : "");
        } : function (t) {
          var e, n, c;
          if ("number" == typeof t) t += u;else if (s && M.test(t)) {
            for (n = t.replace(M, "|").split("|"), c = 0; n.length > c; c++) n[c] = r(n[c]);
            return n.join(",");
          }
          if (e = t.match(v) || [], c = e.length, _ > c--) for (; _ > ++c;) e[c] = i ? e[0 | (c - 1) / 2] : a[c];
          return o + e.join(l) + h;
        } : function (t) {
          return t;
        };
      },
      ce = function ce(t) {
        return t = t.split(","), function (e, i, s, r, n, a, o) {
          var h,
            l = (i + "").split(" ");
          for (o = {}, h = 0; 4 > h; h++) o[t[h]] = l[h] = l[h] || l[(h - 1) / 2 >> 0];
          return r.parse(e, o, n, a);
        };
      },
      fe = (B._setPluginRatio = function (t) {
        this.plugin.setRatio(t);
        for (var e, i, s, r, n = this.data, a = n.proxy, o = n.firstMPT, h = 1e-6; o;) e = a[o.v], o.r ? e = Math.round(e) : h > e && e > -h && (e = 0), o.t[o.p] = e, o = o._next;
        if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t) for (o = n.firstMPT; o;) {
          if (i = o.t, i.type) {
            if (1 === i.type) {
              for (r = i.xs0 + i.s + i.xs1, s = 1; i.l > s; s++) r += i["xn" + s] + i["xs" + (s + 1)];
              i.e = r;
            }
          } else i.e = i.s + i.xs0;
          o = o._next;
        }
      }, function (t, e, i, s, r) {
        this.t = t, this.p = e, this.v = i, this.r = r, s && (s._prev = this, this._next = s);
      }),
      pe = (B._parseToProxy = function (t, e, i, s, r, n) {
        var a,
          o,
          h,
          l,
          _,
          u = s,
          c = {},
          f = {},
          p = i._transform,
          m = F;
        for (i._transform = null, F = e, s = _ = i.parse(t, e, s, r), F = m, n && (i._transform = p, u && (u._prev = null, u._prev && (u._prev._next = null))); s && s !== u;) {
          if (1 >= s.type && (o = s.p, f[o] = s.s + s.c, c[o] = s.s, n || (l = new fe(s, "s", o, l, s.r), s.c = 0), 1 === s.type)) for (a = s.l; --a > 0;) h = "xn" + a, o = s.p + "_" + h, f[o] = s.data[h], c[o] = s[h], n || (l = new fe(s, h, o, l, s.rxp[h]));
          s = s._next;
        }
        return {
          proxy: c,
          end: f,
          firstMPT: l,
          pt: _
        };
      }, B.CSSPropTween = function (t, e, s, r, a, o, h, l, _, u, c) {
        this.t = t, this.p = e, this.s = s, this.c = r, this.n = h || e, t instanceof pe || n.push(this.n), this.r = l, this.type = o || 0, _ && (this.pr = _, i = !0), this.b = void 0 === u ? s : u, this.e = void 0 === c ? s + r : c, a && (this._next = a, a._prev = this);
      }),
      me = function me(t, e, i, s, r, n) {
        var a = new pe(t, e, i, s - i, r, -1, n);
        return a.b = i, a.e = a.xs0 = s, a;
      },
      de = _a.parseComplex = function (t, e, i, s, r, n, a, o, h, l) {
        i = i || n || "", a = new pe(t, e, 0, 0, a, l ? 2 : 1, null, !1, o, i, s), s += "";
        var u,
          c,
          f,
          p,
          m,
          v,
          y,
          T,
          x,
          w,
          b,
          k,
          S = i.split(", ").join(",").split(" "),
          R = s.split(", ").join(",").split(" "),
          O = S.length,
          A = _ !== !1;
        for ((-1 !== s.indexOf(",") || -1 !== i.indexOf(",")) && (S = S.join(" ").replace(M, ", ").split(" "), R = R.join(" ").replace(M, ", ").split(" "), O = S.length), O !== R.length && (S = (n || "").split(" "), O = S.length), a.plugin = h, a.setRatio = l, u = 0; O > u; u++) if (p = S[u], m = R[u], T = parseFloat(p), T || 0 === T) a.appendXtra("", T, re(m, T), m.replace(g, ""), A && -1 !== m.indexOf("px"), !0);else if (r && ("#" === p.charAt(0) || oe[p] || P.test(p))) k = "," === m.charAt(m.length - 1) ? ")," : ")", p = le(p), m = le(m), x = p.length + m.length > 6, x && !j && 0 === m[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[u]).join("transparent")) : (j || (x = !1), a.appendXtra(x ? "rgba(" : "rgb(", p[0], m[0] - p[0], ",", !0, !0).appendXtra("", p[1], m[1] - p[1], ",", !0).appendXtra("", p[2], m[2] - p[2], x ? "," : k, !0), x && (p = 4 > p.length ? 1 : p[3], a.appendXtra("", p, (4 > m.length ? 1 : m[3]) - p, k, !1)));else if (v = p.match(d)) {
          if (y = m.match(g), !y || y.length !== v.length) return a;
          for (f = 0, c = 0; v.length > c; c++) b = v[c], w = p.indexOf(b, f), a.appendXtra(p.substr(f, w - f), Number(b), re(y[c], b), "", A && "px" === p.substr(w + b.length, 2), 0 === c), f = w + b.length;
          a["xs" + a.l] += p.substr(f);
        } else a["xs" + a.l] += a.l ? " " + p : p;
        if (-1 !== s.indexOf("=") && a.data) {
          for (k = a.xs0 + a.data.s, u = 1; a.l > u; u++) k += a["xs" + u] + a.data["xn" + u];
          a.e = k + a["xs" + u];
        }
        return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a;
      },
      ge = 9;
    for (l = pe.prototype, l.l = l.pr = 0; --ge > 0;) l["xn" + ge] = 0, l["xs" + ge] = "";
    l.xs0 = "", l._next = l._prev = l.xfirst = l.data = l.plugin = l.setRatio = l.rxp = null, l.appendXtra = function (t, e, i, s, r, n) {
      var a = this,
        o = a.l;
      return a["xs" + o] += n && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = s || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new pe(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
        s: e + i
      }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + o] += e + (s || ""), a);
    };
    var ve = function ve(t, e) {
        e = e || {}, this.p = e.prefix ? W(t) || t : t, h[t] = h[this.p] = this, this.format = e.formatter || ue(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0;
      },
      ye = B._registerComplexSpecialProp = function (t, e, i) {
        "object" != _typeof(e) && (e = {
          parser: i
        });
        var s,
          r,
          n = t.split(","),
          a = e.defaultValue;
        for (i = i || [a], s = 0; n.length > s; s++) e.prefix = 0 === s && e.prefix, e.defaultValue = i[s] || a, r = new ve(n[s], e);
      },
      Te = function Te(t) {
        if (!h[t]) {
          var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
          ye(t, {
            parser: function parser(t, i, s, r, n, a, l) {
              var _ = o.com.greensock.plugins[e];
              return _ ? (_._cssRegister(), h[s].parse(t, i, s, r, n, a, l)) : (q("Error: " + e + " js file not loaded."), n);
            }
          });
        }
      };
    l = ve.prototype, l.parseComplex = function (t, e, i, s, r, n) {
      var a,
        o,
        h,
        l,
        _,
        u,
        c = this.keyword;
      if (this.multi && (M.test(i) || M.test(e) ? (o = e.replace(M, "|").split("|"), h = i.replace(M, "|").split("|")) : c && (o = [e], h = [i])), h) {
        for (l = h.length > o.length ? h.length : o.length, a = 0; l > a; a++) e = o[a] = o[a] || this.dflt, i = h[a] = h[a] || this.dflt, c && (_ = e.indexOf(c), u = i.indexOf(c), _ !== u && (-1 === u ? o[a] = o[a].split(c).join("") : -1 === _ && (o[a] += " " + c)));
        e = o.join(", "), i = h.join(", ");
      }
      return de(t, this.p, e, i, this.clrs, this.dflt, s, this.pr, r, n);
    }, l.parse = function (t, e, i, s, n, a) {
      return this.parseComplex(t.style, this.format(Q(t, this.p, r, !1, this.dflt)), this.format(e), n, a);
    }, _a.registerSpecialProp = function (t, e, i) {
      ye(t, {
        parser: function parser(t, s, r, n, a, o) {
          var h = new pe(t, r, 0, 0, a, 2, r, !1, i);
          return h.plugin = o, h.setRatio = e(t, s, n._tween, r), h;
        },
        priority: i
      });
    }, _a.useSVGTransformAttr = c || f;
    var xe,
      we = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
      be = W("transform"),
      Pe = V + "transform",
      ke = W("transformOrigin"),
      Se = null !== W("perspective"),
      Re = B.Transform = function () {
        this.perspective = parseFloat(_a.defaultTransformPerspective) || 0, this.force3D = _a.defaultForce3D !== !1 && Se ? _a.defaultForce3D || "auto" : !1;
      },
      Oe = window.SVGElement,
      Ae = function Ae(t, e, i) {
        var s,
          r = N.createElementNS("http://www.w3.org/2000/svg", t),
          n = /([a-z])([A-Z])/g;
        for (s in i) r.setAttributeNS(null, s.replace(n, "$1-$2").toLowerCase(), i[s]);
        return e.appendChild(r), r;
      },
      Ce = N.documentElement,
      De = function () {
        var t,
          e,
          i,
          s = m || /Android/i.test(Y) && !window.chrome;
        return N.createElementNS && !s && (t = Ae("svg", Ce), e = Ae("rect", t, {
          width: 100,
          height: 50,
          x: 100
        }), i = e.getBoundingClientRect().width, e.style[ke] = "50% 50%", e.style[be] = "scaleX(0.5)", s = i === e.getBoundingClientRect().width && !(f && Se), Ce.removeChild(t)), s;
      }(),
      Me = function Me(t, e, i, s, r) {
        var n,
          o,
          h,
          l,
          _,
          u,
          c,
          f,
          p,
          m,
          d,
          g,
          v,
          y,
          T = t._gsTransform,
          x = Fe(t, !0);
        T && (v = T.xOrigin, y = T.yOrigin), (!s || 2 > (n = s.split(" ")).length) && (c = t.getBBox(), e = se(e).split(" "), n = [(-1 !== e[0].indexOf("%") ? parseFloat(e[0]) / 100 * c.width : parseFloat(e[0])) + c.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * c.height : parseFloat(e[1])) + c.y]), i.xOrigin = l = parseFloat(n[0]), i.yOrigin = _ = parseFloat(n[1]), s && x !== Ie && (u = x[0], c = x[1], f = x[2], p = x[3], m = x[4], d = x[5], g = u * p - c * f, o = l * (p / g) + _ * (-f / g) + (f * d - p * m) / g, h = l * (-c / g) + _ * (u / g) - (u * d - c * m) / g, l = i.xOrigin = n[0] = o, _ = i.yOrigin = n[1] = h), T && (r || r !== !1 && _a.defaultSmoothOrigin !== !1 ? (o = l - v, h = _ - y, T.xOffset += o * x[0] + h * x[2] - o, T.yOffset += o * x[1] + h * x[3] - h) : T.xOffset = T.yOffset = 0), t.setAttribute("data-svg-origin", n.join(" "));
      },
      ze = function ze(t) {
        return !!(Oe && "function" == typeof t.getBBox && t.getCTM && (!t.parentNode || t.parentNode.getBBox && t.parentNode.getCTM));
      },
      Ie = [1, 0, 0, 1, 0, 0],
      Fe = function Fe(t, e) {
        var i,
          s,
          r,
          n,
          a,
          o = t._gsTransform || new Re(),
          h = 1e5;
        if (be ? s = Q(t, Pe, null, !0) : t.currentStyle && (s = t.currentStyle.filter.match(C), s = s && 4 === s.length ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), o.x || 0, o.y || 0].join(",") : ""), i = !s || "none" === s || "matrix(1, 0, 0, 1, 0, 0)" === s, (o.svg || t.getBBox && ze(t)) && (i && -1 !== (t.style[be] + "").indexOf("matrix") && (s = t.style[be], i = 0), r = t.getAttribute("transform"), i && r && (-1 !== r.indexOf("matrix") ? (s = r, i = 0) : -1 !== r.indexOf("translate") && (s = "matrix(1,0,0,1," + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", i = 0))), i) return Ie;
        for (r = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], ge = r.length; --ge > -1;) n = Number(r[ge]), r[ge] = (a = n - (n |= 0)) ? (0 | a * h + (0 > a ? -.5 : .5)) / h + n : n;
        return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r;
      },
      Ne = B.getTransform = function (t, i, s, n) {
        if (t._gsTransform && s && !n) return t._gsTransform;
        var o,
          h,
          l,
          _,
          u,
          c,
          f = s ? t._gsTransform || new Re() : new Re(),
          p = 0 > f.scaleX,
          m = 2e-5,
          d = 1e5,
          g = Se ? parseFloat(Q(t, ke, i, !1, "0 0 0").split(" ")[2]) || f.zOrigin || 0 : 0,
          v = parseFloat(_a.defaultTransformPerspective) || 0;
        if (f.svg = !(!t.getBBox || !ze(t)), f.svg && (Me(t, Q(t, ke, r, !1, "50% 50%") + "", f, t.getAttribute("data-svg-origin")), xe = _a.useSVGTransformAttr || De), o = Fe(t), o !== Ie) {
          if (16 === o.length) {
            var y,
              T,
              x,
              w,
              b,
              P = o[0],
              k = o[1],
              S = o[2],
              R = o[3],
              O = o[4],
              A = o[5],
              C = o[6],
              D = o[7],
              M = o[8],
              z = o[9],
              F = o[10],
              N = o[12],
              E = o[13],
              L = o[14],
              X = o[11],
              B = Math.atan2(C, F);
            f.zOrigin && (L = -f.zOrigin, N = M * L - o[12], E = z * L - o[13], L = F * L + f.zOrigin - o[14]), f.rotationX = B * I, B && (w = Math.cos(-B), b = Math.sin(-B), y = O * w + M * b, T = A * w + z * b, x = C * w + F * b, M = O * -b + M * w, z = A * -b + z * w, F = C * -b + F * w, X = D * -b + X * w, O = y, A = T, C = x), B = Math.atan2(M, F), f.rotationY = B * I, B && (w = Math.cos(-B), b = Math.sin(-B), y = P * w - M * b, T = k * w - z * b, x = S * w - F * b, z = k * b + z * w, F = S * b + F * w, X = R * b + X * w, P = y, k = T, S = x), B = Math.atan2(k, P), f.rotation = B * I, B && (w = Math.cos(-B), b = Math.sin(-B), P = P * w + O * b, T = k * w + A * b, A = k * -b + A * w, C = S * -b + C * w, k = T), f.rotationX && Math.abs(f.rotationX) + Math.abs(f.rotation) > 359.9 && (f.rotationX = f.rotation = 0, f.rotationY += 180), f.scaleX = (0 | Math.sqrt(P * P + k * k) * d + .5) / d, f.scaleY = (0 | Math.sqrt(A * A + z * z) * d + .5) / d, f.scaleZ = (0 | Math.sqrt(C * C + F * F) * d + .5) / d, f.skewX = 0, f.perspective = X ? 1 / (0 > X ? -X : X) : 0, f.x = N, f.y = E, f.z = L, f.svg && (f.x -= f.xOrigin - (f.xOrigin * P - f.yOrigin * O), f.y -= f.yOrigin - (f.yOrigin * k - f.xOrigin * A));
          } else if (!(Se && !n && o.length && f.x === o[4] && f.y === o[5] && (f.rotationX || f.rotationY) || void 0 !== f.x && "none" === Q(t, "display", i))) {
            var Y = o.length >= 6,
              j = Y ? o[0] : 1,
              U = o[1] || 0,
              q = o[2] || 0,
              V = Y ? o[3] : 1;
            f.x = o[4] || 0, f.y = o[5] || 0, l = Math.sqrt(j * j + U * U), _ = Math.sqrt(V * V + q * q), u = j || U ? Math.atan2(U, j) * I : f.rotation || 0, c = q || V ? Math.atan2(q, V) * I + u : f.skewX || 0, Math.abs(c) > 90 && 270 > Math.abs(c) && (p ? (l *= -1, c += 0 >= u ? 180 : -180, u += 0 >= u ? 180 : -180) : (_ *= -1, c += 0 >= c ? 180 : -180)), f.scaleX = l, f.scaleY = _, f.rotation = u, f.skewX = c, Se && (f.rotationX = f.rotationY = f.z = 0, f.perspective = v, f.scaleZ = 1), f.svg && (f.x -= f.xOrigin - (f.xOrigin * j + f.yOrigin * q), f.y -= f.yOrigin - (f.xOrigin * U + f.yOrigin * V));
          }
          f.zOrigin = g;
          for (h in f) m > f[h] && f[h] > -m && (f[h] = 0);
        }
        return s && (t._gsTransform = f, f.svg && (xe && t.style[be] ? e.delayedCall(.001, function () {
          Be(t.style, be);
        }) : !xe && t.getAttribute("transform") && e.delayedCall(.001, function () {
          t.removeAttribute("transform");
        }))), f;
      },
      Ee = function Ee(t) {
        var e,
          i,
          s = this.data,
          r = -s.rotation * z,
          n = r + s.skewX * z,
          a = 1e5,
          o = (0 | Math.cos(r) * s.scaleX * a) / a,
          h = (0 | Math.sin(r) * s.scaleX * a) / a,
          l = (0 | Math.sin(n) * -s.scaleY * a) / a,
          _ = (0 | Math.cos(n) * s.scaleY * a) / a,
          u = this.t.style,
          c = this.t.currentStyle;
        if (c) {
          i = h, h = -l, l = -i, e = c.filter, u.filter = "";
          var f,
            p,
            d = this.t.offsetWidth,
            g = this.t.offsetHeight,
            v = "absolute" !== c.position,
            y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + h + ", M21=" + l + ", M22=" + _,
            w = s.x + d * s.xPercent / 100,
            b = s.y + g * s.yPercent / 100;
          if (null != s.ox && (f = (s.oxp ? .01 * d * s.ox : s.ox) - d / 2, p = (s.oyp ? .01 * g * s.oy : s.oy) - g / 2, w += f - (f * o + p * h), b += p - (f * l + p * _)), v ? (f = d / 2, p = g / 2, y += ", Dx=" + (f - (f * o + p * h) + w) + ", Dy=" + (p - (f * l + p * _) + b) + ")") : y += ", sizingMethod='auto expand')", u.filter = -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? e.replace(D, y) : y + " " + e, (0 === t || 1 === t) && 1 === o && 0 === h && 0 === l && 1 === _ && (v && -1 === y.indexOf("Dx=0, Dy=0") || x.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf( true && e.indexOf("Alpha")) && u.removeAttribute("filter")), !v) {
            var P,
              k,
              S,
              R = 8 > m ? 1 : -1;
            for (f = s.ieOffsetX || 0, p = s.ieOffsetY || 0, s.ieOffsetX = Math.round((d - ((0 > o ? -o : o) * d + (0 > h ? -h : h) * g)) / 2 + w), s.ieOffsetY = Math.round((g - ((0 > _ ? -_ : _) * g + (0 > l ? -l : l) * d)) / 2 + b), ge = 0; 4 > ge; ge++) k = ee[ge], P = c[k], i = -1 !== P.indexOf("px") ? parseFloat(P) : $(this.t, k, parseFloat(P), P.replace(T, "")) || 0, S = i !== s[k] ? 2 > ge ? -s.ieOffsetX : -s.ieOffsetY : 2 > ge ? f - s.ieOffsetX : p - s.ieOffsetY, u[k] = (s[k] = Math.round(i - S * (0 === ge || 2 === ge ? 1 : R))) + "px";
          }
        }
      },
      Le = B.set3DTransformRatio = B.setTransformRatio = function (t) {
        var e,
          i,
          s,
          r,
          n,
          a,
          o,
          h,
          l,
          _,
          u,
          c,
          p,
          m,
          d,
          g,
          v,
          y,
          T,
          x,
          w,
          b,
          P,
          k = this.data,
          S = this.t.style,
          R = k.rotation,
          O = k.rotationX,
          A = k.rotationY,
          C = k.scaleX,
          D = k.scaleY,
          M = k.scaleZ,
          I = k.x,
          F = k.y,
          N = k.z,
          E = k.svg,
          L = k.perspective,
          X = k.force3D;
        if (!(((1 !== t && 0 !== t || "auto" !== X || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && X || N || L || A || O) && (!xe || !E) && Se)) return R || k.skewX || E ? (R *= z, b = k.skewX * z, P = 1e5, e = Math.cos(R) * C, r = Math.sin(R) * C, i = Math.sin(R - b) * -D, n = Math.cos(R - b) * D, b && "simple" === k.skewType && (v = Math.tan(b), v = Math.sqrt(1 + v * v), i *= v, n *= v, k.skewY && (e *= v, r *= v)), E && (I += k.xOrigin - (k.xOrigin * e + k.yOrigin * i) + k.xOffset, F += k.yOrigin - (k.xOrigin * r + k.yOrigin * n) + k.yOffset, xe && (k.xPercent || k.yPercent) && (m = this.t.getBBox(), I += .01 * k.xPercent * m.width, F += .01 * k.yPercent * m.height), m = 1e-6, m > I && I > -m && (I = 0), m > F && F > -m && (F = 0)), T = (0 | e * P) / P + "," + (0 | r * P) / P + "," + (0 | i * P) / P + "," + (0 | n * P) / P + "," + I + "," + F + ")", E && xe ? this.t.setAttribute("transform", "matrix(" + T) : S[be] = (k.xPercent || k.yPercent ? "translate(" + k.xPercent + "%," + k.yPercent + "%) matrix(" : "matrix(") + T) : S[be] = (k.xPercent || k.yPercent ? "translate(" + k.xPercent + "%," + k.yPercent + "%) matrix(" : "matrix(") + C + ",0,0," + D + "," + I + "," + F + ")", void 0;
        if (f && (m = 1e-4, m > C && C > -m && (C = M = 2e-5), m > D && D > -m && (D = M = 2e-5), !L || k.z || k.rotationX || k.rotationY || (L = 0)), R || k.skewX) R *= z, d = e = Math.cos(R), g = r = Math.sin(R), k.skewX && (R -= k.skewX * z, d = Math.cos(R), g = Math.sin(R), "simple" === k.skewType && (v = Math.tan(k.skewX * z), v = Math.sqrt(1 + v * v), d *= v, g *= v, k.skewY && (e *= v, r *= v))), i = -g, n = d;else {
          if (!(A || O || 1 !== M || L || E)) return S[be] = (k.xPercent || k.yPercent ? "translate(" + k.xPercent + "%," + k.yPercent + "%) translate3d(" : "translate3d(") + I + "px," + F + "px," + N + "px)" + (1 !== C || 1 !== D ? " scale(" + C + "," + D + ")" : ""), void 0;
          e = n = 1, i = r = 0;
        }
        l = 1, s = a = o = h = _ = u = 0, c = L ? -1 / L : 0, p = k.zOrigin, m = 1e-6, x = ",", w = "0", R = A * z, R && (d = Math.cos(R), g = Math.sin(R), o = -g, _ = c * -g, s = e * g, a = r * g, l = d, c *= d, e *= d, r *= d), R = O * z, R && (d = Math.cos(R), g = Math.sin(R), v = i * d + s * g, y = n * d + a * g, h = l * g, u = c * g, s = i * -g + s * d, a = n * -g + a * d, l *= d, c *= d, i = v, n = y), 1 !== M && (s *= M, a *= M, l *= M, c *= M), 1 !== D && (i *= D, n *= D, h *= D, u *= D), 1 !== C && (e *= C, r *= C, o *= C, _ *= C), (p || E) && (p && (I += s * -p, F += a * -p, N += l * -p + p), E && (I += k.xOrigin - (k.xOrigin * e + k.yOrigin * i) + k.xOffset, F += k.yOrigin - (k.xOrigin * r + k.yOrigin * n) + k.yOffset), m > I && I > -m && (I = w), m > F && F > -m && (F = w), m > N && N > -m && (N = 0)), T = k.xPercent || k.yPercent ? "translate(" + k.xPercent + "%," + k.yPercent + "%) matrix3d(" : "matrix3d(", T += (m > e && e > -m ? w : e) + x + (m > r && r > -m ? w : r) + x + (m > o && o > -m ? w : o), T += x + (m > _ && _ > -m ? w : _) + x + (m > i && i > -m ? w : i) + x + (m > n && n > -m ? w : n), O || A ? (T += x + (m > h && h > -m ? w : h) + x + (m > u && u > -m ? w : u) + x + (m > s && s > -m ? w : s), T += x + (m > a && a > -m ? w : a) + x + (m > l && l > -m ? w : l) + x + (m > c && c > -m ? w : c) + x) : T += ",0,0,0,0,1,0,", T += I + x + F + x + N + x + (L ? 1 + -N / L : 1) + ")", S[be] = T;
      };
    l = Re.prototype, l.x = l.y = l.z = l.skewX = l.skewY = l.rotation = l.rotationX = l.rotationY = l.zOrigin = l.xPercent = l.yPercent = l.xOffset = l.yOffset = 0, l.scaleX = l.scaleY = l.scaleZ = 1, ye("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
      parser: function parser(t, e, i, s, n, o, h) {
        if (s._lastParsedTransform === h) return n;
        s._lastParsedTransform = h;
        var l,
          _,
          u,
          c,
          f,
          p,
          m,
          d,
          g,
          v = t._gsTransform,
          y = s._transform = Ne(t, r, !0, h.parseTransform),
          T = t.style,
          x = 1e-6,
          w = we.length,
          b = h,
          P = {},
          k = "transformOrigin";
        if ("string" == typeof b.transform && be) u = L.style, u[be] = b.transform, u.display = "block", u.position = "absolute", N.body.appendChild(L), l = Ne(L, null, !1), N.body.removeChild(L), null != b.xPercent && (l.xPercent = ne(b.xPercent, y.xPercent)), null != b.yPercent && (l.yPercent = ne(b.yPercent, y.yPercent));else if ("object" == _typeof(b)) {
          if (l = {
            scaleX: ne(null != b.scaleX ? b.scaleX : b.scale, y.scaleX),
            scaleY: ne(null != b.scaleY ? b.scaleY : b.scale, y.scaleY),
            scaleZ: ne(b.scaleZ, y.scaleZ),
            x: ne(b.x, y.x),
            y: ne(b.y, y.y),
            z: ne(b.z, y.z),
            xPercent: ne(b.xPercent, y.xPercent),
            yPercent: ne(b.yPercent, y.yPercent),
            perspective: ne(b.transformPerspective, y.perspective)
          }, m = b.directionalRotation, null != m) if ("object" == _typeof(m)) for (u in m) b[u] = m[u];else b.rotation = m;
          "string" == typeof b.x && -1 !== b.x.indexOf("%") && (l.x = 0, l.xPercent = ne(b.x, y.xPercent)), "string" == typeof b.y && -1 !== b.y.indexOf("%") && (l.y = 0, l.yPercent = ne(b.y, y.yPercent)), l.rotation = ae("rotation" in b ? b.rotation : "shortRotation" in b ? b.shortRotation + "_short" : "rotationZ" in b ? b.rotationZ : y.rotation, y.rotation, "rotation", P), Se && (l.rotationX = ae("rotationX" in b ? b.rotationX : "shortRotationX" in b ? b.shortRotationX + "_short" : y.rotationX || 0, y.rotationX, "rotationX", P), l.rotationY = ae("rotationY" in b ? b.rotationY : "shortRotationY" in b ? b.shortRotationY + "_short" : y.rotationY || 0, y.rotationY, "rotationY", P)), l.skewX = null == b.skewX ? y.skewX : ae(b.skewX, y.skewX), l.skewY = null == b.skewY ? y.skewY : ae(b.skewY, y.skewY), (_ = l.skewY - y.skewY) && (l.skewX += _, l.rotation += _);
        }
        for (Se && null != b.force3D && (y.force3D = b.force3D, p = !0), y.skewType = b.skewType || y.skewType || _a.defaultSkewType, f = y.force3D || y.z || y.rotationX || y.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, f || null == b.scale || (l.scaleZ = 1); --w > -1;) i = we[w], c = l[i] - y[i], (c > x || -x > c || null != b[i] || null != F[i]) && (p = !0, n = new pe(y, i, y[i], c, n), i in P && (n.e = P[i]), n.xs0 = 0, n.plugin = o, s._overwriteProps.push(n.n));
        return c = b.transformOrigin, y.svg && (c || b.svgOrigin) && (d = y.xOffset, g = y.yOffset, Me(t, se(c), l, b.svgOrigin, b.smoothOrigin), n = me(y, "xOrigin", (v ? y : l).xOrigin, l.xOrigin, n, k), n = me(y, "yOrigin", (v ? y : l).yOrigin, l.yOrigin, n, k), (d !== y.xOffset || g !== y.yOffset) && (n = me(y, "xOffset", v ? d : y.xOffset, y.xOffset, n, k), n = me(y, "yOffset", v ? g : y.yOffset, y.yOffset, n, k)), c = xe ? null : "0px 0px"), (c || Se && f && y.zOrigin) && (be ? (p = !0, i = ke, c = (c || Q(t, i, r, !1, "50% 50%")) + "", n = new pe(T, i, 0, 0, n, -1, k), n.b = T[i], n.plugin = o, Se ? (u = y.zOrigin, c = c.split(" "), y.zOrigin = (c.length > 2 && (0 === u || "0px" !== c[2]) ? parseFloat(c[2]) : u) || 0, n.xs0 = n.e = c[0] + " " + (c[1] || "50%") + " 0px", n = new pe(y, "zOrigin", 0, 0, n, -1, n.n), n.b = u, n.xs0 = n.e = y.zOrigin) : n.xs0 = n.e = c) : se(c + "", y)), p && (s._transformType = y.svg && xe || !f && 3 !== this._transformType ? 2 : 3), n;
      },
      prefix: !0
    }), ye("boxShadow", {
      defaultValue: "0px 0px 0px 0px #999",
      prefix: !0,
      color: !0,
      multi: !0,
      keyword: "inset"
    }), ye("borderRadius", {
      defaultValue: "0px",
      parser: function parser(t, e, i, n, a) {
        e = this.format(e);
        var o,
          h,
          l,
          _,
          u,
          c,
          f,
          p,
          m,
          d,
          g,
          v,
          y,
          T,
          x,
          w,
          b = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
          P = t.style;
        for (m = parseFloat(t.offsetWidth), d = parseFloat(t.offsetHeight), o = e.split(" "), h = 0; b.length > h; h++) this.p.indexOf("border") && (b[h] = W(b[h])), u = _ = Q(t, b[h], r, !1, "0px"), -1 !== u.indexOf(" ") && (_ = u.split(" "), u = _[0], _ = _[1]), c = l = o[h], f = parseFloat(u), v = u.substr((f + "").length), y = "=" === c.charAt(1), y ? (p = parseInt(c.charAt(0) + "1", 10), c = c.substr(2), p *= parseFloat(c), g = c.substr((p + "").length - (0 > p ? 1 : 0)) || "") : (p = parseFloat(c), g = c.substr((p + "").length)), "" === g && (g = s[i] || v), g !== v && (T = $(t, "borderLeft", f, v), x = $(t, "borderTop", f, v), "%" === g ? (u = 100 * (T / m) + "%", _ = 100 * (x / d) + "%") : "em" === g ? (w = $(t, "borderLeft", 1, "em"), u = T / w + "em", _ = x / w + "em") : (u = T + "px", _ = x + "px"), y && (c = parseFloat(u) + p + g, l = parseFloat(_) + p + g)), a = de(P, b[h], u + " " + _, c + " " + l, !1, "0px", a);
        return a;
      },
      prefix: !0,
      formatter: ue("0px 0px 0px 0px", !1, !0)
    }), ye("backgroundPosition", {
      defaultValue: "0 0",
      parser: function parser(t, e, i, s, n, a) {
        var o,
          h,
          l,
          _,
          u,
          c,
          f = "background-position",
          p = r || Z(t, null),
          d = this.format((p ? m ? p.getPropertyValue(f + "-x") + " " + p.getPropertyValue(f + "-y") : p.getPropertyValue(f) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
          g = this.format(e);
        if (-1 !== d.indexOf("%") != (-1 !== g.indexOf("%")) && (c = Q(t, "backgroundImage").replace(R, ""), c && "none" !== c)) {
          for (o = d.split(" "), h = g.split(" "), X.setAttribute("src", c), l = 2; --l > -1;) d = o[l], _ = -1 !== d.indexOf("%"), _ !== (-1 !== h[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - X.width : t.offsetHeight - X.height, o[l] = _ ? parseFloat(d) / 100 * u + "px" : 100 * (parseFloat(d) / u) + "%");
          d = o.join(" ");
        }
        return this.parseComplex(t.style, d, g, n, a);
      },
      formatter: se
    }), ye("backgroundSize", {
      defaultValue: "0 0",
      formatter: se
    }), ye("perspective", {
      defaultValue: "0px",
      prefix: !0
    }), ye("perspectiveOrigin", {
      defaultValue: "50% 50%",
      prefix: !0
    }), ye("transformStyle", {
      prefix: !0
    }), ye("backfaceVisibility", {
      prefix: !0
    }), ye("userSelect", {
      prefix: !0
    }), ye("margin", {
      parser: ce("marginTop,marginRight,marginBottom,marginLeft")
    }), ye("padding", {
      parser: ce("paddingTop,paddingRight,paddingBottom,paddingLeft")
    }), ye("clip", {
      defaultValue: "rect(0px,0px,0px,0px)",
      parser: function parser(t, e, i, s, n, a) {
        var o, h, l;
        return 9 > m ? (h = t.currentStyle, l = 8 > m ? " " : ",", o = "rect(" + h.clipTop + l + h.clipRight + l + h.clipBottom + l + h.clipLeft + ")", e = this.format(e).split(",").join(l)) : (o = this.format(Q(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, n, a);
      }
    }), ye("textShadow", {
      defaultValue: "0px 0px 0px #999",
      color: !0,
      multi: !0
    }), ye("autoRound,strictUnits", {
      parser: function parser(t, e, i, s, r) {
        return r;
      }
    }), ye("border", {
      defaultValue: "0px solid #000",
      parser: function parser(t, e, i, s, n, a) {
        return this.parseComplex(t.style, this.format(Q(t, "borderTopWidth", r, !1, "0px") + " " + Q(t, "borderTopStyle", r, !1, "solid") + " " + Q(t, "borderTopColor", r, !1, "#000")), this.format(e), n, a);
      },
      color: !0,
      formatter: function formatter(t) {
        var e = t.split(" ");
        return e[0] + " " + (e[1] || "solid") + " " + (t.match(_e) || ["#000"])[0];
      }
    }), ye("borderWidth", {
      parser: ce("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
    }), ye("float,cssFloat,styleFloat", {
      parser: function parser(t, e, i, s, r) {
        var n = t.style,
          a = "cssFloat" in n ? "cssFloat" : "styleFloat";
        return new pe(n, a, 0, 0, r, -1, i, !1, 0, n[a], e);
      }
    });
    var Xe = function Xe(t) {
      var e,
        i = this.t,
        s = i.filter || Q(this.data, "filter") || "",
        r = 0 | this.s + this.c * t;
      100 === r && (-1 === s.indexOf("atrix(") && -1 === s.indexOf("radient(") && -1 === s.indexOf("oader(") ? (i.removeAttribute("filter"), e = !Q(this.data, "filter")) : (i.filter = s.replace(b, ""), e = !0)), e || (this.xn1 && (i.filter = s = s || "alpha(opacity=" + r + ")"), -1 === s.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = s + " alpha(opacity=" + r + ")") : i.filter = s.replace(x, "opacity=" + r));
    };
    ye("opacity,alpha,autoAlpha", {
      defaultValue: "1",
      parser: function parser(t, e, i, s, n, a) {
        var o = parseFloat(Q(t, "opacity", r, !1, "1")),
          h = t.style,
          l = "autoAlpha" === i;
        return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + o), l && 1 === o && "hidden" === Q(t, "visibility", r) && 0 !== e && (o = 0), j ? n = new pe(h, "opacity", o, e - o, n) : (n = new pe(h, "opacity", 100 * o, 100 * (e - o), n), n.xn1 = l ? 1 : 0, h.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = t, n.plugin = a, n.setRatio = Xe), l && (n = new pe(h, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), n.xs0 = "inherit", s._overwriteProps.push(n.n), s._overwriteProps.push(i)), n;
      }
    });
    var Be = function Be(t, e) {
        e && (t.removeProperty ? (("ms" === e.substr(0, 2) || "webkit" === e.substr(0, 6)) && (e = "-" + e), t.removeProperty(e.replace(k, "-$1").toLowerCase())) : t.removeAttribute(e));
      },
      Ye = function Ye(t) {
        if (this.t._gsClassPT = this, 1 === t || 0 === t) {
          this.t.setAttribute("class", 0 === t ? this.b : this.e);
          for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Be(i, e.p), e = e._next;
          1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null);
        } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e);
      };
    ye("className", {
      parser: function parser(t, e, s, n, a, o, h) {
        var l,
          _,
          u,
          c,
          f,
          p = t.getAttribute("class") || "",
          m = t.style.cssText;
        if (a = n._classNamePT = new pe(t, s, 0, 0, a, 2), a.setRatio = Ye, a.pr = -11, i = !0, a.b = p, _ = K(t, r), u = t._gsClassPT) {
          for (c = {}, f = u.data; f;) c[f.p] = 1, f = f._next;
          u.setRatio(1);
        }
        return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : p.replace(RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", a.e), l = J(t, _, K(t), h, c), t.setAttribute("class", p), a.data = l.firstMPT, t.style.cssText = m, a = a.xfirst = n.parse(t, l.difs, a, o);
      }
    });
    var je = function je(t) {
      if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
        var e,
          i,
          s,
          r,
          n,
          a = this.t.style,
          o = h.transform.parse;
        if ("all" === this.e) a.cssText = "", r = !0;else for (e = this.e.split(" ").join("").split(","), s = e.length; --s > -1;) i = e[s], h[i] && (h[i].parse === o ? r = !0 : i = "transformOrigin" === i ? ke : h[i].p), Be(a, i);
        r && (Be(a, be), n = this.t._gsTransform, n && (n.svg && this.t.removeAttribute("data-svg-origin"), delete this.t._gsTransform));
      }
    };
    for (ye("clearProps", {
      parser: function parser(t, e, s, r, n) {
        return n = new pe(t, s, 0, 0, n, 2), n.setRatio = je, n.e = e, n.pr = -10, n.data = r._tween, i = !0, n;
      }
    }), l = "bezier,throwProps,physicsProps,physics2D".split(","), ge = l.length; ge--;) Te(l[ge]);
    l = _a.prototype, l._firstPT = l._lastParsedTransform = l._transform = null, l._onInitTween = function (t, e, o) {
      if (!t.nodeType) return !1;
      this._target = t, this._tween = o, this._vars = e, _ = e.autoRound, i = !1, s = e.suffixMap || _a.suffixMap, r = Z(t, ""), n = this._overwriteProps;
      var l,
        f,
        m,
        d,
        g,
        v,
        y,
        T,
        x,
        b = t.style;
      if (u && "" === b.zIndex && (l = Q(t, "zIndex", r), ("auto" === l || "" === l) && this._addLazySet(b, "zIndex", 0)), "string" == typeof e && (d = b.cssText, l = K(t, r), b.cssText = d + ";" + e, l = J(t, l, K(t)).difs, !j && w.test(e) && (l.opacity = parseFloat(RegExp.$1)), e = l, b.cssText = d), this._firstPT = f = e.className ? h.className.parse(t, e.className, "className", this, null, null, e) : this.parse(t, e, null), this._transformType) {
        for (x = 3 === this._transformType, be ? c && (u = !0, "" === b.zIndex && (y = Q(t, "zIndex", r), ("auto" === y || "" === y) && this._addLazySet(b, "zIndex", 0)), p && this._addLazySet(b, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (x ? "visible" : "hidden"))) : b.zoom = 1, m = f; m && m._next;) m = m._next;
        T = new pe(t, "transform", 0, 0, null, 2), this._linkCSSP(T, null, m), T.setRatio = be ? Le : Ee, T.data = this._transform || Ne(t, r, !0), T.tween = o, T.pr = -1, n.pop();
      }
      if (i) {
        for (; f;) {
          for (v = f._next, m = d; m && m.pr > f.pr;) m = m._next;
          (f._prev = m ? m._prev : g) ? f._prev._next = f : d = f, (f._next = m) ? m._prev = f : g = f, f = v;
        }
        this._firstPT = d;
      }
      return !0;
    }, l.parse = function (t, e, i, n) {
      var a,
        o,
        l,
        u,
        c,
        f,
        p,
        m,
        d,
        g,
        v = t.style;
      for (a in e) f = e[a], o = h[a], o ? i = o.parse(t, f, a, this, i, n, e) : (c = Q(t, a, r) + "", d = "string" == typeof f, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || d && P.test(f) ? (d || (f = le(f), f = (f.length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"), i = de(v, a, c, f, !0, "transparent", i, 0, n)) : !d || -1 === f.indexOf(" ") && -1 === f.indexOf(",") ? (l = parseFloat(c), p = l || 0 === l ? c.substr((l + "").length) : "", ("" === c || "auto" === c) && ("width" === a || "height" === a ? (l = ie(t, a, r), p = "px") : "left" === a || "top" === a ? (l = H(t, a, r), p = "px") : (l = "opacity" !== a ? 0 : 1, p = "")), g = d && "=" === f.charAt(1), g ? (u = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), u *= parseFloat(f), m = f.replace(T, "")) : (u = parseFloat(f), m = d ? f.replace(T, "") : ""), "" === m && (m = a in s ? s[a] : p), f = u || 0 === u ? (g ? u + l : u) + m : e[a], p !== m && "" !== m && (u || 0 === u) && l && (l = $(t, a, l, p), "%" === m ? (l /= $(t, a, 100, "%") / 100, e.strictUnits !== !0 && (c = l + "%")) : "em" === m ? l /= $(t, a, 1, "em") : "px" !== m && (u = $(t, a, u, m), m = "px"), g && (u || 0 === u) && (f = u + l + m)), g && (u += l), !l && 0 !== l || !u && 0 !== u ? void 0 !== v[a] && (f || "NaN" != f + "" && null != f) ? (i = new pe(v, a, u || l || 0, 0, i, -1, a, !1, 0, c, f), i.xs0 = "none" !== f || "display" !== a && -1 === a.indexOf("Style") ? f : c) : q("invalid " + a + " tween value: " + e[a]) : (i = new pe(v, a, l, u - l, i, 0, a, _ !== !1 && ("px" === m || "zIndex" === a), 0, c, f), i.xs0 = m)) : i = de(v, a, c, f, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n);
      return i;
    }, l.setRatio = function (t) {
      var e,
        i,
        s,
        r = this._firstPT,
        n = 1e-6;
      if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time) {
        if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (; r;) {
          if (e = r.c * t + r.s, r.r ? e = Math.round(e) : n > e && e > -n && (e = 0), r.type) {
            if (1 === r.type) {
              if (s = r.l, 2 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;else if (3 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;else if (4 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;else if (5 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;else {
                for (i = r.xs0 + e + r.xs1, s = 1; r.l > s; s++) i += r["xn" + s] + r["xs" + (s + 1)];
                r.t[r.p] = i;
              }
            } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
          } else r.t[r.p] = e + r.xs0;
          r = r._next;
        } else for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
      } else for (; r;) {
        if (2 !== r.type) {
          if (r.r && -1 !== r.type) {
            if (e = Math.round(r.s + r.c), r.type) {
              if (1 === r.type) {
                for (s = r.l, i = r.xs0 + e + r.xs1, s = 1; r.l > s; s++) i += r["xn" + s] + r["xs" + (s + 1)];
                r.t[r.p] = i;
              }
            } else r.t[r.p] = e + r.xs0;
          } else r.t[r.p] = r.e;
        } else r.setRatio(t);
        r = r._next;
      }
    }, l._enableTransforms = function (t) {
      this._transform = this._transform || Ne(this._target, r, !0), this._transformType = this._transform.svg && xe || !t && 3 !== this._transformType ? 2 : 3;
    };
    var Ue = function Ue() {
      this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0);
    };
    l._addLazySet = function (t, e, i) {
      var s = this._firstPT = new pe(t, e, 0, 0, this._firstPT, 2);
      s.e = i, s.setRatio = Ue, s.data = this;
    }, l._linkCSSP = function (t, e, i, s) {
      return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, s = !0), i ? i._next = t : s || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t;
    }, l._kill = function (e) {
      var i,
        s,
        r,
        n = e;
      if (e.autoAlpha || e.alpha) {
        n = {};
        for (s in e) n[s] = e[s];
        n.opacity = 1, n.autoAlpha && (n.visibility = 1);
      }
      return e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), t.prototype._kill.call(this, n);
    };
    var _qe = function qe(t, e, i) {
      var s, r, n, a;
      if (t.slice) for (r = t.length; --r > -1;) _qe(t[r], e, i);else for (s = t.childNodes, r = s.length; --r > -1;) n = s[r], a = n.type, n.style && (e.push(K(n)), i && i.push(n)), 1 !== a && 9 !== a && 11 !== a || !n.childNodes.length || _qe(n, e, i);
    };
    return _a.cascadeTo = function (t, i, s) {
      var r,
        n,
        a,
        o,
        h = e.to(t, i, s),
        l = [h],
        _ = [],
        u = [],
        c = [],
        f = e._internals.reservedProps;
      for (t = h._targets || h.target, _qe(t, _, c), h.render(i, !0, !0), _qe(t, u), h.render(0, !0, !0), h._enabled(!0), r = c.length; --r > -1;) if (n = J(c[r], _[r], u[r]), n.firstMPT) {
        n = n.difs;
        for (a in s) f[a] && (n[a] = s[a]);
        o = {};
        for (a in n) o[a] = _[r][a];
        l.push(e.fromTo(c[r], i, o, n));
      }
      return l;
    }, t.activate([_a]), _a;
  }, !0), function () {
    var t = _gsScope._gsDefine.plugin({
        propName: "roundProps",
        priority: -1,
        API: 2,
        init: function init(t, e, i) {
          return this._tween = i, !0;
        }
      }),
      e = t.prototype;
    e._onInitAllProps = function () {
      for (var t, e, i, s = this._tween, r = s.vars.roundProps instanceof Array ? s.vars.roundProps : s.vars.roundProps.split(","), n = r.length, a = {}, o = s._propLookup.roundProps; --n > -1;) a[r[n]] = 1;
      for (n = r.length; --n > -1;) for (t = r[n], e = s._firstPT; e;) i = e._next, e.pg ? e.t._roundProps(a, !0) : e.n === t && (this._add(e.t, t, e.s, e.c), i && (i._prev = e._prev), e._prev ? e._prev._next = i : s._firstPT === e && (s._firstPT = i), e._next = e._prev = null, s._propLookup[t] = o), e = i;
      return !1;
    }, e._add = function (t, e, i, s) {
      this._addTween(t, e, i, i + s, e, !0), this._overwriteProps.push(e);
    };
  }(), function () {
    var t = /(?:\d|\-|\+|=|#|\.)*/g,
      e = /[A-Za-z%]/g;
    _gsScope._gsDefine.plugin({
      propName: "attr",
      API: 2,
      version: "0.4.0",
      init: function init(i, s) {
        var r, n, a, o, h;
        if ("function" != typeof i.setAttribute) return !1;
        this._target = i, this._proxy = {}, this._start = {}, this._end = {}, this._suffix = {};
        for (r in s) this._start[r] = this._proxy[r] = n = i.getAttribute(r) + "", this._end[r] = a = s[r] + "", this._suffix[r] = o = e.test(a) ? a.replace(t, "") : e.test(n) ? n.replace(t, "") : "", o && (h = a.indexOf(o), -1 !== h && (a = a.substr(0, h))), this._addTween(this._proxy, r, parseFloat(n), a, r) || (this._suffix[r] = ""), "=" === a.charAt(1) && (this._end[r] = this._firstPT.s + this._firstPT.c + o), this._overwriteProps.push(r);
        return !0;
      },
      set: function set(t) {
        this._super.setRatio.call(this, t);
        for (var e, i = this._overwriteProps, s = i.length, r = 1 === t ? this._end : t ? this._proxy : this._start, n = r === this._proxy; --s > -1;) e = i[s], this._target.setAttribute(e, r[e] + (n ? this._suffix[e] : ""));
      }
    });
  }(), _gsScope._gsDefine.plugin({
    propName: "directionalRotation",
    version: "0.2.1",
    API: 2,
    init: function init(t, e) {
      "object" != _typeof(e) && (e = {
        rotation: e
      }), this.finals = {};
      var i,
        s,
        r,
        n,
        a,
        o,
        h = e.useRadians === !0 ? 2 * Math.PI : 360,
        l = 1e-6;
      for (i in e) "useRadians" !== i && (o = (e[i] + "").split("_"), s = o[0], r = parseFloat("function" != typeof t[i] ? t[i] : t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]()), n = this.finals[i] = "string" == typeof s && "=" === s.charAt(1) ? r + parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2)) : Number(s) || 0, a = n - r, o.length && (s = o.join("_"), -1 !== s.indexOf("short") && (a %= h, a !== a % (h / 2) && (a = 0 > a ? a + h : a - h)), -1 !== s.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * h) % h - (0 | a / h) * h : -1 !== s.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * h) % h - (0 | a / h) * h)), (a > l || -l > a) && (this._addTween(t, i, r, r + a, i), this._overwriteProps.push(i)));
      return !0;
    },
    set: function set(t) {
      var e;
      if (1 !== t) this._super.setRatio.call(this, t);else for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next;
    }
  })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function (t) {
    var e,
      i,
      s,
      r = _gsScope.GreenSockGlobals || _gsScope,
      n = r.com.greensock,
      a = 2 * Math.PI,
      o = Math.PI / 2,
      h = n._class,
      l = function l(e, i) {
        var s = h("easing." + e, function () {}, !0),
          r = s.prototype = new t();
        return r.constructor = s, r.getRatio = i, s;
      },
      _ = t.register || function () {},
      u = function u(t, e, i, s) {
        var r = h("easing." + t, {
          easeOut: new e(),
          easeIn: new i(),
          easeInOut: new s()
        }, !0);
        return _(r, t), r;
      },
      c = function c(t, e, i) {
        this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t);
      },
      f = function f(e, i) {
        var s = h("easing." + e, function (t) {
            this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1;
          }, !0),
          r = s.prototype = new t();
        return r.constructor = s, r.getRatio = i, r.config = function (t) {
          return new s(t);
        }, s;
      },
      p = u("Back", f("BackOut", function (t) {
        return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1;
      }), f("BackIn", function (t) {
        return t * t * ((this._p1 + 1) * t - this._p1);
      }), f("BackInOut", function (t) {
        return 1 > (t *= 2) ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2);
      })),
      m = h("easing.SlowMo", function (t, e, i) {
        e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0;
      }, !0),
      d = m.prototype = new t();
    return d.constructor = m, d.getRatio = function (t) {
      var e = t + (.5 - t) * this._p;
      return this._p1 > t ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e;
    }, m.ease = new m(.7, .7), d.config = m.config = function (t, e, i) {
      return new m(t, e, i);
    }, e = h("easing.SteppedEase", function (t) {
      t = t || 1, this._p1 = 1 / t, this._p2 = t + 1;
    }, !0), d = e.prototype = new t(), d.constructor = e, d.getRatio = function (t) {
      return 0 > t ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1;
    }, d.config = e.config = function (t) {
      return new e(t);
    }, i = h("easing.RoughEase", function (e) {
      e = e || {};
      for (var i, s, r, n, a, o, h = e.taper || "none", l = [], _ = 0, u = 0 | (e.points || 20), f = u, p = e.randomize !== !1, m = e.clamp === !0, d = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --f > -1;) i = p ? Math.random() : 1 / u * f, s = d ? d.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (n = 1 - i, r = n * n * g) : "in" === h ? r = i * i * g : .5 > i ? (n = 2 * i, r = .5 * n * n * g) : (n = 2 * (1 - i), r = .5 * n * n * g), p ? s += Math.random() * r - .5 * r : f % 2 ? s += .5 * r : s -= .5 * r, m && (s > 1 ? s = 1 : 0 > s && (s = 0)), l[_++] = {
        x: i,
        y: s
      };
      for (l.sort(function (t, e) {
        return t.x - e.x;
      }), o = new c(1, 1, null), f = u; --f > -1;) a = l[f], o = new c(a.x, a.y, o);
      this._prev = new c(0, 0, 0 !== o.t ? o : o.next);
    }, !0), d = i.prototype = new t(), d.constructor = i, d.getRatio = function (t) {
      var e = this._prev;
      if (t > e.t) {
        for (; e.next && t >= e.t;) e = e.next;
        e = e.prev;
      } else for (; e.prev && e.t >= t;) e = e.prev;
      return this._prev = e, e.v + (t - e.t) / e.gap * e.c;
    }, d.config = function (t) {
      return new i(t);
    }, i.ease = new i(), u("Bounce", l("BounceOut", function (t) {
      return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }), l("BounceIn", function (t) {
      return 1 / 2.75 > (t = 1 - t) ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375);
    }), l("BounceInOut", function (t) {
      var e = .5 > t;
      return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5;
    })), u("Circ", l("CircOut", function (t) {
      return Math.sqrt(1 - (t -= 1) * t);
    }), l("CircIn", function (t) {
      return -(Math.sqrt(1 - t * t) - 1);
    }), l("CircInOut", function (t) {
      return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    })), s = function s(e, i, _s) {
      var r = h("easing." + e, function (t, e) {
          this._p1 = t >= 1 ? t : 1, this._p2 = (e || _s) / (1 > t ? t : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2;
        }, !0),
        n = r.prototype = new t();
      return n.constructor = r, n.getRatio = i, n.config = function (t, e) {
        return new r(t, e);
      }, r;
    }, u("Elastic", s("ElasticOut", function (t) {
      return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1;
    }, .3), s("ElasticIn", function (t) {
      return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2));
    }, .3), s("ElasticInOut", function (t) {
      return 1 > (t *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) : .5 * this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) + 1;
    }, .45)), u("Expo", l("ExpoOut", function (t) {
      return 1 - Math.pow(2, -10 * t);
    }), l("ExpoIn", function (t) {
      return Math.pow(2, 10 * (t - 1)) - .001;
    }), l("ExpoInOut", function (t) {
      return 1 > (t *= 2) ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)));
    })), u("Sine", l("SineOut", function (t) {
      return Math.sin(t * o);
    }), l("SineIn", function (t) {
      return -Math.cos(t * o) + 1;
    }), l("SineInOut", function (t) {
      return -.5 * (Math.cos(Math.PI * t) - 1);
    })), h("easing.EaseLookup", {
      find: function find(e) {
        return t.map[e];
      }
    }, !0), _(r.SlowMo, "SlowMo", "ease,"), _(i, "RoughEase", "ease,"), _(e, "SteppedEase", "ease,"), p;
  }, !0);
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), function (t, e) {
  "use strict";

  var i = t.GreenSockGlobals = t.GreenSockGlobals || t;
  if (!i.TweenLite) {
    var s,
      r,
      n,
      a,
      o,
      h = function h(t) {
        var e,
          s = t.split("."),
          r = i;
        for (e = 0; s.length > e; e++) r[s[e]] = r = r[s[e]] || {};
        return r;
      },
      l = h("com.greensock"),
      _ = 1e-10,
      u = function u(t) {
        var e,
          i = [],
          s = t.length;
        for (e = 0; e !== s; i.push(t[e++]));
        return i;
      },
      c = function c() {},
      f = function () {
        var t = Object.prototype.toString,
          e = t.call([]);
        return function (i) {
          return null != i && (i instanceof Array || "object" == _typeof(i) && !!i.push && t.call(i) === e);
        };
      }(),
      p = {},
      _m = function m(s, r, n, a) {
        this.sc = p[s] ? p[s].sc : [], p[s] = this, this.gsClass = null, this.func = n;
        var o = [];
        this.check = function (l) {
          for (var _, u, c, f, d = r.length, g = d; --d > -1;) (_ = p[r[d]] || new _m(r[d], [])).gsClass ? (o[d] = _.gsClass, g--) : l && _.sc.push(this);
          if (0 === g && n) for (u = ("com.greensock." + s).split("."), c = u.pop(), f = h(u.join("."))[c] = this.gsClass = n.apply(n, o), a && (i[c] = f,  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return f;
          }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0), d = 0; this.sc.length > d; d++) this.sc[d].check();
        }, this.check(!0);
      },
      d = t._gsDefine = function (t, e, i, s) {
        return new _m(t, e, i, s);
      },
      g = l._class = function (t, e, i) {
        return e = e || function () {}, d(t, [], function () {
          return e;
        }, i), e;
      };
    d.globals = i;
    var v = [0, 0, 1, 1],
      y = [],
      T = g("easing.Ease", function (t, e, i, s) {
        this._func = t, this._type = i || 0, this._power = s || 0, this._params = e ? v.concat(e) : v;
      }, !0),
      x = T.map = {},
      w = T.register = function (t, e, i, s) {
        for (var r, n, a, o, h = e.split(","), _ = h.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --_ > -1;) for (n = h[_], r = s ? g("easing." + n, null, !0) : l.easing[n] || {}, a = u.length; --a > -1;) o = u[a], x[n + "." + o] = x[o + n] = r[o] = t.getRatio ? t : t[o] || new t();
      };
    for (n = T.prototype, n._calcEnd = !1, n.getRatio = function (t) {
      if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
      var e = this._type,
        i = this._power,
        s = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
      return 1 === i ? s *= s : 2 === i ? s *= s * s : 3 === i ? s *= s * s * s : 4 === i && (s *= s * s * s * s), 1 === e ? 1 - s : 2 === e ? s : .5 > t ? s / 2 : 1 - s / 2;
    }, s = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], r = s.length; --r > -1;) n = s[r] + ",Power" + r, w(new T(null, null, 1, r), n, "easeOut", !0), w(new T(null, null, 2, r), n, "easeIn" + (0 === r ? ",easeNone" : "")), w(new T(null, null, 3, r), n, "easeInOut");
    x.linear = l.easing.Linear.easeIn, x.swing = l.easing.Quad.easeInOut;
    var b = g("events.EventDispatcher", function (t) {
      this._listeners = {}, this._eventTarget = t || this;
    });
    n = b.prototype, n.addEventListener = function (t, e, i, s, r) {
      r = r || 0;
      var n,
        h,
        l = this._listeners[t],
        _ = 0;
      for (null == l && (this._listeners[t] = l = []), h = l.length; --h > -1;) n = l[h], n.c === e && n.s === i ? l.splice(h, 1) : 0 === _ && r > n.pr && (_ = h + 1);
      l.splice(_, 0, {
        c: e,
        s: i,
        up: s,
        pr: r
      }), this !== a || o || a.wake();
    }, n.removeEventListener = function (t, e) {
      var i,
        s = this._listeners[t];
      if (s) for (i = s.length; --i > -1;) if (s[i].c === e) return s.splice(i, 1), void 0;
    }, n.dispatchEvent = function (t) {
      var e,
        i,
        s,
        r = this._listeners[t];
      if (r) for (e = r.length, i = this._eventTarget; --e > -1;) s = r[e], s && (s.up ? s.c.call(s.s || i, {
        type: t,
        target: i
      }) : s.c.call(s.s || i));
    };
    var P = t.requestAnimationFrame,
      k = t.cancelAnimationFrame,
      S = Date.now || function () {
        return new Date().getTime();
      },
      R = S();
    for (s = ["ms", "moz", "webkit", "o"], r = s.length; --r > -1 && !P;) P = t[s[r] + "RequestAnimationFrame"], k = t[s[r] + "CancelAnimationFrame"] || t[s[r] + "CancelRequestAnimationFrame"];
    g("Ticker", function (t, e) {
      var i,
        s,
        r,
        n,
        h,
        l = this,
        u = S(),
        f = e !== !1 && P,
        p = 500,
        m = 33,
        d = "tick",
        _g = function g(t) {
          var e,
            a,
            o = S() - R;
          o > p && (u += o - m), R += o, l.time = (R - u) / 1e3, e = l.time - h, (!i || e > 0 || t === !0) && (l.frame++, h += e + (e >= n ? .004 : n - e), a = !0), t !== !0 && (r = s(_g)), a && l.dispatchEvent(d);
        };
      b.call(l), l.time = l.frame = 0, l.tick = function () {
        _g(!0);
      }, l.lagSmoothing = function (t, e) {
        p = t || 1 / _, m = Math.min(e, p, 0);
      }, l.sleep = function () {
        null != r && (f && k ? k(r) : clearTimeout(r), s = c, r = null, l === a && (o = !1));
      }, l.wake = function () {
        null !== r ? l.sleep() : l.frame > 10 && (R = S() - p + 5), s = 0 === i ? c : f && P ? P : function (t) {
          return setTimeout(t, 0 | 1e3 * (h - l.time) + 1);
        }, l === a && (o = !0), _g(2);
      }, l.fps = function (t) {
        return arguments.length ? (i = t, n = 1 / (i || 60), h = this.time + n, l.wake(), void 0) : i;
      }, l.useRAF = function (t) {
        return arguments.length ? (l.sleep(), f = t, l.fps(i), void 0) : f;
      }, l.fps(t), setTimeout(function () {
        f && 5 > l.frame && l.useRAF(!1);
      }, 1500);
    }), n = l.Ticker.prototype = new l.events.EventDispatcher(), n.constructor = l.Ticker;
    var O = g("core.Animation", function (t, e) {
      if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, U) {
        o || a.wake();
        var i = this.vars.useFrames ? j : U;
        i.add(this, i._time), this.vars.paused && this.paused(!0);
      }
    });
    a = O.ticker = new l.Ticker(), n = O.prototype, n._dirty = n._gc = n._initted = n._paused = !1, n._totalTime = n._time = 0, n._rawPrevTime = -1, n._next = n._last = n._onUpdate = n._timeline = n.timeline = null, n._paused = !1;
    var _A = function A() {
      o && S() - R > 2e3 && a.wake(), setTimeout(_A, 2e3);
    };
    _A(), n.play = function (t, e) {
      return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
    }, n.pause = function (t, e) {
      return null != t && this.seek(t, e), this.paused(!0);
    }, n.resume = function (t, e) {
      return null != t && this.seek(t, e), this.paused(!1);
    }, n.seek = function (t, e) {
      return this.totalTime(Number(t), e !== !1);
    }, n.restart = function (t, e) {
      return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0);
    }, n.reverse = function (t, e) {
      return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1);
    }, n.render = function () {}, n.invalidate = function () {
      return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this;
    }, n.isActive = function () {
      var t,
        e = this._timeline,
        i = this._startTime;
      return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime()) >= i && i + this.totalDuration() / this._timeScale > t;
    }, n._enabled = function (t, e) {
      return o || a.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1;
    }, n._kill = function () {
      return this._enabled(!1, !1);
    }, n.kill = function (t, e) {
      return this._kill(t, e), this;
    }, n._uncache = function (t) {
      for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
      return this;
    }, n._swapSelfInParams = function (t) {
      for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
      return i;
    }, n._callback = function (t) {
      var e = this.vars;
      e[t].apply(e[t + "Scope"] || e.callbackScope || this, e[t + "Params"] || y);
    }, n.eventCallback = function (t, e, i, s) {
      if ("on" === (t || "").substr(0, 2)) {
        var r = this.vars;
        if (1 === arguments.length) return r[t];
        null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = f(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = s), "onUpdate" === t && (this._onUpdate = e);
      }
      return this;
    }, n.delay = function (t) {
      return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay;
    }, n.duration = function (t) {
      return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration);
    }, n.totalDuration = function (t) {
      return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration;
    }, n.time = function (t, e) {
      return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time;
    }, n.totalTime = function (t, e, i) {
      if (o || a.wake(), !arguments.length) return this._totalTime;
      if (this._timeline) {
        if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
          this._dirty && this.totalDuration();
          var s = this._totalDuration,
            r = this._timeline;
          if (t > s && !i && (t = s), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? s - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline;
        }
        this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && (this.render(t, e, !1), I.length && V());
      }
      return this;
    }, n.progress = n.totalProgress = function (t, e) {
      return arguments.length ? this.totalTime(this.duration() * t, e) : this._time / this.duration();
    }, n.startTime = function (t) {
      return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime;
    }, n.endTime = function (t) {
      return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale;
    }, n.timeScale = function (t) {
      if (!arguments.length) return this._timeScale;
      if (t = t || _, this._timeline && this._timeline.smoothChildTiming) {
        var e = this._pauseTime,
          i = e || 0 === e ? e : this._timeline.totalTime();
        this._startTime = i - (i - this._startTime) * this._timeScale / t;
      }
      return this._timeScale = t, this._uncache(!1);
    }, n.reversed = function (t) {
      return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed;
    }, n.paused = function (t) {
      if (!arguments.length) return this._paused;
      var e,
        i,
        s = this._timeline;
      return t != this._paused && s && (o || t || a.wake(), e = s.rawTime(), i = e - this._pauseTime, !t && s.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && this.render(s.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, !0, !0)), this._gc && !t && this._enabled(!0, !1), this;
    };
    var C = g("core.SimpleTimeline", function (t) {
      O.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0;
    });
    n = C.prototype = new O(), n.constructor = C, n.kill()._gc = !1, n._first = n._last = n._recent = null, n._sortChildren = !1, n.add = n.insert = function (t, e) {
      var i, s;
      if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), i = this._last, this._sortChildren) for (s = t._startTime; i && i._startTime > s;) i = i._prev;
      return i ? (t._next = i._next, i._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = i, this._recent = t, this._timeline && this._uncache(!0), this;
    }, n._remove = function (t, e) {
      return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this;
    }, n.render = function (t, e, i) {
      var s,
        r = this._first;
      for (this._totalTime = this._time = this._rawPrevTime = t; r;) s = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = s;
    }, n.rawTime = function () {
      return o || a.wake(), this._totalTime;
    };
    var D = g("TweenLite", function (e, i, s) {
        if (O.call(this, i, s), this.render = D.prototype.render, null == e) throw "Cannot tween a null target.";
        this.target = e = "string" != typeof e ? e : D.selector(e) || e;
        var r,
          n,
          a,
          o = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
          h = this.vars.overwrite;
        if (this._overwrite = h = null == h ? Y[D.defaultOverwrite] : "number" == typeof h ? h >> 0 : Y[h], (o || e instanceof Array || e.push && f(e)) && "number" != typeof e[0]) for (this._targets = a = u(e), this._propLookup = [], this._siblings = [], r = 0; a.length > r; r++) n = a[r], n ? "string" != typeof n ? n.length && n !== t && n[0] && (n[0] === t || n[0].nodeType && n[0].style && !n.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(u(n))) : (this._siblings[r] = G(n, this, !1), 1 === h && this._siblings[r].length > 1 && Z(n, this, null, 1, this._siblings[r])) : (n = a[r--] = D.selector(n), "string" == typeof n && a.splice(r + 1, 1)) : a.splice(r--, 1);else this._propLookup = {}, this._siblings = G(e, this, !1), 1 === h && this._siblings.length > 1 && Z(e, this, null, 1, this._siblings);
        (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -_, this.render(-this._delay));
      }, !0),
      M = function M(e) {
        return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType);
      },
      z = function z(t, e) {
        var i,
          s = {};
        for (i in t) B[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!E[i] || E[i] && E[i]._autoCSS) || (s[i] = t[i], delete t[i]);
        t.css = s;
      };
    n = D.prototype = new O(), n.constructor = D, n.kill()._gc = !1, n.ratio = 0, n._firstPT = n._targets = n._overwrittenProps = n._startAt = null, n._notifyPluginsOfEnabled = n._lazy = !1, D.version = "1.17.0", D.defaultEase = n._ease = new T(null, null, 1, 1), D.defaultOverwrite = "auto", D.ticker = a, D.autoSleep = 120, D.lagSmoothing = function (t, e) {
      a.lagSmoothing(t, e);
    }, D.selector = t.$ || t.jQuery || function (e) {
      var i = t.$ || t.jQuery;
      return i ? (D.selector = i, i(e)) : "undefined" == typeof document ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById("#" === e.charAt(0) ? e.substr(1) : e);
    };
    var I = [],
      F = {},
      N = D._internals = {
        isArray: f,
        isSelector: M,
        lazyTweens: I
      },
      E = D._plugins = {},
      L = N.tweenLookup = {},
      X = 0,
      B = N.reservedProps = {
        ease: 1,
        delay: 1,
        overwrite: 1,
        onComplete: 1,
        onCompleteParams: 1,
        onCompleteScope: 1,
        useFrames: 1,
        runBackwards: 1,
        startAt: 1,
        onUpdate: 1,
        onUpdateParams: 1,
        onUpdateScope: 1,
        onStart: 1,
        onStartParams: 1,
        onStartScope: 1,
        onReverseComplete: 1,
        onReverseCompleteParams: 1,
        onReverseCompleteScope: 1,
        onRepeat: 1,
        onRepeatParams: 1,
        onRepeatScope: 1,
        easeParams: 1,
        yoyo: 1,
        immediateRender: 1,
        repeat: 1,
        repeatDelay: 1,
        data: 1,
        paused: 1,
        reversed: 1,
        autoCSS: 1,
        lazy: 1,
        onOverwrite: 1,
        callbackScope: 1
      },
      Y = {
        none: 0,
        all: 1,
        auto: 2,
        concurrent: 3,
        allOnStart: 4,
        preexisting: 5,
        "true": 1,
        "false": 0
      },
      j = O._rootFramesTimeline = new C(),
      U = O._rootTimeline = new C(),
      q = 30,
      V = N.lazyRender = function () {
        var t,
          e = I.length;
        for (F = {}; --e > -1;) t = I[e], t && t._lazy !== !1 && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
        I.length = 0;
      };
    U._startTime = a.time, j._startTime = a.frame, U._active = j._active = !0, setTimeout(V, 1), O._updateRoot = D.render = function () {
      var t, e, i;
      if (I.length && V(), U.render((a.time - U._startTime) * U._timeScale, !1, !1), j.render((a.frame - j._startTime) * j._timeScale, !1, !1), I.length && V(), a.frame >= q) {
        q = a.frame + (parseInt(D.autoSleep, 10) || 120);
        for (i in L) {
          for (e = L[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
          0 === e.length && delete L[i];
        }
        if (i = U._first, (!i || i._paused) && D.autoSleep && !j._first && 1 === a._listeners.tick.length) {
          for (; i && i._paused;) i = i._next;
          i || a.sleep();
        }
      }
    }, a.addEventListener("tick", O._updateRoot);
    var G = function G(t, e, i) {
        var s,
          r,
          n = t._gsTweenID;
        if (L[n || (t._gsTweenID = n = "t" + X++)] || (L[n] = {
          target: t,
          tweens: []
        }), e && (s = L[n].tweens, s[r = s.length] = e, i)) for (; --r > -1;) s[r] === e && s.splice(r, 1);
        return L[n].tweens;
      },
      W = function W(t, e, i, s) {
        var r,
          n,
          a = t.vars.onOverwrite;
        return a && (r = a(t, e, i, s)), a = D.onOverwrite, a && (n = a(t, e, i, s)), r !== !1 && n !== !1;
      },
      Z = function Z(t, e, i, s, r) {
        var n, a, o, h;
        if (1 === s || s >= 4) {
          for (h = r.length, n = 0; h > n; n++) if ((o = r[n]) !== e) o._gc || o._kill(null, t, e) && (a = !0);else if (5 === s) break;
          return a;
        }
        var l,
          u = e._startTime + _,
          c = [],
          f = 0,
          p = 0 === e._duration;
        for (n = r.length; --n > -1;) (o = r[n]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (l = l || Q(e, 0, p), 0 === Q(o, l, p) && (c[f++] = o)) : u >= o._startTime && o._startTime + o.totalDuration() / o._timeScale > u && ((p || !o._initted) && 2e-10 >= u - o._startTime || (c[f++] = o)));
        for (n = f; --n > -1;) if (o = c[n], 2 === s && o._kill(i, t, e) && (a = !0), 2 !== s || !o._firstPT && o._initted) {
          if (2 !== s && !W(o, e)) continue;
          o._enabled(!1, !1) && (a = !0);
        }
        return a;
      },
      Q = function Q(t, e, i) {
        for (var s = t._timeline, r = s._timeScale, n = t._startTime; s._timeline;) {
          if (n += s._startTime, r *= s._timeScale, s._paused) return -100;
          s = s._timeline;
        }
        return n /= r, n > e ? n - e : i && n === e || !t._initted && 2 * _ > n - e ? _ : (n += t.totalDuration() / t._timeScale / r) > e + _ ? 0 : n - e - _;
      };
    n._init = function () {
      var t,
        e,
        i,
        s,
        r,
        n = this.vars,
        a = this._overwrittenProps,
        o = this._duration,
        h = !!n.immediateRender,
        l = n.ease;
      if (n.startAt) {
        this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
        for (s in n.startAt) r[s] = n.startAt[s];
        if (r.overwrite = !1, r.immediateRender = !0, r.lazy = h && n.lazy !== !1, r.startAt = r.delay = null, this._startAt = D.to(this.target, 0, r), h) if (this._time > 0) this._startAt = null;else if (0 !== o) return;
      } else if (n.runBackwards && 0 !== o) if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;else {
        0 !== this._time && (h = !1), i = {};
        for (s in n) B[s] && "autoCSS" !== s || (i[s] = n[s]);
        if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && n.lazy !== !1, i.immediateRender = h, this._startAt = D.to(this.target, 0, i), h) {
          if (0 === this._time) return;
        } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null);
      }
      if (this._ease = l = l ? l instanceof T ? l : "function" == typeof l ? new T(l, n.easeParams) : x[l] || D.defaultEase : D.defaultEase, n.easeParams instanceof Array && l.config && (this._ease = l.config.apply(l, n.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (t = this._targets.length; --t > -1;) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null) && (e = !0);else e = this._initProps(this.target, this._propLookup, this._siblings, a);
      if (e && D._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), n.runBackwards) for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
      this._onUpdate = n.onUpdate, this._initted = !0;
    }, n._initProps = function (e, i, s, r) {
      var n, a, o, h, l, _;
      if (null == e) return !1;
      F[e._gsTweenID] && V(), this.vars.css || e.style && e !== t && e.nodeType && E.css && this.vars.autoCSS !== !1 && z(this.vars, e);
      for (n in this.vars) {
        if (_ = this.vars[n], B[n]) _ && (_ instanceof Array || _.push && f(_)) && -1 !== _.join("").indexOf("{self}") && (this.vars[n] = _ = this._swapSelfInParams(_, this));else if (E[n] && (h = new E[n]())._onInitTween(e, this.vars[n], this)) {
          for (this._firstPT = l = {
            _next: this._firstPT,
            t: h,
            p: "setRatio",
            s: 0,
            c: 1,
            f: !0,
            n: n,
            pg: !0,
            pr: h._priority
          }, a = h._overwriteProps.length; --a > -1;) i[h._overwriteProps[a]] = this._firstPT;
          (h._priority || h._onInitAllProps) && (o = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0);
        } else this._firstPT = i[n] = l = {
          _next: this._firstPT,
          t: e,
          p: n,
          f: "function" == typeof e[n],
          n: n,
          pg: !1,
          pr: 0
        }, l.s = l.f ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), l.c = "string" == typeof _ && "=" === _.charAt(1) ? parseInt(_.charAt(0) + "1", 10) * Number(_.substr(2)) : Number(_) - l.s || 0;
        l && l._next && (l._next._prev = l);
      }
      return r && this._kill(r, e) ? this._initProps(e, i, s, r) : this._overwrite > 1 && this._firstPT && s.length > 1 && Z(e, this, i, this._overwrite, s) ? (this._kill(i, e), this._initProps(e, i, s, r)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (F[e._gsTweenID] = !0), o);
    }, n.render = function (t, e, i) {
      var s,
        r,
        n,
        a,
        o = this._time,
        h = this._duration,
        l = this._rawPrevTime;
      if (t >= h) this._totalTime = this._time = h, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (s = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === h && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > l || l === _ && "isPause" !== this.data) && l !== t && (i = !0, l > _ && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : _);else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === h && l > 0) && (r = "onReverseComplete", s = this._reversed), 0 > t && (this._active = !1, 0 === h && (this._initted || !this.vars.lazy || i) && (l >= 0 && (l !== _ || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || l === t ? t : _)), this._initted || (i = !0);else if (this._totalTime = this._time = t, this._easeType) {
        var u = t / h,
          c = this._easeType,
          f = this._easePower;
        (1 === c || 3 === c && u >= .5) && (u = 1 - u), 3 === c && (u *= 2), 1 === f ? u *= u : 2 === f ? u *= u * u : 3 === f ? u *= u * u * u : 4 === f && (u *= u * u * u * u), this.ratio = 1 === c ? 1 - u : 2 === c ? u : .5 > t / h ? u / 2 : 1 - u / 2;
      } else this.ratio = this._ease.getRatio(t / h);
      if (this._time !== o || i) {
        if (!this._initted) {
          if (this._init(), !this._initted || this._gc) return;
          if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = o, this._rawPrevTime = l, I.push(this), this._lazy = [t, e], void 0;
          this._time && !s ? this.ratio = this._ease.getRatio(this._time / h) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
        }
        for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== o && t >= 0 && (this._active = !0), 0 === o && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === h) && (e || this._callback("onStart"))), n = this._firstPT; n;) n.f ? n.t[n.p](n.c * this.ratio + n.s) : n.t[n.p] = n.c * this.ratio + n.s, n = n._next;
        this._onUpdate && (0 > t && this._startAt && t !== -1e-4 && this._startAt.render(t, e, i), e || (this._time !== o || s) && this._callback("onUpdate")), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && t !== -1e-4 && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === h && this._rawPrevTime === _ && a !== _ && (this._rawPrevTime = 0));
      }
    }, n._kill = function (t, e, i) {
      if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
      e = "string" != typeof e ? e || this._targets || this.target : D.selector(e) || e;
      var s,
        r,
        n,
        a,
        o,
        h,
        l,
        _,
        u,
        c = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
      if ((f(e) || M(e)) && "number" != typeof e[0]) for (s = e.length; --s > -1;) this._kill(t, e[s], i) && (h = !0);else {
        if (this._targets) {
          for (s = this._targets.length; --s > -1;) if (e === this._targets[s]) {
            o = this._propLookup[s] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[s] = t ? this._overwrittenProps[s] || {} : "all";
            break;
          }
        } else {
          if (e !== this.target) return !1;
          o = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all";
        }
        if (o) {
          if (l = t || o, _ = t !== r && "all" !== r && t !== o && ("object" != _typeof(t) || !t._tempKill), i && (D.onOverwrite || this.vars.onOverwrite)) {
            for (n in l) o[n] && (u || (u = []), u.push(n));
            if ((u || !t) && !W(this, i, e, u)) return !1;
          }
          for (n in l) (a = o[n]) && (c && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, h = !0), a.pg && a.t._kill(l) && (h = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete o[n]), _ && (r[n] = 1);
          !this._firstPT && this._initted && this._enabled(!1, !1);
        }
      }
      return h;
    }, n.invalidate = function () {
      return this._notifyPluginsOfEnabled && D._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], O.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -_, this.render(-this._delay)), this;
    }, n._enabled = function (t, e) {
      if (o || a.wake(), t && this._gc) {
        var i,
          s = this._targets;
        if (s) for (i = s.length; --i > -1;) this._siblings[i] = G(s[i], this, !0);else this._siblings = G(this.target, this, !0);
      }
      return O.prototype._enabled.call(this, t, e), this._notifyPluginsOfEnabled && this._firstPT ? D._onPluginEvent(t ? "_onEnable" : "_onDisable", this) : !1;
    }, D.to = function (t, e, i) {
      return new D(t, e, i);
    }, D.from = function (t, e, i) {
      return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new D(t, e, i);
    }, D.fromTo = function (t, e, i, s) {
      return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new D(t, e, s);
    }, D.delayedCall = function (t, e, i, s, r) {
      return new D(e, 0, {
        delay: t,
        onComplete: e,
        onCompleteParams: i,
        callbackScope: s,
        onReverseComplete: e,
        onReverseCompleteParams: i,
        immediateRender: !1,
        lazy: !1,
        useFrames: r,
        overwrite: 0
      });
    }, D.set = function (t, e) {
      return new D(t, 0, e);
    }, D.getTweensOf = function (t, e) {
      if (null == t) return [];
      t = "string" != typeof t ? t : D.selector(t) || t;
      var i, s, r, n;
      if ((f(t) || M(t)) && "number" != typeof t[0]) {
        for (i = t.length, s = []; --i > -1;) s = s.concat(D.getTweensOf(t[i], e));
        for (i = s.length; --i > -1;) for (n = s[i], r = i; --r > -1;) n === s[r] && s.splice(i, 1);
      } else for (s = G(t).concat(), i = s.length; --i > -1;) (s[i]._gc || e && !s[i].isActive()) && s.splice(i, 1);
      return s;
    }, D.killTweensOf = D.killDelayedCallsTo = function (t, e, i) {
      "object" == _typeof(e) && (i = e, e = !1);
      for (var s = D.getTweensOf(t, e), r = s.length; --r > -1;) s[r]._kill(i, t);
    };
    var $ = g("plugins.TweenPlugin", function (t, e) {
      this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = $.prototype;
    }, !0);
    if (n = $.prototype, $.version = "1.10.1", $.API = 2, n._firstPT = null, n._addTween = function (t, e, i, s, r, n) {
      var a, o;
      return null != s && (a = "number" == typeof s || "=" !== s.charAt(1) ? Number(s) - Number(i) : parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2))) ? (this._firstPT = o = {
        _next: this._firstPT,
        t: t,
        p: e,
        s: i,
        c: a,
        f: "function" == typeof t[e],
        n: r || e,
        r: n
      }, o._next && (o._next._prev = o), o) : void 0;
    }, n.setRatio = function (t) {
      for (var e, i = this._firstPT, s = 1e-6; i;) e = i.c * t + i.s, i.r ? e = Math.round(e) : s > e && e > -s && (e = 0), i.f ? i.t[i.p](e) : i.t[i.p] = e, i = i._next;
    }, n._kill = function (t) {
      var e,
        i = this._overwriteProps,
        s = this._firstPT;
      if (null != t[this._propName]) this._overwriteProps = [];else for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
      for (; s;) null != t[s.n] && (s._next && (s._next._prev = s._prev), s._prev ? (s._prev._next = s._next, s._prev = null) : this._firstPT === s && (this._firstPT = s._next)), s = s._next;
      return !1;
    }, n._roundProps = function (t, e) {
      for (var i = this._firstPT; i;) (t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next;
    }, D._onPluginEvent = function (t, e) {
      var i,
        s,
        r,
        n,
        a,
        o = e._firstPT;
      if ("_onInitAllProps" === t) {
        for (; o;) {
          for (a = o._next, s = r; s && s.pr > o.pr;) s = s._next;
          (o._prev = s ? s._prev : n) ? o._prev._next = o : r = o, (o._next = s) ? s._prev = o : n = o, o = a;
        }
        o = e._firstPT = r;
      }
      for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;
      return i;
    }, $.activate = function (t) {
      for (var e = t.length; --e > -1;) t[e].API === $.API && (E[new t[e]()._propName] = t[e]);
      return !0;
    }, d.plugin = function (t) {
      if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
      var e,
        i = t.propName,
        s = t.priority || 0,
        r = t.overwriteProps,
        n = {
          init: "_onInitTween",
          set: "setRatio",
          kill: "_kill",
          round: "_roundProps",
          initAll: "_onInitAllProps"
        },
        a = g("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () {
          $.call(this, i, s), this._overwriteProps = r || [];
        }, t.global === !0),
        o = a.prototype = new $(i);
      o.constructor = a, a.API = t.API;
      for (e in n) "function" == typeof t[e] && (o[n[e]] = t[e]);
      return a.version = t.version, $.activate([a]), a;
    }, s = t._gsQueue) {
      for (r = 0; s.length > r; r++) s[r]();
      for (n in p) p[n].func || t.console.log("GSAP encountered missing dependency: com.greensock." + n);
    }
    o = !1;
  }
}( true && module.exports && "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : this || window, "TweenMax"); /**
                                                                                                                         * Created by Web-Mosaica on 02.09.2019.
                                                                                                                         */

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/assets/js/app": 0,
/******/ 			"assets/css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkwmcrm"] = self["webpackChunkwmcrm"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["assets/css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["assets/css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;